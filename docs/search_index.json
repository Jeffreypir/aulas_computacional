[
["index.html", "ESTATÍSTICA COMPUTACIONAL Disciplina ministrada à alunos do bacharelado em estatística da UFPB Início", " ESTATÍSTICA COMPUTACIONAL Disciplina ministrada à alunos do bacharelado em estatística da UFPB Docente: Prof. Dr. Pedro Rafael Diniz Marinho E-mail: pedro.rafael.marinho@gmail.com / pedro@de.ufpb.br Início Última atualização: 27/06/2019 Departamento de Estatística (UFPB): http://www.de.ufpb.br/ Licença O material Estatística Computacional do Prof. Pedro Rafael. D. Marinho está licenciado com uma Licença Creative Commons - Atribuição-NãoComercial-CompartilhaIgual 4.0 Internacional. Isso quer dizer: Você tem o dirieto de copiar e redistribuir o material em qualquer suporte ou formato; Você tem o direito de remixar, transformar e criar a partir deste material; Você deve dar crédito apropriado, fornecer um link para a licença e indicar se foram feitas alterações. Você pode fazê-lo de qualquer maneira razoável, mas de nenhuma maneira que sugira que o licenciador endossa você ou seu uso; Você não poderá utilizar o material para fins comerciais; Se você remixar, transformar, ou criar a partir do material, tem de distribuir as suas contribuições sob a mesma licença que o original. Sendo assim, não poderá aplicar termos jurídicos ou medidas de caráter tecnológico que restrinjam legalmente outros de fazerem algo que a licença permita. Maiores detalhes a respeito da licença em: https://creativecommons.org/licenses/by-nc-sa/4.0/. Observação: Os códigos que estão presentes nesse material estão sobre os termos GNU General Public License (\\(\\geq 3\\), versão três ou superior). Assim, o leitor poderá fazer uso de qualquer código desse material em seus projetos, pacotes, desde que cite a fonte. Além disso, todas as imagens utilizadas nesse material são de uso livre e não comercial. Na barra superior desse material você poderá encontrar um ícone para download das minhas aulas de R. Trata-se de um Portable Document Format (PDF) que contém minhas aulas de R. O material das aulas está sujeito a mesma licença desse material. Você é livre para utilizar e remixar, desde que referencie o autor e o Departamento de Estatística da UFPB. Além disso, você deverá deixar claro quais foram as modificações realizadas. Importante: Esse material está sob constante aprimoramento e sugestões poderão ser enviadas para o repositório do GitHub que hospeda este conteúdo. Uma vez que o material está sendo mantido e versionado no GitHub, as alterações podem ser realizadas diretamente no arquivo fonte do projeto, bastando clicar no ícone em formato de um lápis, no canto superior esquerdo desta página, ou das páginas em que se desejam sugerir alterações, como correções de palavras, mudanças de parágrafos, alteração de códigos, melhoramento de exemplos, inclusão de novos exemplos, etc. As alterações serão bem vindas e serão acatadas (incorporadas ao arquivo orignal) na medida que forem julgadas como sendo convenientes. Nota: Para que seja possível propor alterações é necessário que você saiba utilizar o git/GitHub e tenha realizado um fork do trabalho em sua conta do GitHub. Apreder a utilizar o git/GitHub poderá ser muito útil (dentro da academia ou fora dela), uma vez que você saberá versionar seus códigos, artigos e trabalhos em geral. "],
["prefacio.html", "Prefácio Tecnologias abordadas no curso Teorias abordadas no curso Sugestões de passos para revisão da linguagem R", " Prefácio Esse material sempre tentará se adequar à ementa da disciplina de Estatística Computacional, sendo esta uma disciplina obrigatória do curso de bacharelado em estatística do Departamento de Estatística da UFPB. Dessa forma, trata-se de um material destinado à alunos do Departamento de Estatística da UFPB. Porém, esse material poderá vir a despertar interesse à outras pessoas que não alunos da instituição. A ementa do curso de Estatística Computacional, que compõe a estrutura do curso como disciplina obrigatória, poderá ser obtida no link. Como pode-se observar, a disciplina é dividida no uso de tecnologias (linguagem de marcação e linguagem de programação) e alguns aspectos teóricos que envolvem a teoria de estatística computacional. O bom uso dos conceitos abordados no curso estará alinhado ao perfeito entendimento das tecnologias e teorias apresentadas. Importante: O tópico referente à tipografia científica em LaTeX não será abordado, visto que esse assunto atualmente está sendo apresentado na disciplina de Metodologia do Trabalho Científico, no início do curso de bacharelado em estatística da UFPB. Além disso, o tópico referente à programação em R abordará aspectos mais avançados da linguagem, uma vez que a essa altura do curso, os alunos entendem os conceitos básicos da linguagem R. Para quem deseja revisar a linguagem R, estou disponibilizando as aulas do meu curso introdutório de programação em R. As aulas estão divididas em dois arquivos. Curso de programação em R: Acesse o primeiro arquivo clicando aqui; Acesse o segundo arquivo clicando aqui. O curso introdutório de programação em R é dividido em dois arquivos, mas você poderá optar em baixar um único arquivo PDF clicando no ícone na barra superior desse material. Note que o Curso de Estatística Computacional não é o material adequado para você, caso o seu enteresse seja aprender a linguagem de programação R. Em um futuro próximo, quando este material estiver concluído e caso você já considere um usuário avançado de R, talvez pular para os assuntos referentes aos aspectos teóricos de estatística computacional venha ser o caminho mais produtivo para o seu aprendizado. Tecnologias abordadas no curso Uso de git e GitHub para versionamento de projetos; Linguagem de marcação: LaTeX; R Markdown; Linguagem de programação R sob um olhar mais avançado: Orientação à objeto utilizando funções genéricas (sistema S3 de orientação à objeto); Sistema R6 de orientação à objeto; Expressões regulares (regex); Uso de funcionais. Nessa parte será revisado os funcionais do base r bem como serão apresentados novos funcionais; Construção de pacotes em R; Uso de pacotes que incorporam características novas à linguagem R, entre eles, alguns dos pacotes da comunidade do RStudio; Closures; Checando a peformance do código e identificando gargalos; Conceitos de metaprogramação; Paralelismo em R (OpenMP). Em substituição ao item 2, trataremos do rmardkown, em especial, do uso do pacote bookdown para a construção de relatórios e livros dinâmicos utilizando a linguagem de marcação markdown. Por exemplo, esse material foi construído utilizando essas ferramentas. Nota: Um bom material em língua portuguesa sobre o LaTeX poderá ser obtido no aqui. Trata-se do curso intitulado Breve Introdução ao LaTeX2\\(\\varepsilon\\), do Prof. Lenimar Nunes de Andrade do Departamento de Matemática da UFPB. Para começar a estudar o LaTeX, você precisará instalar em seu computador um compilador do código de LaTeX e um editor para seus textos escritos utilizando a linguagem de marcação LaTeX. Abaixo listo os programas que você deverá instalar em seu computador para poder iniciar o estudo do material de LaTeX. TeX Live: Trata-se de uma distribuição do TeX padrão para a maior parter dos sistemas *nix (derivados de Unix, incluindo o Linux e macOS). O TeX Live também está disponível para o sistema operacional Windows. Clique aqui para baixar o arquivo de instalação. No processo de instalação você precisará estar conectado à internet, uma vez que o instalador precisará baixar diversos arquivos nos espelhos de distribuição do TeX Live. Uma das vantagens TeX Live é a sua velocidade na compilação de um arquivo com extensão .tex. TeXstudio: O TeXstudio é um editor de texto para o sistema LaTeX. Um outro bom editor que você poderá considerá para utilizar em seus estudos é o Texmaker, que assim como o TeXstudio, está disponível para os sistemas operacionais Linux, macOS e Windows. Teorias abordadas no curso Geração de números pseudo-aleatórios: Método da inversão; Método da aceitação-rejeição; Método da transformação. Métodos de Monte Carlo; Métodos de reamostragem: Jackknife; Bootstrap: estimação de erro-padrão, correção de viés, construção de intervalos aleatórios, testes de hipóteses, bootstrap de Wu (bootstrap selvagem). Algumas dessas metodologias serão apresentadas em esquemas simples (um nível de bootstrap) e duplo (dois níveis de bootstrap). Métodos de otimização não-linear em estatística: métodos de Newton e quasi-Newton. Sugestões de passos para revisão da linguagem R É aconselhado que antes de prosseguir nesse material o leitor faça uma revisão básica da linguagem R. Entre os princiapis conceitos necessários para uma boa progressão nesse curso, destacam-se: Entender as diferenças do funcionamento de um compilador para um interpretador. Lembre-se, R é uma linguagem interpretada; Revise os principais tipo de dados: character, double, integer e logical. Lembre-se que por regra de coerção, os tipos mais flexíveis em R seguem a seguinte regra de flexibilidade: character &gt; double &gt; integer &gt; lógico. Isso quer dizer, por exemplo, que se a é um vetor que possui elementos do tipo character e double, então todos os elementos do vetor serão coagidos para o tipo mais flexível, que nesse caso é o tipo character. Exemplo: a &lt;- c(1, letters[1:5]); is.character(a[1]) retornará TRUE. Lembre-se que R “não possui” constantes. Constantes são tratadas como vetores atômicos de comprimento 1. Esses são chamados de atômicos por serem a estrutura básica da linguagem, uma vez que R é uma linguagem vetorial. Além disso, lembres-se que listas também são vetores, porém, não-atômicos. Veja que, por exemplo, is.vector(list(1)) retornará TRUE. Por falar em vetores atômicos, chamaremos simplesmente de vetores, revise as principais estruturas de dados em R: vetores (c()), fatores (factor()), listas (list()), matrizes (matrix()), sequência de matrizes (arrays()) e tabelas (data.frames()). Note que uma matriz é um array de comprimento 1. Não confunda estrutura de dados com tipo de dados. Estruturas de dados refere-se ao mecanismo de organização de dados, já o tipo de dados refere-se ao tipo básico das informações que são organizadas nessas estruturas; Entenda o uso das funções is.troque() e as.troque(), em que troque poderá ser ser substituido por: Um Estrutura de dados: vector, factor, list, numeric, data.frame, matrix, array, etc. Um Tipos de dados: integer, double, numeric, character, logical, etc. Revise os operadores relacionais e lógicos: Operadores Relacionais: ==(igual), &lt; (menor), &lt;= (menor ou igual), &gt; (maior), &gt;= (maior ou igual), != (diferente); Operadores Lógicos: || (OU lógico), &amp;&amp; (E lógico), ! (NÃO lógico). Esses são operadores não vetorizados. Os operadores | e &amp; são as versões vetorizadas dos operadores || e &amp;&amp;, ou seja, por exemplo, c(2,3) &lt; c(1,1)) | (c(2,1) &gt;= c(2,3)) retornará o vetor c(TRUE, FALSE) e (c(2,3) &lt; c(1,4)) | (c(2,1) &gt;= c(2,3)) retornará c(TRUE, TRUE), respectivamente. Perceba que utilizar o operador | OU lógico é realizado sobre a ordem das posições dos elementos nos vetores; Revise as estruturas de condições: if, else, switch e ifelse. A função ifelse() equivale à estrutura (condição) ? retorno 1 : retorno 2 das linguagens C/C++; Revise as estruturas de repetições: while, for e repeat. Entenda o uso das instruções break e next quando utilizadas dentro dessas estruturas. Revise a definição de funções. Tente entender a flexibilidade embutida em funções que retornam uma lista. Isso se deve ao fato de uma lista ser uma estrutura heterogênea que poderá retornar qualquer estrutura de dados, incluindo outra(s) lista(s). Isso é interessante, uma vez que normalmente desejamos que uma função retorne mais de um objeto, sendo estes objetos quaisques, podendo ter as mais variadas estruturas e tipos de dados. Se achar necessário, revise algumas funções úteis: ls(), rm(), length(), sum(), abs(), mean(), median(), var(), sd(), cor(), summary(), sqrt(), exp(), expm1() (fornece uma boa proximação para exp(x) - 1, quando x é pequeno), log(), log10(), log1p() (fornece uma boa aproximação para log(x+1) quando x é pequeno), round(), union(), intersect(), choose(), factorial(), dim(), ncol(), nrow(), diag(), %*%, t(), solve(), det(), eigen(), print(), cat(), paste(), paste0(), substring(),str(), sort(), quantile(), match() e %in%. Lembre-se que quando os operadores +, -, *, /, %% (módulo / resto da divisão) e ^ são aplicados entre matrizes, ou entre matrizes e vetores de comprimento 1 (“constantes”), as operações serão realizadas elemento à elemento. Diversas outras características da linguagem R são importantes e serão lembradas, aos poucos, na medida que for necessário. Ficará a cargo do leitor fazer as sugestões de revisões acima. O capítulo que inicia esse material é dedicado à apresentação de exercício que o leitor deverá resolver. Trata-se de um capítulo em que os exercícios envolvem as sugestões de revisão da linguagem R apresentadas acima. Os exercícios para serem resolvidos poderão exigir revisões de outros conceitos que não foram listados na proposta de revisão acima. No entanto, se esses exercícios forem bem resolvidos, utilizando-se de boas práticas de programação em R, a leitura desse material será a mais agradável possível. Considere as aulas de R disponibilizadas como um ponto de apoio. "],
["revisao-basica-da-linguagem-r.html", "1 Revisão básica da linguagem R Exercícios propostos", " 1 Revisão básica da linguagem R Mesmo que você se considere um programador razoável de R, aconselho que venha resolver a lista de exercícios apresentada adiante. É comum que venhamos esquecer de alguns conceitos de linguagens em que programamos. Esses exercícios é uma oportunidade que você irá ter de revisar lógica de programação utilizando a linguagem R e consequentemente revisar alguns conceitos importantes, porém básicos, da linguagem. Tente resolver esses exercícos após um olhar detalhado das sugestões apresentadas. A lista de assuntos para revisão sugerem temas bastante simples para quem já programa um pouco na linguagem R. Tais sugestões aliadas com as resoluções desses exercício irão lapidar os conhecimentos necessários e fará com que você necessariamente revise outros assuntos inseridos nos exercícios. Estes assuntos/exercícios também são simples e não envolverão conceitos avançados da linguagem R. Conceitos mais avançados serão abordados no decorrer do curso de Estatística Computacional e exercícios estarão disponíveis no decorrer de outros capítulos, à medida que forem necessários. Observação: A google disponibilizou um guia de estilo de programação em R. Trata-se de um guia de boas práticas de programação, no que diz respeito à escrita do código. Esse guia não trata de boas práticas de programação para a obtenção de melhorias de desempenho da linuguagem R. Você não é obrigado adotar essas normas. Porém, segui-las tornará o seu código mais legível. Exercícios propostos Descreva o funcionamento e as diferenças de um compilador para um interpretador. Liste exemplos de linguagens de programação compiladas e interpretadas. Responda os itens abaixo: Descreva os principais tipos de dados da linguagem R. Descreva as principais estruturas de dados da linguagem R. Disserte sobre as diferenças entre tipos de dados e estruturas de dados. Descreva quais estruturas de dados são homogêneas e quais estruturas são heterogêneas. Explique o por quê das saídas abaixo: x &lt;- c(7.1, 2.3, 3L, TRUE) x ## [1] 7.1 2.3 3.0 1.0 y &lt;- c(TRUE, letters[1:3]) y ## [1] &quot;TRUE&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; z &lt;- c(1.0, 5, 7, 0L) z ## [1] 1 5 7 0 Sem utilizar o R, o que você espera como retorno de x &lt;- c(1, c(2, c(3, 4))); x. Qual a estrutura de dados de x? Irá ocorrer erro ao tentar criar um vetor atômico (vetor) com objetos de tipos diferentes? Como o interpretador de R trata essas situações. Explique detalhadamente. O que signicica NA, NaN, Inf e -Inf, em R? Liste algumas das situações em que utilizando-se das operações básicas +, -, * e / poderemos ter NaN como retorno. Considere vetor &lt;- c(2, 7, 10, 8). Qual o tipo de dados do objeto vetor? Crie os objetos vetor_int, vetor_character e vetor_logical. Dica: crie esses objetos utilizando funções para conversão dos tripos dos elementos do objeto vetor. O que faz o código abaixo? Explique detalhadamente o que cada função faz. objects(grep(&quot;bas&quot;, search())) Qual o retorno do código abaixo? Explique detalhadamente o código. search()[(grep(&quot;gr&quot;, search()))] Forneça o código que acessa o caracter \"a\" de l, em que l &lt;- c(list(c(3, 2), \"a\"), c(1,2)). Depois, converta l em um vetor atômico. Sem executar os códigos abaixo, descreva as saídas esperadas: Qual a saída esperada para os códigos c(1, FALSE), c(\"a\", 1), c(list(1), \"a\"), c(TRUE, 1L)? Por que 1 == \"1\" retornará TRUE? Explique. Por que -1 &lt; FALSE retornará TRUE? Explique. Considere o objeto vetor &lt;- 1:25. Com o objeto vetor, construa uma matriz de ordem 5x5 usando a função matrix() e depois utilizando a função dim(). Crie a matriz M, de ordem 50x50, com elementos de 1 à 2500 preenchidos por linha. Atribua nomes às linhas (l_1 à l_50) e colunas (c_1 à c_50) de M. Dica: certamente você percebeu que não será nada interessante digitar os nomes das linhas e colunas de M. Tente utilizar as funções paste() e rep()como soluções para esse problema. Remova os nomes das linhas e colunas da matriz M criada no exercício anterior. Sejam V1 &lt;- matrix(1:12, ncol = 4, nrow = 3) e W1 &lt;- matrix(1:8, ncol = 4, nrow = 2). Crie a matriz M1que é o resultado da concatenação, por linha, de V1 e W1. Considere os objetos V2 &lt;- matrix(1:12, ncol = 2, nrow = 4) e W2 &lt;- matrix(1:12, ncol = 3, nrow = 4). Cria a matriz M2como resultados da concatenação, por coluna, de V2 e W2. Considere obj &lt;- list(1:3, \"a\" , TRUE, 1.0). Construa uma matriz de ordem 2x2 a partir de obj. O que de interessante você observa? Construa a matriz A (matriz de avaliações), de ordem 30x2, em que a primeira coluna são os nomes dos alunos (Aluno_1 à Aluno_30) e a segunda coluna são as notas de 3 avaliações, por aluno. Dica: para facilitar, gere as avaliações dos alunos de forma aleatória. O que a função dim() retorna quando aplicada à um vetor? Se is.matrix(x) retorna TRUE, o que irá retornar de is.array(x)? Explique. Descreva os objetos objetos x1, x2 e x3 construídos na forma apresentada abaixo: x1 &lt;- array(1:5, c(1, 1, 5)) x2 &lt;- array(1:5, c(1, 5, 1)) x3 &lt;- array(1:5, c(5, 1, 1)) Considere o código apresentado abaixo: df &lt;- data.frame(x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df$y ## [1] a b c ## Levels: a b c Qual a estrutura de dados de df$y? Como poderemos alterar o comportamento do data frame df para que df$y retorne um vetor atômico com elementos do tipo character? Ao tentar criar um data frame com o código abaixo obteremos um erro. Corrija o código: data.frame(x = 1:3, y = list(1:2, 1:3, 1:4)) ## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 2, 3, 4 Considere a lista abaixo: notas &lt;- list(c(7.1, 3.2, NA), c(2.7, 8.8, 10.0), c(0.0, NA, NA), c(7.7, 8.4, 6.3), c(3.6, 6.6, 8.1), c(NA, NA, NA), c(7.4, 7.1, 7.3), c(10.0, NA, 7.0), c(1.6, 3.2, 5.3), c(8.8, 9.2, 8.0)) Responta os itens abaixo: Atribua nomes (Aluno_1 à Aluno_10) à cada elemento de notas. Crie o vetor status contendo o status dos dez alunos. Considere: A (aprovado), REP (reprovado), F (final). Dica: construa o vetor status atribuindo literalmente as categorias A, REP ou F para cada aluno, ou seja, não é preciso criar uma função para fazer isso automaticamente. Considere A para os alunos com média no intervalo \\([7, 10]\\), R para os alunos com média no intervalo \\([0, 4)\\) e F para os alunos com média no intervalo \\([4, 7)\\). Crie o vetor alunos com os nomes dos alunos. Obtenha esse vetor por meio do objeto notas. Construa o data frame historico com as variáveis nomes, notas e status. Com base no data frame historico, construa o data frame aprovados com os alunos aprovados. De forma análoga, construa um data frame para cada um dos demais status, respectivamente. Suponha que o professor está interessado em saber quais alunos foram ou tem alguma chance de assumir o status de aprovado. Construa o data frame bons_alunos com estes alunos. Modifique os nomes das linhas do data frame historico colocando id_1 na primeira linha e respectivamente, no mesmo padrão, para as demais linhas. Obtenha por meio do data frame historico um novo data frame (historico_na) com os alunos que deixaram ao menos uma prova para repor. Apenas para os alunos que fizeram as três avaliações, obtenha a média aritmética das avaliações. Acrescente a variável de nome media como última coluna do data frame historico. Consideremos o conjunto de dados state.x77 do pacote datasets (pacote padrão de R). A base state.x77 refere-se à um objeto de ordem 50x8, em que cada linha refere-se à um dos 50 estados dos EUA. Consulte a documentação (help(state.x77)) para obter maiores informações. Responda os itens abaixo: Qual a estrutura de dados do objeto state.x77? Construa o data frame dados utilizando state.x77. Obtenha o data frame de nome dados_1 com os estados estadunidenses que possuem população maior que 4246 (quatro milhões duzentos e quarenta e seis mil). Obtenha o data frame dados_2 com os estatdos estadunidenses que possuem população maior que 4246 e menor que 8 milhões, isto é, menor que 8000. Obtenha o vetor vetor_est com os nomes dos estados que obedecem os critérios do item 3. Construa o data frame dados_3 com os estados estadunidenses que possuem população maior que 1.5 vezes a média dos 50 estados considerados. Obtenha um vetor com o nome dos estados que obedecem essa restrição. Construa o data frame dados_4 com os estados estadunidenses que possuem população maior que duas vezes a mediana dos 50 estados e que tenha uma população com expectativa de vida maior que 71.84 anos. Obtenha o data frame dados_5 com os estados estadunidenses cuja população possuem renda maior que a média nacional e expectativa de vida maior que 72 anos. Adicione ao data frame dados duas linhas com as médias e variâncias de todas as variáveis, respectivamente. Escreva um programa que retorne a saída baixo: i1 = 1 i2 = 2 i3 = 3 i4 = 4 i5 = 5 i6 = 6 i7 = 7 Dica: Resolva esse simples exercício de três formas diferentes (usando while, for e repeat). Escreva uma função que retorne o imposto pago por mulheres e por homens, sabendo que as mulheres pagam \\(10\\%\\) e que os homens pagam \\(5\\%\\) a mais do que as mulheres. Resolva o exercício anterior utilizando a função switch(). Implemente a função tab(num, inicio, fim) que é responsável por escrever no prompt de commando a tabuada de um número passado como argumento à num. Nota: os argumentos inicio e fim referem-se ao início e fim da tabuada, ou seja, tab(num = 1, inicio = 7, fim = 12) deverá escrever no prompt: 1 x 7 = 7 1 x 8 = 8 1 x 9 = 9 1 x 10 = 10 1 x 11 = 11 1 x 12 = 12 Implemente tab() utilizando as diferentes escruturas de repetição da linguagem R (for, while e repeat). Escreva a função celtofar() que converte um vetor de temperaturas em graus Celsius para graus Fahrenheit. Considere: \\[F = 1.8 \\times C + 32,\\] em que \\(C\\) é a temperatura em graus Celsius e \\(F\\) é a temperatura em graus Fahrenheit. Melhore a função celtofar() para que critique valores não válidos de temperaturas. Modifique a função celtofar() para que funcione também para conversões no sentido oposto, isto é, para que converta de graus Fahrenheit para graus Celsius. Construa a função imc() que calcula o IMC (Índice de Massa Corporal) de uma pessoa. A função deverá retornar o IMC e um status. Observe que: \\[\\mathrm{IMC} = \\frac{\\mathrm{peso}}{\\mathrm{altura}^2},\\] em que \\(\\mathrm{peso}\\) é dado em \\(kg\\) e a \\(\\mathrm{altura}\\) é fornecida em \\(cm\\). Alem disso, considere: IMC Status \\(&lt; 17.0\\) Muito abaixo do peso \\([17.0, 18.5)\\) Abaixo do peso \\([18.5, 25.0)\\) Peso normal \\([25.0, 30.0)\\) Acima do peso \\([30.0, 35.0)\\) Obesidade nível I \\([35.0, 40.0)\\) Obesidade nível II (severa) \\(\\geq 40.0\\) Obesidade nível III (mórbida) Dica: Uma função robusta deverá tratar problema(s) com a(s) entrada(s), isto é, deverá criticar informações inconsistentes passadas como argumento. Utilizando a instrução de repetição for construa um pequeno programa que com base em um vetor de valores no intervalo \\([0, 1]\\), some apenas os valores maiores que 0.7. Dica: para economizar tempo, considere vetor &lt;- runif(n = 1e5, min = 0, max = 1). Resolva o exercício anterior sem utilizar nenhuma instrução de repetição. Avalie o custo computacional dos exercícios anteriores (exercícios 34 e 35) utilizando a função Sys.time(). Discuta o resultado. Construa a função central(x) que recebe como argumeto um vetor passado à x e retorna algumas medidas de tendência central. A função central() deverá retornar: Média aritmética (média amostral): \\(\\overline{x} = n^{-1}\\sum_{i = 1}^n x_i.\\) Média geométrica: \\(G = (\\prod_{i=1}^n x_i)^{\\frac{1}{n}}.\\) Média harmônica: \\(H = \\frac{n}{\\frac{1}{x_1} + \\cdots + \\frac{1}{x_n}}.\\) Algumas exigências a respeito do funcionamento da função central() encontram-se enumeradas abaixo: 1 - A função deverá retornar todas as três medidas de tendência central ou apenas uma das estatísticas, a depender do interesse do usuário. 2 - Observações Not Availables NA serão eleminadas do cálculo. Porém, uma mensagem de aviso ao usuário da função deverá ser emitida informando-o a repseito do número de observações eliminadas e em quais posições encontravam-se estas observações. 3 - A função deverá alertar o usuário se uma estrutura/tipo de dados não suportado por central() for passado como argumento à x. A função deverá alertar qual estrutura/tipo de dados foi passado, avinsando assim que essa estrutura/tipo de dados não poderá vir a ser processado(a). Nota: Não utilize a vetorização da linguagem R. Nesse exercício desejamos treinar o uso das estruturas de repetições da linguagem. Não utilizar vetorização da linguagem quer dizer que você não poderá aplicar uma função à todos elementos de um vetor. Por exemplo, se x é um vetor, você não poderá fazer x^2, sqrt(x), mean(x), length(), etc. Aplique a função a cada posição do vetor utilizando estruturas de repetições. Em seus projetos reais, utilize a capacidade de vetorização da linguagem e evite o quanto der as estruturas de repetições. Isso fará com que os seus códigos sejam mais eficientes. Aqui apenas queremos exercitar o uso das estruturas de repetições. Além disso, central() poderá ter outros argumentos além de x. Sem utilizar a capacidade de vetorização da linguagem R, nas formas do exercício anterior, implemente a função myvar(x) que retorna a variância amostral de um vetor passado como argumetno à x. Algumas exigências a respeito do funcionamento da função myvar() encontram-se enumeradas abaixo: 1 - A função deverá retornar todas as três medidas de dispersão ou apenas uma das estatísticas, a depender do interesse do usuário. 2 - Observações Not Availables NA serão eleminadas do cálculo. Porém, uma mensagem de aviso ao usuário deverá ser passada informando o número de observações eliminadas e em quais posições encontravam-se. 3 - A função deverá alertar o usuário se uma estrutura ou tipo de dados não coerente com o interesse da função for passado como argumento à x. Nota: Não utilize a vetorização da linguagem R. Nesse exercício desejamos treinar o uso das estruturas de repetições da linguagem. Não utilizar vetorização da linguagem quer dizer que você não poderá aplicar uma função à todos elementos de um vetor. Por exemplo, se x é um vetor, você não poderá fazer x^2, sqrt(x), mean(x), length(), etc. Aplique a função a cada posição do vetor utilizando estruturas de repetições. Em seus projetos reais, utilize a capacidade de vetorização da linguagem e evite o quanto der as estruturas de repetições. Isso fará com que os seus códigos sejam mais eficientes. Aqui apenas queremos exercitar o uso das estruturas de repetições. Além disso, myvar() poderá ter outros argumentos além de x. Se x, na função myvar(), for um vetor não numérico? E se x for um vetor de caracteres numéricos? E se x for uma string numérica como \"1,2,3\" que desejamos tratar como sendo o c(1, 2, 3)? Modifique a função myvar() para que venham tratar/considerar essas situações. Implemente a função disp(x) que deverá retornar uma das medidas de dispersão listadas logo abaixo: Amplitude: \\(A = x_{\\mathrm{max}} - x_{\\mathrm{min}}.\\) Variância amostral: \\(S^2 = \\frac{\\sum_{i=1}^{n}(x_i - \\overline{x})^2}{n-1}.\\) Desvio padrão amostral: \\(S = \\sqrt{S^2}.\\) Coeficiente de variação: \\(CV = \\frac{100 \\times S}{\\overline{x}}.\\) Algumas exigências a respeito do funcionamento da função disp() encontram-se enumeradas abaixo: 1 - A função deverá retornar todas as quatro estatísticas ou apenas uma das estatísticas, a depender do interesse do usuário. 2 - Observações Not Availables NA serão eleminadas do cálculo. Porém, uma mensagem de aviso ao usuário deverá ser passada informando o número de observações eliminadas e em quais posições encontravam-se. 3 - A função deverá alertar o usuário se uma estrutura ou tipo de dados não coerente com o interesse da função for passado como argumento à x. Nota: Não utilize a vetorização da linguagem. Nesse momento também desejamos treinar o uso das estruturas de repetições da linguagem. Implemente a função mycor(x, y, pearson = TRUE, rm.na = TRUE) que deverá receber como argumentos dois vetores passados para x e y, respectivamente. A função mycor() deverá retornar o coeficiente de correlação de Pearson se pearson = TRUE, caso contrário, retornará o coeficiente de correlação de Spearman. Além disso, se rm.na = TRUE, a função mycor() deverá eliminar os Not Availables NA dos respectivos vetores. Por exemplo, se x &lt;- c(1, 8, -1, NA, NA) e y &lt;- c(NA, 7, -2, 10, 5) forem passados para mycor(), esta deverá eliminará as duas últimas observações de x e y, bem como a primeira observação de x e y, resultando, nesse exemplo, em x &lt;- c(8, -1) e y &lt;- c(7, -2), respectivamente. A função deverá alertar a respeito das eliminações e informar quais as posições eliminadas dos vetores. Algumas outras exigências a respeito do funcionamento da função mycor() encontram-se enumeradas abaixo: 1 - A função deverá parar e alertar o usuário nas situações em que os vetores não tenham os mesmos comprimentos. 2 - A função deverá retornar dois objetos, rho e level, em que rho (\\(\\rho\\)) é o valor da correlação e level informa o nível dessa correlação. Os níveis possível a ser retornados são: desprezível se \\(\\rho \\in [0, 0.3)\\), fraca se \\(\\rho \\in [0.3, 0.5)\\), moderada se \\(\\rho \\in [0.5, 0.7)\\), forte se \\(\\rho \\in [0.7, 0.9)\\) e fortíssima se \\(\\rho \\in [0.9, 1]\\). Dica: A função warning() pode ser útil para emitir uma mensagem de aviso (alerta) ao usuário da função mycor(). Construa duas funções, tree1() e tree2(), que escrevam, no prompt de comando, as imagens abaixo, respectivamente. O programa deverá utilizar instruções de repetições para resolver o problema. A primeira função deverá imprimir: ********** ********* ******** ******* ****** ***** **** *** ** * A segunda função deverá imprimir: *-*-*-*-*- *-*-*-*-* *-*-*-*- *-*-*-* *-*-*- *-*-* *-*- *-* *- * Implemente as funções utilizando as estruturas de repetições for, while e repeat. Escreva a função tree3(), utilizando instruções de repetições, de modo a fornecer as seguintes estruturas, adepender do valor de n. Para \\(n = 1\\): * Para \\(n = 2\\): * ** Para \\(n = 3\\): * ** *** e assim por diante para outros valores de \\(n\\). Implemente tree3() utilizando as estruturas de repetições for, while e repeat. Melhore as funções tree1(), tree2() e tree3() de modo que estas possam considerar caracteres distintos e não somento o caracter asterisco. Modifique a função tree1(), de tal forma que a estrutura obtida seja: Para \\(n = 1\\): A Para \\(n = 2\\): A BB Para \\(n = 3\\): A BB CCC e assim por diante para outros valores de \\(n\\). Dica: Note que \\(n \\leq 26\\). Assim, retorne uma mensagem de advertência se um valor de \\(n\\) inapropriado for informado. Dica: utilize a função stop(). Implemente a função aprox_e() que retorna uma aproximação para \\(\\mathrm{e}^x\\), em que: \\[\\mathrm{e}^x = \\sum_{n = 0}^{\\infty} \\frac{x^n}{n!}.\\] Dica: A função aprox_e() deverá receber como argumento o número de somas a serem consideradas. Crie a função aprox_pi(), fazendo uso de instruções de repetição, que forneça uma aproximação para o valor da constante \\(\\pi\\). Essa aproximação deverá considerar: \\[\\pi = 4 - \\frac{4}{3} + \\frac{4}{5} - \\frac{4}{7} + \\frac{4}{9} - \\frac{4}{11} + \\dots\\] Dica: Premita que o usuário de sua função forneça a quantidade de termos a serem somados. Além disso, faça com que sua função critique valores indevidos para a quantidade de termos somados. Implemente a função fib(), utilizando instruções de repetição, que retorna o Fibonacci de um número. Lembre-se, a sequência de Fibonacci é dada por \\(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \\ldots\\) . Note que Fibonacci de \\(n\\) é dado por \\(F_n = F_{n-1} + F_{n-2},\\, n &gt; 2\\), com \\(F_1 = 1\\) e \\(F_2 = 1\\). Por exemplo, Fibonacci de 5 é dado por \\(F_5 = F_{4} + F_{3} = 3 + 2 = 5\\). Implemente o exercício anterior usando funções recursivas. Lembre-se: chamamos de funções recursivas as funçãos que chamam a si mesma. Um esboço de função recursiva: func_f &lt;- function(...){ # Ué? ... # Sim! Estamos chamando a função que estamos criando. ;) func_f(...) # Será preciso parar em algum momento # somos finitos :) if (contition) break } Implemente a função aprox_pi() de forma recursiva. Implemente a função nachange(df), em que df recebe um data frame/matriz. A função nachange() deverá trocar NA pelo character “?”. Dica: Em caso de df não possuir nenhum elemento NA, a função nachange() deverá retornar o objeto passado à df. Construa a função searchindf(df, value), em que df é um data frame/matriz e value é um vetor de uma única posição. A função searchindf()deverá retorna TRUE se o valor passado para value é encontrado em alguma posição do data frame/matriz passado(a) para df e FALSE caso contrário. Dica: tente construir a função da forma mais robusta possível. Por exemplo, considere criticar os argumentos, caso estes não tenham a estrutura de dados adequada ao objetivo da função. Construa a função namecolsort(df), em que df receberá como argumento um(a) data frame/matriz. A função namecolsort() deverá retorna o(a) data frame/matriz com as colunas ordenadas. Dica: ordene as colunas considerando o primeiro caracter que compõe o nome da coluna (variável). Escreva a função exclusive(df), em que df receberá como argumento um(a) data frame/matriz. A função exclusive() deverá retornar a posição das linhas exclusivas, ou seja, as linhas que não possuem elementos repetidos. Escreva uma função extremeindex(df, max = NULL), em que df receberá como primeiro argumento um(a) data frame/matriz. A função maxindex() deverá retornar a posição (linha, coluna) do valor máximo contido no objeto passado para df, caso max = TRUE. Em caso de max = FALSE, a função maxindex() deverá retornar a posição (linha, coluna) do valor mínimo contido no objeto passado à df. Para o caso de max = NULL (caso padrão), a função maxindex() deverá retornar uma matriz de ordem 2x2, em que cada linha deverá retornar a posição do elemento mínimo e máximo, respectivamente, contidos no objeto passado à df. Implemente a função myt(df), em que dfrecebe como argumento um(a) data frame/matriz. A função myt() deverá “girar”, em 90 graus, a(o) matriz/data frame passado à df. Dica: não utilize a função t() para transpor a matriz. Crie a função anagram(x, y) que recebe dois argumentos (duas strings). A função anagram() deverá retornar TRUE se uma palavra (string) é anagrama da outra e FALSE em situação contrária. A função deverá considerar que ambas as strings possuem a mesma quantidade de caracteres. Caso a quantidade de caracteres não seja igual, em ambas as strings, a função deverá parar e advertir o usuário. Dica: você poderá utilizar a função strsplit(). Implemente a função strposition(x), em que dado uma palavra (string) fromada por letras do alfabeto Romano e passada como argumento para x, retorna a posição das letras em um vetor. Por exemplo, a string (palavra) cada passada para a função fará com que strposition() retorne o vetor formados pelos elementos 3, 1, 4 e 1. Dica: a função não poderá aceitar strings que são formadas por pelo menos um caracter que não seja uma letra do alfabeto Romano. Altere a função strposition(x) para que em situação da string (palavra) possuir um ou mais caracteres não pertencentes ao alfabeto Romano, o retono seja NA, nas respectivas posições destes caracteres. "],
["o-evangelho-do-gnulinux.html", "2 O Evangelho do GNU/Linux 2.1 Um breve histórico 2.2 Vantagens em utilizar GNU/Linux 2.3 Algumas distribuições", " 2 O Evangelho do GNU/Linux Nesse capítulo tentarei convencê-lo, sem imposições, que o uso de alguma distribuição GNU/Linux poderá ser um caminho coerente e que trará facilidades para quem deseja um sistema operacional flexível, fácil de manter e livre. Tentarei aqui expressar minhas experiências no uso do linux, de uma forma geral, e na estatística. Ao final, listarei algumas distribuições GNU/Linux que considero interessantes. Observação: Você é livre para escolher o sistema operacional (SO) que deseja trabalhar. Porém, em situações em que seja necessário dissertar sobre alguma configuração específica do sistema (não serão muitas), as explicações apresentadas levarão em consideração, na maioria dos casos, sistemas GNU/Linux. Se você for meu aluno, tentarei esforçar-me um pouco mais. 2.1 Um breve histórico Em meados de 1970, o Unix foi (ainda é) um dos sistemas operacionais mais amplamente utilizados em mainframes devido à sua ampla confiabilidade, distribuição e suporte. Muitos desses sistemas Unix tratavam-se de sistemas proprietários. Entre os sistemas Unix mais populares e livres estava o Berkley Software Distribution (BSD) cujo desenvolvimento (1977 a 1995) era realizado pela Computer Systems Research Group (CSRG), vinculado à Universidade da Califórnia, em Berkely. Nota: Nos dias de hoje, o termo BSD é utilizado para designar qualquer sistema operacional do tipo Unix (sistemas Unix-like). Muitas vezes o termo Unix-like é substituído por UN*X ou *nix. Tratam-se de sistemas operacionais baseados em Unix, mas que não necessariamente estão de acordo com a especificação Single UNIX. O sistema Linux (kernel) foi baseado no Unix, sendo este o sistema Unix-like mais popular dentre diversos outros que são razoavelmente conhecidos pelo público em geral e bastante conhecidos por profissionais que tem alguma afinidade com a computação. A maioria dos sistemas BSD’s, disponíveis na atualidade, possuem o código fonte aberto, porém fazem o uso da licença BSD que é menos restritiva, permitindo, por exemplo, que apenas os arquivos binários sejam distribuídos. Trata-se de uma licença atraente para aplicativos embarcados, em que empresas não estão obrigadas a disponibilizar o código fonte das suas aplicações, quando estes forem solicitados. Devido a licença BSD ser menos restritivas que a licença GNU General Public License, utilizada pelo Linux, por diversos outros programas e bibliotecas de código aberto, alguns sistemas BSD’s conhecidos possuem código proprietário. No caso dos sistemas BSD’s proprietários, muito provavelmente se você solicitar os códigos às empresas que os construíram o seu pedido não será atendido. Entre os sistemas operacionais BSD’s de código fechado mais conhecidos, destacam-se dois: 1 - O sistema Solaris, em que nas suas primeiras versões era chamado de SunOS. Esse sistema BSD foi desenvolvido pela Sun Microsystems, que em 2009, foi adquirida pela Oracle Corporation. Detalhes a respeito do sistema Solaris podem ser encontrados no site da Oracle. 2 - O macOS, sistema operacional produzido pela empresa Apple. Muito provavelmente o macOS é um dos *nix mais conhecidos. Porém, o macOS está longe de ser o sistema *nix mais amplamente utilizados em supercomputadores. Saindo do território dos sistemas BSD’s proprietários, abaixo listo alguns dos mais conhecidos sistemas BSD’s, em que os códigos dos projetos são abertos, isto é, com iniciativas Open Source: 1 - FreeBSD: Trata-se de um sistema moderno, livre e que é bastante utilizado em servidores, desktops e plataformas embarcadas. O FreeBSD é talvez o sistema BSD, de código livre, que é mais amplamente utilizado entre os sistemas dessa lista. A melhor forma de acompanhar as novidades do FreeBSD é ler o FreeBSD Journal, um jornal livre dos desenvolvedores do FreeBSD. Seu mascote genérico é o BSD daemon, apelidado de Beastie. 2 - NetBSD: Trata-se de uma derivação do sistema 4.4BSD da Universidade da California, Berkley e do 386BSD, às vezes chamado de Jolix. Assim como o FreeBSD, o NetBSD é um sistema que pode rodar em diversas arquiteturas de computadores. O seu logo é uma bandeirola. 3 - OpenBSD: Trata-se de um projeto baseado no sistema 4.4BSD. O projeto OpenBSD desenvolveu aplicações como o OpenSSH que é a principal ferramenta de conectividade para login remoto utilizando o protocolo Secure Shell (SSH). O seu mascote é o Puffy. 4 - DragonFly BSD: Os seus desenvolvedores afirmam que trata-se de um sistema operacional pertencente à mesma classe de outros sistemas baseados em BSD e Linux, porém inclue recursos que o diferenciam de outros sistemas operacionais. Por exemplo, o DragonFly BSD possue o HAMMER, um moderno sistema de arquivos de alta peformance. O mascote do projeto é uma libélula. Observação: Linux é uma marca registrada de Linus Torvalds. Você poderá ver essa informação aqui. Além disso, Linux é um *nix, UN*X ou Unix-like (como queira chamar), mas Linux não é um BSD, nem um BSD é um Linux. Por exemplo, a biblioteca C do BSD é baseada nos códigos de Berkeley e não na GNU C Library. Dessa forma, diferentemente dos diversos sistemas BSD’s, o Linux utiliza-se de alguns recursos fornecidos pelo GNU C. O sistema operacional Linux foi inicialmente desenvolvido pelo engenheiro de software Linus Torvalds em 1991. Atualmente o Linux conta com diversos desenvolvedores espalhados pelo mundo, em que Linus Torvads é o principal desenvolvedor. Não é difícil adivinhar o porquê do nome Linux. Figura 2.1: Linus Torvalds em uma conferência para o TED intitulada A mente por trás do Linux, 2016. Nessa época, inícios dos anos 90, Linus Torvalds era discente na Universidade de Helsinque, Finlândia como estudante de ciência da computação. Sua dissertação de mestrado intitulada Linux: a Portable Operating System (56 páginas) foi defendida no Departamento de Ciência da Computação da Universidade de Helsinque, em 31 de janeiro de 1997. A dissertação introduz problemas de protabilidade do kernel Linux em diferentes arquiteturas de computadores. O autor comenta que quem acompanhou os primórdios do desenvolvimento do kernel Linux, o título de sua dissertação poderia soar como ironia, uma vez que o projeto original do Linux não estava realmente preocupado com a portabilidade do sistema em diversas arquiteturas de processadores. À época, a preocupação maior do projeto era com a execução do Linux em computadores com processadores Motorola 68k Amiga e Atari, ambos de 32 bits. Isso restringia o uso de Linux em algumas arquiteturas de PCs doméstricos da época. Segundo Torvalds, a implementação do Linux foi baseada em três questões principais. São elas: 1 - Simplicidade: Muito embora o kernel de um sistema operacional é algo complexo, e isso não é diferente no Linux, a implementação mais simples possível é um dos pilares do projeto. 2 - Eficiência: Uma vez que o kernel está envolvido com quase todas as atividades de uma máquina (PCs, mainframes, entre outros), a implementação do kernel Linux busca a eficiência, ou seja, o kernel nunca poderá ser visto como uma restrição de desempenho. 3 - Compatibilidade: O que está ocorrendo por baixo do kernel de um sistema operacional poderá ser de interesse para pesquisadores na área de sistemas operacionais. Dessa forma, um sistema operacional não poderá impor “surpresas” ao usuário comum ou mesmo à um programador. O Linux é um sistema operacional robusto e disponível para funcionar em diversas arquiteturas e sem “surpresas”. “Embora o projeto Linux tenha sido intimamente associado a mim pessoalmente, em parte devido ao nome, gostaria de deixar bem claro que o sistema operacional Linux é um grande projeto feito cooperativamente por muitas pessoas em todo o mundo. Mesmo se você desconsiderar todos os programas em nível de usuário que são parte integrante de qualquer sistema Linux, apenas o kernel contém código de centenas de pessoas ao redor do mundo. Obrigado a todos vocês.” — Linus Torvalds, Linux: a Portable Operating System, página 3. A todo momento, nessa nossa conversa, a expressão kernel foi utilizada junto com o termo Linux. Isso normalmente é feito para deixar claro que o Linux é um programa que gerencia os seus hardwares e o funcionamento dos programas que você utiliza no seu dia a dia, caso você esteja utilizando uma distribuição Linux, é claro. Porém, se você ainda não está utilizando o Linux nesse momento, saiba que o seu sistema operacional possui um kernel, sendo este a parte mais importante do sistema. Figura 2.2: Tux, logo desenvolvido pelo programador Larry Ewing e idealizado por Linus Torvalds como mascote do projeto Linux. Para que um sistema operacional venha ser utilizado pela maioria das pessoas, em que nesse grupo nos incluímos, este deverá conter diversos outros programas e recursos além do kernel propriamente dito. Para nós que trabalhamos com estatística, por exemplo, precisamos de ter a nossa disposição outras linguagens de programação além de C, como R, C++, Java, Go, Lua, Rust, Ruby, Julia, Python, entre outras linguagens, além de IDEs (Integrated Development Environment) para desenvolvimento dos nossos programas, softwares para escrita de relatórios, sistemas de gerenciamento de banco de dados, sistermas de versionamento, entre diversos outros programas de interesse. Anterior ao início do desenvolvimento do Linux (kernel), Richard Matthew Stallman, conhecido por muitos programadores pela sigla rms, tinha anunciado no final de 1983 o projeto do sistema operacional GNU (Projeto GNU). Figura 2.3: Logo do projeto GNU, lançado em 27 de setembro de 1983, por Richard Stallman Richard Matthew Stallman (rms). O desenvolvimento do sistema operacional GNU (sistema tipo Unix, Unix-like) teve início em 1984 com o auxílio de diversos programadores. Nesse projeto, os programadores iniciaram o desenvolvimento das ferramentas principais de um sistema operacional em paralelo ao desenvolvimento de editores de textos, compiladores da linguagem C, clientes de e-mail, interfaces gráficas, entre outras aplicações de interesses para o usuário final. Figura 2.4: Richard Matthew Stallman (rms), fundador do movimento de software livre, do projeto GNU e da Free Software Fundation em uma de suas palestras. Por volta de 1990, o sistema operacional GNU já estava quase todo completo mas faltava uma peça fundamental e indispensável em qualquer SO - o kernel. Nessa época, já havia-se um microkernel de nome GNU Hurd. Então, após a construção das aplicações principais, o foco seria em concentrar esforços no melhoramento do kernel Hurd. Porém, por volta de 1992, quando o kernel Linux foi anunciado como software livre, este pareceu ser mais viável a se juntar ao sistema GNU. Dessa forma, a combinação do kernel Linux com o quase completo sistema GNU resultou em um sistema opracional completo e assim sugiu o GNU/Linux. Nota: No início do desenvolvimento do Linux (kernel), por volta de 1991, o compilador GCC do projeto GNU já estava pronto (lançamento em 23 de maio de 1987) e este compunha umas das diversas ferramentas construídas para o sistema GNU. Linus Torvalds utilizada e ainda utiliza o GCC como compilador de C para o desenvolvimento do kernel Linux. Como já dito anteriormente, o Linux utiliza alguns recursos fornecidos do GNU C. Assim, note a grande importância do projeto GNU e do próprio Richard Stallman para o projeto Linux. Originalmente o GCC suportava apenas a linguagem C e à época era denominado de GNU C Compiler (compilador C GNU). Atualmente o GCC tem suporte à diversas linguagens de programação e pode ser utilizado para compilar em diversas arquiteturas de computadores. Abaixo enumero algumas linguagens de programação em que atualmente é possível compilar utilizando o GCC: 1- C: linguagem de programação compilada de propósito geral, estruturada, imperativa, procedural criada em 1972 por Dennis Ritchie na empresa AT&amp;T Bell Labs para desenvolvimento do sistema operacional Unix. 2- C++: linguagem de programação compilada, multi-paradigma e de uso geral desenvolvida por Bjarne Stroustrup, um famoso cientística da computação dinamarquês e professor catedrático da Universidade do Texas. C++, inicialmente denominada de C com classes (C with Classes) surgiu em 1983 no Bell Labs. 3- Fortran: família de linguagens de programação conhecida globalmente como Fortran. Fortran foi desenvolvida a partir da década de 1950 e continua a ser usada hoje em dia. O nome é um acrônimo da expressão IBM Mathematical FORmula TRANslation System. Fortran foi muito utilizada na área de computação científica e ainda continua sendo bastante utiliza pelo pessoal da “velha guarda”. 4- Object-C: linguagem de programação orientada a objeto inspirada nas linguagens Smalltalk e C. 5- Java: linguagem de programação orientada a objetos desenvolvida na década de 90, por uma equipe de programadores chefiada por James Gosling, na empresa Sun Microsystems. Em 2008 o Java foi adquirido pela empresa Oracle Corporation. 6- Go: linguagem de programação criada pela Google e lançada como código livre em novembro de 2009. 7- D: linguagem de programação de uso geral projetada por Walter Bright da Digital Mars. É baseada majoritariamente em C++, apesar de não ser apenas uma variante. A versão estável da primeira especificação foi lançada em janeiro de 2007. 8- Ada: linguagem de programação estruturada e de tipagem estática. É uma linguagem imperativa, orientada a objetos e de alto nível, originada de Pascal, Simula e outras linguagens. Figura 2.5: Logo do GNU Compiler Collection, denominado de GCC produzidos pelo projeto GNU, em que o ovo faz alusão à origem do (Projeto GNU). O logo do GCC acima é interessante e resume um pouco do que foi dito. Uma das primeiras ferramentas para se construir programas de computador, principalmente em uma época dominada por linguagens compiladas, é um compilador. Sendo assim, foi por meio do GCC que surgiu todas as aplicações do projeto GNU. O logo representa o nascimento de um gnu, mamífero nativo do continente africano que é utilizado como símbolo/logo (Figura 2.3) do projeto GNU. Observação: O compilador GCC está em amplo desenvolvimento, incorporando novas ferramentas, tecnologias e suporte à novas linguagens de programação. Voltando ao Linux, no seu desenvolvimento existem colaborações de diversos programadores ao redor do mundo, em que Linus Torvalds é o pricipal desenvolvedor e gerencia o rumo que o projeto deverá seguir. Nota: Aqui você poderá acessar a conta oficial do Linus Torvalds no GitHub. Você poderá acompanhar todas as modificações e quando estas foram incluídas no projeto Linux. Mais adiante, nesse material, trataremos a respeito do uso do git/GitHub. Por sinal, o git foi criado pelo Linus Torvalds. Diversas distribuições de GNU/Linux são mantidas de acordo com suas características particulares, combinações de softwares, interfaces gráficas, estruturas de diretórios, sistemas de configurações, comunidades, entre outras. Dessa forma, entenda as distribuições Linux com uma combinação de versões de kernel Linux (agora chamaremos apenas de Linux) com diversas ferramentas/softwares do projeto GNU e outros softwares e bibliotecas podendo ser proprietários ou não. Porém, em sua essência, as distribuições Linux são livres para serem modificadas. O que normalmente poderá haver de proprietário em algumas distribuições Linux refere-se à drives, como por exemplo os drives de placas de vídeos, impressoras ou de algum hardware que você esteja utilizando. É bastante comum que diversas empresas disponibilizem versões com iniciativas Open Source de seus drives. Quando não fazem isso, sendo assim mais restritivas, estas empresas disponibilizam versões de softwares que são free (de graça para uso) mas de código fechado. Porém, quando se utiliza alguma distribuição GNU/Linu,x não é algo comum a dependência de softwares proprietários, uma vez que a a comunidade Linux é muito grande e já desenvolveu diversas alternativas com iniciativas Open Source para softwares proprietários. 2.2 Vantagens em utilizar GNU/Linux O uso de alguma distribuição GNU/Linux taz diversas facilidades para o usuário comum, aquele que utiliza o computador no seu dia a dia ou para nós que programamos e temos interesse com a estatística, em especial na área de estatística computacional. Essas facilidades estão fortimente relacionadas com a desenvoltura que um sistema GNU/Linux tem de ser configurado e adaptado para as necessidades do usuário. Há diversas outras vantagens em inclinar-se para o uso de alguma distribuição GNU/Linux, como por exemplo a sua robustez, confiabilidade e seu gerenciamento eficiente de memória. Essa última característica do Linux é algo de grande importância para os estatísticos ou programadores que trabalham com estatística, uma vez que é comum termos que carregar objetos (matrizes, tabelas, vetores, etc) que ocupam muito espaço na memória do computador. Abaixo enumero, sob minha ótica, as vantagens que um “não convertido” poderá considerar na hora de meditar sobre a necessidade de considerar uma distribuição GNU/Linux: 1 - Imagine que você precisa comprar um carro e que uma de suas opções refere-se à um carro com o motor totalmente lacrado, ou seja, suponha que jamais você irá conseguir ver o que está abaixo do capô. No início, muito provavelmente tudo funcionará bem, ao menos aparentemente. O carro irá parecer ágil, seguro e com o som do funcionamento do motor aparentemente perfeito. Porém, a medida que você vai utilizando o carro, problemas irão aparecendo, sons estranhos, motor aquecenendo, etc. Em distribuições GNU/Linux o capô é aberto, ou seja, se utilizam de iniciativas Open Source. 2 - Por consequência do item 1, você não precisa pagar para utilizar uma distribuição GNU/Linux. Dessa forma, você será um profissional que uma empresa poderá querer, uma vez que ela não precisará pagar licenças anuais de um sistema operacional para você utilizar. 3 - As distribuições GNU/Linux são normalmente menos vulneráveis à vírus e malwares, não havendo assim, em minha opinião, a necessidade de instalação de anti-vírus, muito embora estes existam para sistemas GNU/Linux. 4 - A medida que os sistemas operacionais evoluem, seus requisitos de hardwares aumentam de forma exponencial. Existem inúmeras distribuições GNU/Linux disponíveis. Algumas dessas distribuições irão exigir muito pouco dos seus hardwares. Dessa forma, você poderá dar vida à uma máquina antiga. 5 - É muito fácil, em uma distribuição GNU/Linux, manter o SO e os seus programas atualizados. Não há a necessidade de dilapidar o seu tempo para manter o sistema e softwares atualizados. Dependendo da distribuição GNU/Linux escolhida, o programa utilizado para essa tarefa poderá ser diferente. Seja qual for, eles normalmente cumprem o papel ao qual foram destinados. 6 - Linux é instalado na maioria dos servidores, demonstrando que trata-se de uma ótima escolha. Além disso, à medida que diversos aplicativos estão migrando para plataforma nas nuvens, a quantidade de aplicações, que hoje já é muito grande, está ficando ainda maior. 7 - Linux está em todo lugar e muito provavelmente está, de alguma forma, no seu celular ou TV, caso estes utilizem o sistema Android. O Android desenvolvido pela Google é baseado no kernel do Linux. 8 - A quantidade de usuários do GNU/Linux capacitados é muito grande. Nas comunidades você muito provavelmente encontrará alguém disposto para te ajudar com alguma dúvida/problema relacionado ao sistema/programação. 9 - Para nós que precisamos constantemente realizar simulações científicas, poderá surgir a necessidade da utilização de computadores eficientes (supercomputadores) em que você irá acessar a distância. Normalmente esses supercomputadores rodam alguma distribuição GNU/Linux. Acessar e submeter suas simulações nessas máquinas de alta performance é algo muito mais simples e sem grandes dores de cabeça quando usamos o GNU/Linux (alguma distribuição Linux). No Brasil há diversos CENAPAD (Centro Nacional de Processamento de Alto Desempenho), em que você poderá submeter uma proposta de projeto e usufruir do poder computacional dessas máquinas. Após conseguir uma conta, você terá que ler a documentação de como utilizar o sistema para submeter seus jobs (suas simulações), ou seja, isso exigirá que você esteja familiarizado com o uso de sistemas GNU/Linux. 2.3 Algumas distribuições Como mencionado anteriormente, as distribuições GNU/Linux fornecem diversas experiências/“sabores” no uso de Linux, variando no que diz respeito ao tamanho das comunidades, interfaces gráficas, pré-configurações realizadas, repositórios de programas, entre diversas outras características. Porém, todas as distribuições GNU/Linux tem em comum o uso do kernel Linux, podendo variar as versões e as frequências de atualizações do kernel e dos demais programas. Nota: Algumas distribuições GNU/Linux são mais papulares que outras. Isso não diz muito sobre a qualidade da distribuição, uma vez que todas elas utilizam um kernel robusto - o kernel Linux. O nível de popularidade de uma distribuição Linux normalmente está diretamente relacionado ao nível de facilidade que você terá em conseguir soluções para possíveis problemas que sempre nos deparamos ao utilizar qualquer SO. Abaixo listo algumas distribuições GNU/Linux populares: 1 - Debian: é uma distribuição GNU/Linux lançada em 1993. A distribuição Debian também tem grande importância história devido ao fato de ter influenciado diversas distribuições GNU/Linux, entre elas Ubuntu e Mint. 2 - Arch: Trata-se de uma distribuição GNU/Linux bastante flexível e com uma comunidade muito ativa. O Arch Linux foi lançado em 2002 e inicialmente desenvolvido por Judd Vinet. Porém, atualmente o projeto Arch Linux é mantido por diversos programadores espalhados pelo mundo. Outras grandes características da distribuição Arch além de ter uma comunidade intensa é a qualidade de suas documentações, em que muito provavelmente você encontrará uma instrução para tudo o que você precisa. Além disso, um ponto importante refere-se ao seu gerenciador de pacote (pacman) que é bastante organizado e fácil de utilizar. Arch é uma distribuição Rolling Release, ou seja, ao contrário das distribuições Fixed Relase que divulgam novos lançamentos importantes em intervalos regulares de tempo, uma distribuição Rolling Release tem atualizações passadas de forma mais contínua. 2 - Fedora: Trata-se de uma distribuição GNU/Linux lançada em 2003 e financiada principalmente pela Red Hat. 3 - Ubuntu: É uma distribuição Linux muito conhecida, baseada no Debian e que foi desenvolvida pela Canonical Ltd. A distribuição Ubuntu diferencia da distribuição Debian em torno da filosofia de sua concepção e periodicidade de atualizações. 5 - Manjaro: Trata-se de uma das distribuições GNU/Linux lançada em 2011, bastante robusta e baseada no Arch Linux. Todas as características destacadas para o Arch Linux são características também presente no Manjaro. Ao contrário do Arch Linux, em que um usuário iniciante no Linux poderia sentir dificuldades em utilizar, o Manjaro é uma distribuição Linux fácil de instalar e utilizar. Em um ambiente de trabalho poderemos não querer gastar muitos esforços para instalar uma distribuição GNU/Linux. Uma lista de algumas distribuções populares de sistemas *nix podem ser obtida no DistroWatch.com. Porém, note que há diversas outras distribuições GNU/Linux sendo criadas ou mesmo já criadas mas que não estão listadas no site. Como sugestão de uma boa distribuição Linux a se considerar, sugiro que testem a distribuiçao Manjaro. Muito provavelmente vocês irão desejar possuir uma distribuição bem atualizada e com as versões mais recentes de programas, linguagens e bibliotecas. A distribuição Manjaro é distribuída oficialmente com as interfaces gráficas XFCE, KDE e GNOME. Abaixo apresento algumas figuras do Manjaro utilizando as interfaces gráficas XFCE, KDE e GNOME, respectivamente. Manjaro com XFCE Figura 2.6: Distribuição Manjaro utilizando XFCE como interface gráfica. Manjaro com KDE Figura 2.7: Distribuição Manjaro utilizando KDE como interface gráfica. Manjaro com GNOME Figura 2.8: Distribuição Manjaro utilizando GNOME como interface gráfica. Você poderá baixar a iso de instalação da distribuição Manjaro, com algumas dessas interfaces gráficas, clicando aqui. Há diversos vídeos no YouTube ensinando a baixar, instalar e configurar o Manjaro. Busque pelo termo Instalando Manjaro Linux ou clique aqui. Nota: Além dessas interfaces gráficas, o Manjaro é mantido pela comunidade com outras interfaces gráficas, a exemplo das interfaces MATE, Cinnamon e Deepin. Aconselho que venha considerar o download da versão com a interface GNOME, mas esse é um gosto pessoal meu. Independente da interface que você deseja utilizar, você continua utilizando o Manjaro com o kernel Linux. É isso o que realmente importa! Entre diversas comunidades disponíveis, você poderá considerar a comunidade Manjaro Brasil. Trata-se de uma comunidade ativa e receptiva. Essa comunidade é um exemplo de um bom lugar para você sanar suas dúvidas e fazer perguntas sobre Linux e especialmente a respeito do Manjaro. Além dos diversos sites que te ajudam a aprender o Linux, você poderá procurar por vídeos no YouTube a respeito do assunto. Por exemplo, procure pelos termos Instalando manjaro, Comandos no manjaro, Utilizando pacman instalar programas, etc. Vasculhar a internet é uma ótima maneira para entender o Linux e a distribuição de sua escolha. "],
["versionamento-de-codigo.html", "3 Versionamento de código 3.1 Git 3.2 GitHub", " 3 Versionamento de código Na estatística, bem como em diversas outras áreas, a todo momento estamos editando documentos, como por exemplo, códigos de programação, artigos, relatórios, aulas, apresentações, livros, dentre inúmeros outros possíveis. Nesses processos de edições dos mais variádos documentos, quase sempre sentimos a necessidade de versionar as alterações, uma vez que se não houver um versionamento e se desejarmos voltar à um estado de edição anterior, estariamos sobre uma tarefa extremamente difícil ou mesmo impossível, a depender do número de passos anteriores ao qual desejamos voltar. Quando não dominamos nenhum sistema de controle de versão, normalmente o que fazemos para ter a possibilidade de voltar para uma dada versão de edição é armazenar diversas cópias do projeto em diretórios distintos. Versionar dessa forma pode servir quando temos poucas versões, porém, mesmo assim, é comum os desarranjos e atrapalhos no gerenciamento de diversos diretórios. Quando há o domínio de um sistema de controle de versão evitamos esse tipo de problema, uma vez que continuaremos trabalhando sobre um mesmo diretório que terá seus estados modificados quando solicitado, isto é, será possível voltar para a distribuição de arquivos e conteúdos anteriores, mesmo se nesse processo de edição alguns arquivos foram deletados, renomeados ou fortemente modificados. Importante: Não se preocupe se você voltar à estados anteriores e desistir. Você poderá retornar à estados mais recentes (incluindo o último) sem nenhum problema. Deixe o trabalho sujo com o sistema de versionamento. Além disso, para nós estatísticos que vivemos codificando e constantemente alterando códigos de programação, versionar de forma eficiente é algo crucial. 3.1 Git Visando ajudar o desenvolvedor na tarefa de versionamento de projetos/códigos, a ferramenta git foi desenvolvida, escrita utilizando a linguagem C, por Linus Torvalds (criador do Linux) e atualmente mantido por Jun Hamano, um engenheiro de sofware japonês. No git, cada diretório de trabalho é um repositório com histórico completo das versões e não depende de acesso à um servidor ou rede central. Essa é uma das características que torna o git uma ferramenta rápida, além, é claro, de ser escrito em C, que reduz a sobrecarga de tempos de execução que é algo normalmente comum em linguagens de nível superior. Inicialmente essa ferramenta visava ajudar os desenvolvedores do kernel do Linux na tarefa de versionar, de forma eficiente, as mudanças no kernel que antes eram versionadas por meio do BitKeeper, um software proprietário desenvolvido pela BitMover Inc, Califórnia. Isso era um dilema entre os desenvolvedores do Linux, uma vez que ao contrário do BitKeeper, o Linux é conhecido por suas iniciativas Open Source. À época, o projeto Linux tinha acesso gratuito ao BitKeeper. Porém, com a acusação de programadores do kernel Linux estarem utilizando engenharia reversa, o acesso gratuito foi removido. Esse foi o fato que forçou Linus Torvalds a desenvolver o git. Além do git, atualmente existem algumas ferramentas para versionamento de códigos. Entre tais ferramentas, enumero duas que considero as mais conhecidas: mercurial: Trata-se de um sistema de versionamento, assim como o git, com iniciativas Open Source. Na internet é fácil encontrar diversos comparativos, em que muitos usuários citam como uma de suas vantagens a facilidade. O mercurial é o sistema de versionamento mais popular no Bitbucket, uma plataforma de hospedagem de código fonte que não é tão utilizada quanto o GitHub e o GitLab; subversion: Trata-se de um sistema de versionamento distribuido sobre os termos da Apache License e que foi desenvolvido pela Apache Software Foundation. Assim como o mercurial, o subversion não é tão popular quanto o git. Por se tratar do sistema de versionamento mais amplamente utilizado (mais popular) em versionamentos locais e remotos (a exemplo do GitHub e GitLab que são plataformas de hospedagem de código, em que é possível facilmente enviar códigos versionados usando git), trataremos apenas do uso do git. Nota: A ferramenta git poderá ser facilmente instalada em Linux/Unix, Windows e macOS. Clique aqui e faça o download da versão desejada e instale em seu sistema operacional. Há diversos vídeos na internet ensinando a configurar o git em sistemas Windows. Após a instalação do git em seu sistema operacional, abaixo listarei algumas funções interessantes para o uso do git via o prompt de comando (terminal). O terminal ao qual você deverá trabalhar com o git é algo parecido com as imagens abaixo: Figura 3.1: A imagem mais a esquerda refere-se ao terminal bash no linux e a mais a direita refere-se terminal bash instalado no Windows para o uso do git. Essas imagens são meramente ilustrativas e poderão variar um pouco a depender do sitema operacional. Observação: Para usuários de sistemas operacionais baseados em Arch Linux, por exemplo, usuários do Manjaro Linux, a instalação do git é bastante fácil. No terminal do Linux, basta fazer: sudo pacman -S git Caso você tenha optado em utilizar alguma distribuição GNU/Linux que não é derivada do Arch, muito provavelmente você não seguiu as considerações da distribuição Linux sugeridas na Seção Algumas distribuições, em que sugiro o uso do Manjaro Linux ou de distribuições GNU/Linux derivadas do Arch. Dessa forma, busque na distribuição GNU/Linux escolhida o comando para a instalação do git. Nota: Se você está utilizando alguma distribuição GNU/Linux baseada em Debian/Ubuntu, você poderá instalar o git fazendo sud apt-get install git. Outros a respetio da instalação do git poderão ser encontrados aqui. No Linux, o terminal bach, que é instalado por padrão, será o terminal que utilizaremos o git. Não há nenhuma necessidade de utilização de termais complementares. No terminal bach, para facilitar, você pode chamar simplesmente de “terminal do linux” é onde configuramos o sistema operacional, instalamos programas, removemos programas, programamos, compilamos, utilizamos o git, etc. É incrível a flexibilidade e a quantidade de coisas que podemos fazer no terminal do Linux. Usuários do sistema operacional Windows poderão instalar facilmente o git considerando o executável fornecido aqui. Se o seu sistema for 64 bits, vá ao final da página e faça o download do arquivo Git-x-64-bit.exe, em que x dá lugar a versão do git. Para esses usuários, durante o processo de instalação, no passo Adjusting your PATH environment, é importante selecionar a última opção, conforme a imagem abaixo: Após a instalação do git, em seu sistema operacional, abra o terminal e execute o comando git --version. Em caso de retorno da versão instalada do git, muito provavelmente a instalação ocorreu corretamente. Após instalar corretamente o git, a primeira coisa que você precisa fazer é configurar o seu nome de usuário e endereço de e-mail. Isso é de grande importância, uma vez que cada commit (compromentimento), a informação do usuário que fez alguma atualização do documento/projeto é utilizada. Ou seja, trata-se de uma espécie de “carimbar” o autor da modificação. Sendo assim, no terminal, faça: git config --global user.name &quot;seu nome ou sigla&quot; git config --global user.email seu_email Nota: A configuração acima só precisará ser realiazada uma única vez, uma vez que foi utilizado a opção --global no momento de definir o usuário e senha. Além disso, você sempre poderá realizar essas configurações, sem a necessidade de instalar novamente o git, caso deseje trocar o nome do usuário e e-mail utilizado. Após instalar e configurar corretamente o git em seu sistema operacional, considere os comandos enumerados adiante. Esses comandos devem ser realizados no diretório ao qual queremos versionar com o git. Dessa forma, você deverá, no terminal estar no diretório a ser versionado. Importante: Os comandos cd, cd .., ls, cp, mkdir, rm e mv são comandos úteis do terminal de linux e que normalmente precisamos deles quando estamos trabalhando com o git. Muito provavelmente, esses comandos serão reconhecidos no terminal do git quando instalado no Windows. Esses comandos foram apresentados em sala de aula. Comando úteis do git: git help &lt;verbo&gt;: Esse é o comando mais importante do git. Com ele você encontrará informações a respeito de um &lt;verbo&gt;, em que &lt;verbo&gt; deverá ser substituído por um comando git válido. Por exemplo, faça git help help para obter informações sobre o comando help de git. Outras variantes de git help &lt;verbo&gt; pode ser: git &lt;verbo&gt; --help man git-&lt;verbo&gt; git --version: Como mencionado anteriormente, esse comando retornará a versão do git que encontra-se instalada no seu sistema operacional. git config --list: Esse comando lista as configurações do git que você está utilizando, ou seja, retornará o nome do usuário e e-mail que você configurou ao final da insatalação do git. git config --global core.excludesfile .gitignore: O arquivo .gitignore trata-se de um arquivo oculto (inicia-se com um ponto) e normalmente é colocado no diretório ao qual estamos querendo versionar. Dentro desse arquivo colocamos os nomes dos arquivos do diretório que estamos versionando e que desejamos não considerar no versionamento. O conteúdo desse arquivo de nome .gitignore poderia ser algo como: codigo1.R codigo2.cpp .diretorioOculto .ArquivoOculto.Rmd meulivro.pdf figura.png Com o arquivo .gitignore acima estaríamos dizendo para o git ingnorar um código R de nome codigo1.R, um código em C++ de nome codigo2.cpp, o diretório oculto de nome .diretórioOculto, um arquivo oculto R Markdown de nome .ArquivoOculto.Rmd, um livro em formato PDF de nome meulivro.pdf e uma figura no formato png de nome figura.png. Nota: Normalmente não utilizamos o comando git config --global core.excludesfile .gitignore, uma vez que esse comando irá sempre ignorar do versionamento qualquer um desses arquivos/diretórios que encontram-se listado em .gitignore. Algo mais útil seria apenas criar o arquivo .gitignore com a lista de diretórios e arquivos ao qual queremos desconsiderar no versionamento do nosso projeto. git init: No terminal, no diretório ao qual se quer versionar, esse comanto irá inicializar o versionamento do repositório. Por exemplo, o código abaixo mostra que estamos versionando o repositório de nome DocVersionado: cd /home/usuario/DocVersionado git init git status: verifica o status das modificações dos arquivos e diretórios no interior de DocVersionado. Serão listados os arquivos que foram modificados, deletados e acrescentados no projeto. git add .: adiciona todas as modificações que foram realizadas no Working Directory na Staging Area. git commit -m \"comentário útil\": Ao utilizar o comando git add ., as modificações ainda não foram versionadas, ou seja, não foram adicionadas no Git Directory. Para que as modificações adocionadas na Staging Area sejam versionadas, será preciso utilizar o comando git commit -m \"comentário útil\", em que \"comentário útil\", como o próprio nome diz, é um comentário útil a respeito das modificações realizadas no projeto. Cada commit realizado é internamente identificado por uma chave. Será por meio dessa chave que conseguiremos retroagir ou progredir no histórico do versionamento do nosso projeto. git log: exibe os históricos com todas as modificações realizadas, comentários dos commits realizados, as chaves de cada commit, horário da realização da introdução das modificações e informações do usuário que realizou as alterações. Algo parecido com a imagem abaixo: git log --stat: trás informações detalhadas das modificações realizadas em todos os arquivos e diretórios versionados dentro de um projeto. Com esse comando é possível inclusive ver a quantidade de alterações (deleções e inserções). git log --pretty=oneline: retorna informações resumidas de todos os commits realizados. Na maioria das vezes é o comnando mais utilizado para obter as chaves a chave de um dado commit, uma vez que não desejamos poluir o terminal com informações que muitas vezes podem ser desnecessárias. Você poderá utiliar o comando clear ou as teclas de atalho Ctrl + L para limpar o terminal. A imagem abaixo mostra cada commit em uma linha (chave e comentário): git checkout chave: modifica o projeto para o estado do commit referente à chave fornecida. Se deserjarmos voltar ao último commit, devemos fazer git checkout master. As chaves poderão ser fornecidas utilizando as diferentes variações do comando git log paresentadas acima. (OUTROS DETALHES FORAM ABORDADOS EM AULA NO DIA 17/06/2019) 3.2 GitHub (CONTEÚDO ABORDADO EM SALA DE AULA NO DIA 17/06/2019) "],
["relatorio-markdown-em-r.html", "4 Relatório Markdown em R 4.1 Markdown 4.2 R Markdown", " 4 Relatório Markdown em R Uma das tarefas mais importantes e frequentes na vida de um estatístico refere-se à construção de documentos (relatórios, manuais, etc). A construção desses documentos é algo que demanda tempo, uma vez que, por exemplo, temos que escrever a respeito das metodologias estatísticas consideradas e justificar o seu uso, organizar as informações obtidas de um modelo estatístico e interpretá-las, tabular os resultados de algumas simulação, escolher o formato de saída do documento e escrever de forma clara e robusta os resultados obtidos (muitos que irão ler seu documento não são estatísticos). Um pouco dessa rotina encontra-se no diagrama a baixo: Figura 4.1: Fluxo de trabalho - organização dos dados, escolhas das metodologias, implementações e edição de documento. Como descrito no diagrama 4.1, o processo de construção de um relatório é um processo frequente, uma vez que você muito provavelmente, em alguma empresa, irá deparar-se com documentos em que deverão ser atualizados, dia após dia. Por exemplo, você poderá vir a trabalhar em uma empresa em que diariamente terá que enviar relatório(s) ao seu chefe ou para um grupo de pessoas. Por exemplo, em muitas situações, esse(s) documentos(s) poderão possuir um layout predefinido, onde serão apenas alterados os resultados/retornos obtidos por suas funções implementadas em R. Ou seja, estamos considerando o caso em que você diariamente tem o mesmo relatório com diferentes estatísticas (indicadores descritivos, resultados inferenciais, etc). Com o R e o Markdown, bem como utlizando outras ferramentas disponíveis para programadores de R, você poderá automatizar, ao máximo, o processo de construção documentos. Por tratar-se de uma comunidade grande e que envolve muitos estatísticos, a comunidade de R vem constantemente desenvolvendo ferramentas de interesse para quem trabalha com estatística e aprendizado estatístico. Muitas dessas ferramentas são disponibilizadas na forma de pacotes, no CRAN (The Comprehensive R Archive Network), bem como no GitHub. Isso mostra a grande flexivilidade de R e o quanto essa linguagem se adapta às necessidades de um estatístico ou à quem for de interesse a análise de dados. Você poderá programar em qualquer linguagem, porém, programar em R tornará sua vida de progamador/estatístico mais fácil, caso o seu seu interesse esteja em resolver problemas estatísticos e/ou que envolvam aprendizado estatístico, denominado por muitos de machine learning (aprendizado de máquina). Observação: Nada impedirá que você venha trabalhar com problemas não estatísticos em R. R é uma linguagem elegante, flexível e que permite se comunicar com diversas outras linguagens de programação. Como mostra o diagrama 4.1, a linguagem R está no meio de importantes etapas de um estudo. O estatístico poderá utilizar o R para organizar os dados, implementar as metodologias estatísticas adotadas no estudo e se quiser, poderá utilizar o R para construir o relatório. Note que no diagrama 4.1, descrevemos a linguagem R como uma ferramenta que está presente entre quase todos os passos na construção dos resultados de um estudo. Integrando o Markdown com a linguagem R, você fará com que o R esteja presente entre todos os processos do estudo, o que certamente trará grande flexibilidade (possibilidades) às suas análises. Assim, seu fluxo de trabalho passará de 4.1 para 4.2 otimizando assim, as suas análises. Figura 4.2: Linguagem R entre todos os fluxos de trabalho de um estudo estatístico. Destaque para o uso de R para a construção de um relatório. Nota: Esse material que você está lendo agora mostra um pouco do que você consegue fazer com o R + Markdown utilizando algumas ferramentas (pacotes) disponíveis para o R. As ferramentas que integram R com Markdown são bem integradas com a IDE de programação RStudio, o que facilita um pouco o trabalho de edição. 4.1 Markdown Markdown é uma linguagem de marcação desenvolvida em 2004 por John Gruber com a colaboração de Aaron Swartz. Markdown é uma linguagem muito leve e diponível sob os termos de uma licença de código aberto no estilo BSD. Nota: Algo curioso com relação a linguagem Markdown é que o seu lançamento inicial se deu em 19 de março de 2004 e o seu último lançamento (versão 1.0.1) foi em 17 de dezembro do mesmo ano. A versão 1.0.1 do Markdown possui apenas 18 KB. Figura 4.3: Logo da linguagem de marcação Markdown utilizada para conversão de texto em HTML. Importante: Arquivos em Markdown devem possuir a extensão .md. A linguagem Markdown faz com que a tarefa de construir páginas em HTML seja algo bem mais fácil e prazeroso. Sinceramente, você não estaria lendo esse material se eu tivesse que escrever todo esse conteúdo diretamente em HTML. Para entender um pouco do que estou falando, logo abaixo você encontrará dois exemplos do mesmo texto escrito utilizando as linguagens de marcação Markdown e HTML, respectivamente. Ambos nos levarão ao mesmo resultado de uma página em HTML. Note como é mais claro e limpo o código em Markdown em comparação ao código em HTML. Texto escrito utilizando Markdown: # Seção Escrevendo alguma coisa nessa minha seção. ## Subseção Escrevendo alguma coisa nessa minha subseção. Outra linha. Colocando texto em itálico _texto em itálico_ ou *texto em itálico*, em negrito **texto em negrito** e destacando um código `f &lt;- function() ...`. Criando uma linha horizontal: --- Listando itens: * R é Open Source * R é uma ótima linguagem de progrmação * Estatísticos em todo o mundo usam R * R é utilizado por grandes empresas para análise de dados e em aprendizagem de máquina. --- Enumerando itens: 1. R Agro 2. R é Tec 3. R é Pop 4. R é Tudo --- Um bom curso de estatística computacional utilizando R poderá ser encontrado em [**Estatística Computacional**](https://prdm0.github.io/aulas_computacional). ![Logo da linguagem de programação R.](https://www.r-project.org/logo/Rlogo.png &quot;icon&quot;) Lembre-se: &gt; Batatinha quando nasce, esparrama pelo chão. &gt; Se você não aprender em R irá sofrer de montão. &gt; --- Autor desconhecido, 2019. &lt;strong&gt;Se eu desejar, poderei utilizar código HTML&lt;/strong&gt;. Texto escrito utilizando HTML: &lt;h1&gt;Seção&lt;/h1&gt; &lt;p&gt;Escrevendo alguma coisa nessa minha seção.&lt;/p&gt; &lt;h2&gt;Subseção&lt;/h2&gt; &lt;p&gt;Escrevendo alguma coisa nessa minha subseção.&lt;/p&gt; &lt;p&gt;Outra linha.&lt;/p&gt; &lt;p&gt;Colocando texto em itálico &lt;em&gt;texto em itálico&lt;/em&gt; ou &lt;em&gt;texto em itálico&lt;/em&gt;, em negrito &lt;strong&gt;texto em negrito&lt;/strong&gt; e destacando um código &lt;code&gt;f &amp;lt;- function() ...&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Criando uma linha horizontal:&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;Listando itens:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;R é Open Source&lt;/li&gt; &lt;li&gt;R é uma ótima linguagem de progrmação&lt;/li&gt; &lt;li&gt;Estatísticos em todo o mundo usam R&lt;/li&gt; &lt;li&gt;R é utilizado por grandes empresas para análise de dados e em aprendizagem de máquina.&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;p&gt;Enumerando itens:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;R Agro&lt;/li&gt; &lt;li&gt;R é Tec&lt;/li&gt; &lt;li&gt;R é Pop&lt;/li&gt; &lt;li&gt;R é Tudo&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;p&gt;Um bom curso de estatística computacional utilizando R poderá ser encontrado em &lt;a href=&quot;https://prdm0.github.io/aulas_computacional&quot;&gt;&lt;strong&gt;Estatística Computacional&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;https://www.r-project.org/logo/Rlogo.png&quot; alt=&quot;Logo da linguagem de programação R.&quot; title=&quot;icon&quot; /&gt;&lt;/p&gt; &lt;p&gt;Lembre-se:&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Batatinha quando nasce, esparrama pelo chão. Se você não aprender em R irá sofrer de montão.&lt;/p&gt; &lt;p&gt;--- Autor desconhecido, 2019.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;strong&gt;Se eu desejar, poderei utilizar código HTML&lt;/strong&gt;.&lt;/p&gt; Nota: Os códigos apresentados acima, utilizando as linguagens de marcação Markdown e HTML, irão nos levar aos mesmos resultados. Para observar o resultado, clique aqui. É claro que o HTML produzido ainda é bem simples e “rústico”, lembrando um pouco das páginas do início da popularização da internet. Mas calma, utilizando as ferramentas corretas e que estão disponíveis em R, poderemos produzir texto como esse que você está lendo agora. A boa notícia é que você não precisará alterar em nada o código escrito em Markdown para obtenção de uma saída mais agradável. Você apenas precisará associá-lo à ferramenta correta dispiníveis em R. Antes de conversarmos a respeito das ferramentas disponíveis, em R, para a construção de saídas em HTML mais atraentes, precisaremos entender melhor a sintaxe do Markdown. A seção que segue é dedicada ao entendimento da sintaxe do Markdown. 4.1.1 Sintaxe Entender a sintaxe de Markdown é algo interessante por alguns motivos. Elencarei três deles abaixo: A sintaxe de Markdown é fácil e não requer uma grande curva de aprendizado; Seus documentos podem ser facilmente compartilhados dentro de uma empresa ou grupo de pessoas. Seu relatório em HTML poderá estar hospedado utilizando algum serviço e as pessoas poderão acessar o conteúdo clicando em um link. Por exemplo, não haverá a necessidade de compartilhar arquivos por e-mail ou em dispositivos de armazenamento. Você não precisará levar esse arquivo com você, caso tenha acesso à internet; Markdown poderá ser utilizado em vários lugares, e não apenas em conjunto com o R. Por exemplo, você poderá utilizar o Markdown no GitHub ou no Stack Overflow, site este de perguntas e respostas que é muito útil no aprendizado de programação. Por sinal, aconselho que você crie uma conta e venha utilizado o Stack Overflow para fazer peguntas de programação em R. Há uma comunidade grande de programadores de R no Stack Overflow. No Stack Overflow você não poderá fazer perguntas genéricas. Se você tiver com problemas em algum código, construa um exemplo do código resumido e explique detalhadamente o seu problema e o que deseja obter. Assim, você terá grandes chances de sua pergunta ser respondida de forma eficiente, cordial e sem correr o risco de ter a sua pergunta apagada por algum moderador. Nota: Por falar em Stack Overflow, a equipe do Stack Overflow utiliza o R e o RStudio em suas análises. Veja um depoimento aqui. Utilizar o Markdown com o R dentro do RStudio é algo interessante e fácil. Porém, para aprender a sintaxe, consideraremos essa ferramenta. Por ela, você poderá testar rapidamente o que o que irá aprender. 4.1.1.1 Parágrafo, cabeçalho e bloco de códigos Um parágrafo em Markdown é constrído por uma ou mais linhas de textos separadas por uma ou mais linhas em branco. Escrevendo três parágrafos em Markdown: Aqui estou criando meu primeiro parágrafo em Markdown. Espero que eu possa aprender o markdown e assim venha obter sucesso na minha carreira como estatístico. Darei um espaço abaixo: Aqui é o meu segundo parágrafo. Só passando para lembrar que R é uma ótima linguagem de programação. Abaixo colocarei 2 espaços: &quot;Qualquer um pode, com algum estudo, escrever códigos que o computador enteda. Bons programadores esvrevem códigos que os humanos entendam.&quot; - Alguém, 5 mil anos a.C. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. Acrescendando um cabeçalho: Você poderá utilizar uma sequencia do caracter = para iniciar uma seção. Analogamente, utilizando o caracter - você poderá criar uma subseção. Um texto com parágrafos soltos ============================== Aqui estou criando meu primeiro parágrafo em Markdown. Espero que eu possa aprender o markdown e assim venha obter sucesso na minha carreira como estatístico. Darei um espaço abaixo: Aqui é o meu segundo parágrafo. Só passando para lembrar que R é uma ótima linguagem de programação. Abaixo colocarei 2 espaços: Um programador que não organiza o seu código deveria morrer mais cedo --------------------------------------------------------------------- &quot;Qualquer um pode, com algum estudo, escrever códigos que o computador enteda. Bons programadores esvrevem códigos que os humanos entendam.&quot; - Alguém, 5 mil anos a.C. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. Importante: É importante dizer que esse comportamento poderá veriar de uma ferramenta que suporta a sintaxe de Markdown para outra. Com o uso frequente de alguma dessas ferramentas, você irá familiarizar-se com algumas possíveis divergências. 4.1.1.2 Seções/subseções aninhadas Podemos utilizar sequências do caracter # para criar seções aninhadas. O código acima poderia ser alterador por: # Um texto com parágrafos soltos Aqui estou criando meu primeiro parágrafo em Markdown. Espero que eu possa aprender o markdown e assim venha obter sucesso na minha carreira como estatístico. Darei um espaço abaixo: Aqui é o meu segundo parágrafo. Só passando para lembrar que R é uma ótima linguagem de programação. Abaixo colocarei 2 espaços: ## Um programador que não organiza o seu código deveria morrer mais cedo &quot;Qualquer um pode, com algum estudo, escrever códigos que o computador enteda. Bons programadores esvrevem códigos que os humanos entendam.&quot; - Alguém, 5 mil anos a.C. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. De uma forma geral, tem-se: # Seção ## Subseção ### Subsubseção #### Subsubsubseção ... — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. 4.1.1.3 Bloco de Frases É possível criar, por meio do caracter &gt; frases em bloco. Por exemplo, com a ferramenta que utilizo para a construção desse material, temos abaixo três frases utilizando três níveis de blocos. Primeiro nível de bloco. Segundo nível de bloco. Terceiro nível de bloco. &gt; Primeiro nível de bloco. &gt; &gt; Segundo nível de bloco. &gt; &gt; &gt; Terceiro nível de bloco. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. 4.1.1.4 Dando ênfase É possível que venhamos dar ênfase à um trecho de um texto. Isso é feito utilizando * (asterisco), _ (subilinhado/underscore), ** (duplo asterisco) ou __ (duplo subilinhado/underscore). Essas combinações de caracteres devem envolver o texto a ser destacado e fazem: * (asterisco): Deixa o texto envolvido em itálico. Isso é feito fazendo *texto em itálico* — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. _ (sublinhado/underscore): Faz o mesmo que *, isto é, deixa o texto envolvido em itálico. _texto em itálico_ — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. ** (duplo asterisco): Deixa o texto envolvido em negrito. **texto em negrito** — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. __(dublo subilinhado/underscore): Faz o mesmo que envolver o texto por **, isto é, deixa o texto envolvido em negrito. __texto em negrito__ — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. O código abaixo faz uso do que aprendemos até aqui: # Um texto com parágrafos soltos Aqui estou criando meu primeiro parágrafo em **Markdown**. Espero que eu possa aprender o markdown e assim venha obter sucesso na minha carreira como estatístico. Darei um espaço abaixo: _Aqui é o meu segundo parágrafo_. Só passando para lembrar que R é uma ótima linguagem de programação. __Abaixo colocarei 2 espaços__: ## Um programador que não organiza o seu código deveria morrer mais cedo *&quot;Qualquer um pode, com algum estudo, escrever códigos que o computador enteda. Bons programadores esvrevem códigos que os humanos entendam.&quot;* - **Alguém**, _5 mil anos a.C_. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. 4.1.1.5 Listando Itens Em seu texto, é possível que tenha o intenresse de listar itens de forma não ordenada. Isso é possível utilizando os caracteres *, + ou -. Considere o exemplo: * Meu primeiro item; * Meu segundo item; * Meu terceiro item. ou + Meu primeiro item; + Meu segundo item; + Meu terceiro item. ou ainda - Meu primeiro item; - Meu segundo item; - Meu teceiro item. Nota: Você poderá intercambiar os caracteres *, + e -. Ou seja, você poderá fazer: * Meu primeiro item; + Meu segundo item; - Meu terceiro item. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K.. 4.1.1.6 Enumerando Itens As vezes necessitamos de itens dispostos segundo uma ordem. Você poderá ordenar os itens utilizando um número seguido de um ponto. Considere o exemplo abaixo: 1. Meu primeiro item enumerado; 2. Meu segundo item enumerado; 3. Meu terceiro item enumerado. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. Nota: Os itens enumerados ou não enumerados podem ser formados por parágrafos. Você deverá colocar 4 (quatro) espaços para iniciar um parágrafo de um respectivo item. Considere o código abaixo: 1. Aqui é o meu primeiro item. Aqui é um novo parágrafo do meu primeiro item. 2. Aqui é o meu segundo item. Aqui é um novo parágrafo do meu segundo item. 3. Aqui é o meu terceiro item. Aqui é um novo parágrafo do meu terceiro item. Essa mesma regra vale para os itens não enumerados. Considere o código abaixo: * Aqui é o meu primeiro item. Aqui é um novo parágrafo do meu primeiro item. * Aqui é o meu segundo item. Aqui é um novo parágrafo do meu segundo item. * Aqui é o meu terceiro item. Aqui é um novo parágrafo do meu terceiro item. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. 4.1.1.7 Criando Links A linguagem de marcação Markdown te permite inserir links no meio do seu texto. Markdown suporta dois estilos de inserção de links. São eles: Link não resumido: As vezes temos o interesse de deixar claro, em nosso texto, qual o endereço completo de um e-mail ou site. Por exemplo, considere o texto do exemplo abaixo: Exemplo 1: Se você precisar, acesse o http://www.de.ufpb.br/ do Departamento de Estatística da UFPB. Também, em caso de necessidade, você poderá mandar um e-mail para mim. Meu e-mail é pedro.rafael.marinho@gmail.com. A forma geral para a construção de links não resumido é &lt;link&gt;. Para obtermos o retorno acima, devemos fazer: Se você precisar, acesse o &lt;http://www.de.ufpb.br/&gt; do Departamento de Estatística da UFPB. Também, em caso de necessidade, você poderá mandar um e-mail para mim. Meu e-mail é &lt;pedro.rafael.marinho@gmail.com&gt;. Link resumido: Trata-se do link que é substituido por um texto sugestivo ao seu conteúdo. Trata-se de uma forma de se construir um link sem a necessidade expor todo o caminho/endereço (froma resumida). Por exemplo, considere o texto do exemplo abaixo: Exemplo 2: Se você precisar, acesse o site do Departamento de Estatística da UFPB. Também, em caso de necessidade, você poerá mandar um e-mail para mim. A forma geral para construção de links resumido (sugestivos) é [testo do link](link). Por exemplo, o exemplo cima poderá ser obtido pelo código abaixo: Se você precisar, acesse o [**site**](http://www.de.ufpb.br/) do Departamento de Estatística da UFPB. Também, em caso de necessidade, você poerá mandar um [**e-mail**](mailto:pedro.rafael.marinho@gmail.com) para mim. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. Nota: Em se tratando de link resumido, para linkar corretamente um e-mail com o programa de envio e recebimento padrão instalado no computador, você deverá utilizar a expressão mailto: antes da definição do e-mail ao qual deseja linkar com o programa. Por exemplo: [e-mail](mailto:pedro.rafael.marinho@gmail.com) Se você desejar, você poderá ter uma lista enumerada de links ao final do arquivo e invoca-los, por sua numeração, no corpo do seu texto. Considere o texto do exemplo que segue: Exemplo: “Adoro programar utilizando a linguagem R. Para uma melhor experiência, considere programar utilizando a IDE RStudio. Programar em R com o RStudio torna a tarefa de programar ainda mais agradável. Mais agradável ainda é saber que a linguagem R possui um grande número de pacotes para trabalhar com estatística.” Um solução, com o que já aprendemos de Markdown, para esse exemplo acima, poderia ser: Solução 1: &quot;**Adoro programar** utilizando a linguagem [**R**](https://www.r-project.org). Para uma melhor experiência, considere programar utilizando a IDE [RStudio](https://www.rstudio.com/products/RStudio/). Programar em [R](https://www.r-project.org) com o [**RStudio**](https://www.rstudio.com/products/RStudio/) torna a tarefa de programar ainda mais agradável. Mais agradável ainda é saber que a linguagem [R](https://www.r-project.org) possui um grande número de [*pacotes*](https://cloud.r-project.org/web/packages/available_packages_by_date.html) para trabalhar com estatística.&quot; — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. Solução 2 &quot;**Adoro programar** utilizando a linguagem [**R**][1]. Para uma melhor experiência, considere programar utilizando a IDE [RStudio][2]. Programar em [R][1] com o [**RStudio**][2] torna a tarefa de programar ainda mais agradável. Mais agradável ainda é saber que a linguagem [R][1] possui um grande número de [*pacotes*][3] para trabalhar com estatística.&quot; [1]: https://www.r-project.org &quot;R&quot; [2]: https://www.rstudio.com/products/RStudio/ &quot;RStudio&quot; [3]: https://cloud.r-project.org/web/packages/available_packages_by_date.html &quot;packages&quot; — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. Nota: Note que o exemplo acima poderá ser útil em situações que que repetimos linkamos uma palavra ao longo de todo o texto. Nesses casos, a linkagem considerando a numeração dos links poderá ser menos cansativa. 4.1.1.8 Inserindo figuras no texto Se você trabalha com estatística muito provavelmente sente corriqueiramente a necessidade de introduzir, em um texto, gráfico(s) e imagen(s) que explica(m) um resultado obtido ou que nos auxilia(m) à etender um detarminado problema. A sintaxe de inserção de figuras é muito semelhante à sintaxe de inserção de links. Exemplo: Suponha que desejamos inserir o logo da linguagem de programação R, na forma abaixo: Figura: Logo da linguagem de programação R obtido em aqui. A Figura acima poderá ser inserida na forma que segue: &lt;center&gt; ![](https://www.r-project.org/logo/Rlogo.png){height=&quot;100px&quot; width=&quot;100px&quot;} &lt;/br&gt; Figura: Logo da linguagem de programação **R** obtido em [**aqui**](https://www.r-project.org/logo/Rlogo.png). &lt;/center&gt; Observação: Poderá ser que a depender de onde você esteja testando esse código, a expressão {height=\"100px\" width=\"100px\"} não venha funcionar. Além disso, não se preocupe com o alinhamento da imagem nem com outros pormenores. Com pouco esforço e utilizando as ferramentas necessárias de R, tudo se ajustará. O objetivo aqui é apenas expor o básico da sintaxe de Markdown. Você poderá achar estranho algumas sintaxes acima. Abaixo esclareço todas elas: &lt;center&gt; … &lt;/center&gt;: Essas expressões faz com que tudo o que está envolvido entre elas sejam centralizados na página em HTML que será gerada. Essas expressões também poderá ser útil para centralizar textos. Exemplo: Reproduza o exemplo que segue: &lt;center&gt; Envolver algum texto entre `&lt;center&gt;`e &lt;/center&gt; &lt;center&gt; fará com que tudo que esteja envolvido seja centralizado. &lt;/center&gt; &lt;/br&gt;: Trata-se de um expressão de HTML responsável por pular uma linha. Essa expressão poderá ser utilizada em qualquer lugar do seu código escrito em Markdown. {height=\"100px\" width=\"100px\"}: Essa expressão é utilizada para definirmos as dimensões da imagens, a ser inserida, nesse caso em pixels, altura e largura, respectivamente. Exercícios Construa um código em Markdown que retorne a saída abaixo: R é um ambiente de software livre para computação estatística e gráficos. Ele compila e é executado em uma ampla variedade de plataformas UNIX, Windows e MacOS. Para fazer o download do R, escolha o seu espelho CRAN (Comprehensive R Archive Network) preferido. Modifique o código em Markdown utilizado no exercício anterior para que forneça: R é um ambiente de software livre para computação estatística e gráficos. Ele compila e é executado em uma ampla variedade de plataformas UNIX, Windows e MacOS. Para fazer o download do R, escolha o seu espelho CRAN (Comprehensive R Archive Network) preferido. Construa o código em Markdown que forneça uma saída próxima a da imagem abaixo: Forneça o código Markdown para a obtenção do resultado que segue: Aqui é o item 1: Subitem 1 Subitem 2 Subitem 3 Aqui é o item 2: Subitem 1 Subitem 2 Subitem 3 Aqui é o item 3: Subitem 1 Subsubitem 1 Subsubitem 2 Subitem 2 Subsubitem 1 Subsutitem 2 Forneça o código Markdown que retore o resultado que segue: Aqui é o item 1: Eu serei um programador de R. Eu prometo de sempre serei fiel, na alegria e na tristeza, até que a morte nos separe… Além dos votos acima, abaixo segue dois motivos para você apresender a programar em R: Se você não programar, você não irá passar na disciplina. =( Acho que o motivo acima é suficiente. R é uma linguagem legal. R tem vários pacotes: Mais algumas coisas … : Bla bla bla bla bla bla bla bla … Bla Bla … Se tudo der errado, mande um email para jesus@aomeudeus.com com o título: “Estou Chegando”. Considere o a imagem desse link. Crie um arquivo Markdown de modo a ser inserido a imagem com dimensões 50 por 50 pixels centralizada no HTML resultante após a compilação. O resultado que você deverá obter é o que segue: Figura: Importando o logo do RStudio figura qualquer. 4.2 R Markdown Se você chegou à esse ponto da leitura, muito provavelmente deverá estar se perguntando sobre muitas coisas. Algumas dessas perguntas poderiam ser: Como referenciar um texto ou figura? E se eu quiser colocar figuras lado a lado? Como incorporar fórmulas matemáticas no corpo do texto? Como colocar referências no texto? É possível incorporar tabelas? As respostas à estas perguntas não foram respondidas por serem bastante inconveniente ou mesmo impossível de respondê-las utilizando a linguagem Markdown. A linguagem Markdown é bastante simples e útil para muitos casos. Aliás, na maior parte do tempo estamos utilizando a sintaxe de Markdown, sendo que algumas vezes é que nós nos deparamos com com algumas dessas necessidades. Visando atender à diversas exigências, entre elas as que estão enumeradas acima, houve a necessidade de se extender a sintaxe do Markdown em R. Essas necessidades corriqueiras são atendidas pelo pacote rmarkdown que disponibiliza ao usuário o R Markdown. O pacote rmarkdown foi criado por Yihui Xie, PhD em estatística e que atualmente trabalha como engenheiro de software na RStudio, Inc. Yihui Xie atualmente mantem diversos pacotes em R em seus repositórios no GitHub. Figura 4.4: Logo do pacote rmarkdown - permite programadores R extender a sintaxe de marcação Markdown utilizando R Markdown. Como dito anteriormente, para fazer uso de R Markdown será necessário o uso do pacote rmarkdown. Esse pacote, por sua vez, trabalha sobre duas importantes ferramentas. São elas: knitr: Um pacote também criado por Yihui Xie e que hoje possui diversos colaborados. O pacote knitr permite converter um texto escrito em R Markdown (arquivo com extensão .Rmd) para Markdown (arquivo com extensão .md). Em 2012, o pacote knitr já permitia com algumas linguagens de marcação, entre as mais importantes destacam-se a linguagem LaTeX e HTML. Apenas em 2015 é que foi introduzido o R Markdown (arquivos com extensão .Rmd), uma vez que o Markdown tinha se mostrado ser um formato de documento popular e bastante utilizado pela comunidade. Pandoc: Um “canivete suíço” escrito utilizando a linguagem de programação Haskell e que permite converter textos escritos em uma linguagem de marcação para outra. Muito embora você não precisa utilizar diretamente os comandos do Pandoc quando fizer uso do pacote rmarkdown, você poderá instalar facilmente o Pandoc em seus sistema operacional e utilizar o Pandoc para converter arquivos .tex (TeX) em .docx (DOCX, formato relacionado com a ferramenta Microsoft Word), .md (Markdown) em .pdf (PDF), .tex (LaTeX) para .md (Markdown), entre diversas outras conversões. Maiores detalhes a repseito das possíveis conversões você encontrará aqui. Nota: Com o R Markdown teremos a nossa disposição diversas ferramentas e ainda poderemos usufruir da simplicidade do Markdown. O funcionamento geral e interações entre o pacote rmarkdown com o pacote knitr e o Pandoc poderão ser resumidos com diagrama abaixo: Figura 4.5: Funcionamento do pacote rmarkdown que permite trabalharmos com arquivos .Rmd e sua interação com o knitr e Pandoc na converção para formatos intermediários. Como podemos observar no diagrama 4.5, o pacote knitr é responsável por converter o arquivo .Rmd que contém códigos em R Markdown para um arquivo .md que contém código em Markdown puro. Depois, o Pandoc irá agirar sobre o aquivo .md e irá converter para o formato desejado, em que por padrão, o formato é .html. A conversão para HTML é de longe a mais utilizada, uma vez que trata-se de um formato que facilita o compartilhamento do seu conteúdo, sendo possível, por exemplo, hospedar os HTMLs gerados em um servidor para o acesso de qualquer lugar, desde que se tenha um browser e uma conecção com uma rede de internet. O pacote knitr também incorpora algumas funcionalidades quando estamos trabalhando com R Markdown, em que a mais importante delas é a possibilidade de incorporar e avaliar pedaços (chuncks) de códigos R dentro do documento, isto é, dentro do arquivo .Rmd. Essa é uma grande funcionalidade que nos permitirá fazer duas coisas importantes: Utilizar funções de R para plotagem de gráficos; Incorporar retornos de funções no interior do relatório; Nota: Acima listei apenas duas funcionalidades de julgo como mais importantes do pacote knitr, além, é claro, de converter arquivos R Markdown para arquivos em Markdown puro. Uma outra funcionalidade do pacote knitr que vale a pena ser destacada aqui, é a possibilidade de utilizar uma de suas função para incorporá figuras previamente salvas (os formatos mais populares de imagens são suportados) e controrar seu tamanhol, título, alinhamento bem como outras características de interesse. Importante: Tudo que você aprendeu a respeito de Markdown continuará valendo para arquivos R Markdown (arquivos com extensão .Rmd). Antes de iniciarmos as próximas seções a respeito do R Markdown, certifique-se que você possue o rmarkdown e o knitr instalados. Muito provavelmente esses pacotes juntamente com o Pandoc já estarão instalados, caso você esteja utilizando o RStudio. Em todos os exemplos que seguem nas seções que seguem, no RStudio, acesse as opções File, New File e R Markdown, respectivamente, para criar um novo arquivo R Mardown (arquivo com extensão .Rmd). Você também poderá utilizar as teclas de atalho Ctrl + Shift + N para criar um arquivo com extensão .R e no momento de salvar mude a extensão do arquivo para .Rmd. Nota: Você poderá compilar o código de R Markdown de três formas: Utilizando, no RStudio, a combinação das teclas de atalho Ctrl + Shift + K; Clicando no ícone do pacote knitr; Utilizando a função rmarkdown::render(input = \"arquivo.Rmd\"). Será criado no diretório de trabalho o arquivo arquivo.html. "],
["r-miscelanea-e-topicos-avancados.html", "5 R - miscelânea e tópicos avançados 5.1 Operador %&gt;% - Pipe 5.2 Funções", " 5 R - miscelânea e tópicos avançados Nesse ponto será assumido que você realizou os passos de revisão da linguagem R sugeridos, bem como resolveu os exercícios propostos. Considerá-los é de grande importância para que você consiga assimilar os conceitos apresentados nesse Capítulo. Esse Capítulo visa apresentar algumas miscelâneas a respeito da linguagem de programação R, bem como, alguns tópicos mais avançados de programação em R. O termo “avançado” utilizado aqui não necessariamente tem correlação com dificuldade de entendimento. Aqui utilizo esse termo para abordar assuntos que normalmente eram pouco discutidos em livros mais antigos da linguagem R e que atualmente vem ganhando destaques em livros e discussões mais recentes na internet. Na verdade, a maioria dos conceitos que serão abordados são de fácil compreensão, porẽm ajudarão os programadores em R a construir códigos mais robustos e mais flexíveis. Alguns desses assuntos que serão abordados e divididos em subseções são: Pipe %&gt;% Funções: Funcionais Closures dot-dot-dot, ..1, ..2 e etc Orientação à objeto por função genérica (sistema S3) Regex Tópicos em metaprogramação Paralelismo Empacotando funções 5.1 Operador %&gt;% - Pipe Para que possamos entender a utilidade dos operadores pipe, em especial do operador %&gt;%, vamos fazer um pão de queijo. Adiante, você encontrará a receita com 7 passos enumerados que deverão serem seguidos para que possamos fazer o nosso pão de queijo. Nota: Esse material não garante que você terá sucesso, caso seja curioso e tente fazer a receita. Foque apenas no código. E se você for de Minas Gerais e saiba fazer pão de queijo, desconsidere qualquer inconsistência na receita. =) Ingredientes: 2 copos americanos de leite, 1 copo americano de água, 1/3 de um copo americano de óleo, 1 colher de sopa de sal, 500g de povilho doce, queijo ralado a gosto, 3 ovos. Passos do Preparo: Ferva o leite com a água e o óleo; Em uma vasilha misture o polvilho e o sal; Jogue o liquido fervido e misture com uma colher grande; Espere esfriar (30 minutos) e despeje o queijo ralado e os ovos; Misture a massa com a mão amassando até ficar homogênea; Faça bolinhas do tamanho que preferir; Sirva quentinho; Assuma, por absurdo, que poderemos fazer nossos pães de queijo no R que que os verbos destacados nos passos acima são funções que implementamos em R. Dessa forma, forma, pelo que sabemos de R, poderemos fazer nossos pães de queijo de forma que segue: sirva(fazer(misture(despeje(esperar(misture(ingredientes = c(povilho, sal), add = ferver(c(leite, óleo), add_agua = TRUE), colher_grande = TRUE), tempo = 30), homogenea = TRUE), modo = &quot;amassando&quot;), formato = &quot;bolinha&quot;), modo = &quot;quentinho&quot;) Perceba que o código acima poderá ser um pouco confuso, uma vez que envolve muitas composições de funções. Porém, nada impede que você esteja salvando os resultados intermediários em objetos, de modo a facilitar a leitura do código ao relacionar esses objetos intermediários. Fazer isso funciona bem e eu particularmente utilizo muito. Porém, você também poderá fazer uso de pipes (operador %&gt;%) que poderá, nessas situações, deixar a leitura do código mais fácil, lógica e consequentimente mais compreensível., como veremos adiante. O operador de tubo %&gt;% foi implementando no pacote magrittr por Stefan Milton Bache e atualmente recebe a colaboração de diversas pessoas, incluindo programadores da RStudio, Inc. Atualmente, o pacote não recebe muitas atualizações, muito provavelmente por já está estável e cumprindo bem o seu papel. O nome magrittr muito provavelmente faz alusão à René Magritte, um dos principais pintores surrealista belga, em que a letra r, ao final, obviamente faz referências à linguagem R. É possível inferir isso com base no logo do pacote, apresentado logo abaixo: Figura 5.1: Logo do pacote magrittr com frase Ceci n’est pas une pipe (ouça a pronuncia, mesmo frase que acompanha pintura La trahison des images de René Magritte. Voltemos à algo mais interessante, ao preparo de pães de queijo. O preparo, “em R”, poderia ser quase tão saboroso quanto comer os pães de queijo, se fossem “preparados” utilizando o operador %&gt;%, na forma que segue: # Fazendo pão de queijo utilizando o operador pipe, isto é, # utilizando o operador %&gt;%. ferver(ingradientes = c(leite, água, óleo)) %&gt;% misturar(colher_grande = TRUE) %&gt;% esperar(tempo = 30) %&gt;% despejar(ingredientes = c(&quot;queijo&quot;, &quot;ovos&quot;)) %&gt;% amassar(forma = &quot;mãos&quot;) %&gt;% fazer_bolinhas(volume = 1) %&gt;% sirvir(froma = &quot;quentinho&quot;) É possível observar que o código acima é consideravelmente mais legível que o código apresentado mais acima desta subseção. O código acima é mais legível, por que os verbos/funções são encadeadas na sequência lógica do preparo e não lidos de dentro para fora, como no primeiro exemplo. Olhando rapidamente para cada um dos códigos, percebemos que o código que faz uso do operador %&gt;% fornece mais informações a respeito do que se está à fazer. Importante: Apesar de ser um operador útil, não exagere no uso de %&gt;%, principalmente quando se tem um conjunto de passos demasiadamente grande. Nessas situações, procure atribuir parte do código à objetos intermediários e depois componha esses objetos. Além disso, as funções envolvidas possuem diversas entradas e saídas, pode ser que o uso do operador %&gt;% não seja interessante. No RStudio, você poderá utilizar o atalho Ctrl + Shift + M como atalho para escrever mais rapidamente o operador %&gt;%. Nota: Como curiosidade, o recurso de pipes estão disponíveis em outras linguagens de programação, como F#, e os pielines de sistemas *nix que usa pipes para a comunicação entre os processos utilizando passagem de mensagens. Você poderá instalar o magrittr diretamente pelo CRAN ou por meio do repositório GitHub do pacote, ou seja, por meio de um dos comandos abaixo: # Instalando o pacote magrittr disponível # nos repositórios do CRAN. library(magrittr) # ou # Para instalar pacotes diretamente do GitHub, # você de deve ter instalado o pacote # devtools para poder fazer uso da função # install_github(). # Instalando o repositório magrittr do usuário/organização de # nome tidyverse do GitHub. devtools::install_github(&quot;tidyverse/magrittr&quot;, ref = &quot;master&quot;) Nota: Há pontos positivos e negativos ao considerar a instalação de um pacote diretamente do epositório do pacote no GitHub ou em qualquer outro sistema de hospedagem de código. Mencionarei apenas GitHub, mas o comentário se extende à outros sistemas de hospedagem de códigos, como, por exemplo, o GitLab. Basicamente, o ponto positivo refere-se à possibilidade de estarmos instalando uma versão mais recente do pacote, porém, em alguns casos, o pacote poderá apresentar alguns bugs, muito embora os códigos no branch master são normalmente estáveis e possuem códigos iguais aos que temos no CRAN. Instalar diretamente um pacote que está sendo mantido no GitHub dará a possibilidade de instalar versões mais recentes do pacote que ainda não encontram-se no CRAN. Pelo GitHub, você também terá a vantagem de instalar versões mais antigas do pacote. Por exemplo, no repositório do magrittr, no GitHub, você verá que, em Branch, haverá diversas versões versionadas do pacote, em que uma delas chama-se dev. Fazer devtools::install_github(\"tidyverse/magrittr\", ref = \"dev\") fará com que você instale a versão de desenvolvimento do pacote. Dessa forma, aconselho que sempre considere a instalação da versão no branch master de qualquer pacote que venha instalar diretamente do GitHub. Assim, haverá menos possibilidade de você deparar-se com códigos que ainda não funcionam ou que possuam algum(s) bug(s). Para um entendimento geral do operador %&gt;%, considere a existência dos objetos x, ye f. Então, x %&gt;% f(y) irá atribuir o objeto x à f, como primeiro argumento da função f, ou seja, será equivalente à fazer f(x, y). Porém, nem sempre desejamos introduzir o que está a esquerda do operador %&gt;% como primeiro agumento daquilo que está à sua direita. Para isso, poderemos fazer uso do caracter . (ponto). Esse caracter irá designar em qual posição será introduzido o objeto à esquerda de %&gt;% na função à sua direita. Por exemplo, a expressão x %&gt;% f(a, b = .) fará com que x à esqueda de %&gt;% seja substituído no lugar do caracter ., ou seja, x é passado como argumento à b, segundo argumento de f. Exemplo: Uso do caracter . em um contexto de bloco de instrução. Esse exemplo mostra que o que está a direita do operador %&gt;% não necessariamente precisa ser uma função. Nesses casos, o caracter . é de grande importância para que o operador saiba substituir corretamente o objeto x no bloco de instruções. library(magrittr) x &lt;- mtcars x %&gt;% { if (is.data.frame(.) || is.matrix(.)){ cat(&quot;A dimensão dos dados é&quot;, dim(.)) } else { cat(&quot;Objeto não é uma matriz ou um data frame&quot;) } } ## A dimensão dos dados é 32 11 Nota: Observe que, por exemplo, fazer x %&gt;% f(., y = 1) equivale a fazer x %&gt;% f(y = 1), uma vez que por padrão, o objeto que está à esquerda de %&gt;%sempre será substituído como primeiro argumento da função que está mais a sua direta, caso não seja utilizado o caractere . para indicar o lugar do substituição. Um outro operador útil disponível no pacote magrittr é o operator tee, denotado por %T&gt;%. Esse operador funciona de forma muito parecida com o operador %&gt;%, exceto pelo fato de que ele irá retornar o conteúdo do lado esquedo e não o resultado da operação do seu lado diretio. O uso do operador %T&gt;% não é tão comum. Normalmente a frequência de uso do operador %&gt;% é muito maior. Porém, veja que não é possível resolver o exemplo que segue utilizando apenas o operador %&gt;%. Exemplo: Pelo que entendemos do operador %&gt;%, não faz nenhum sentido o código abaixo: # Fixando uma semente. set.seed(0) rnorm(1000L) %&gt;% hist(., main = &quot;Histograma Qualquer&quot;, xlab = &quot;x&quot;, ylab = &quot;Frequência&quot;) %&gt;% mean ## Warning in mean.default(.): argumento não é numérico nem lógico: retornando ## NA ## [1] NA Nesse exemplo, observamos que o histograma foi construído, porém, não faz nenhum sentido passar um gráfico à função mean. Muito provavelmente o desejo de quem viria escrever um código como esse seria tirar a média do vetor resultante do código rnorm(1000L). Nessas situações, poderemos fazer uso do operador %T&gt;% (operador tee). Exemplo: Aqui temos um típico uso do operador %T&gt;%. Perceba que utilizando o perador %T&gt;%, foi possível passar rnorm(1000L) como argumento à função hist, assim como seria possível utilizando o operador %&gt;%. Porém, com o operador %T&gt;%, conseguimos passar rnorm(1000L) à função mean e não à função hist, que seria esperado se utilizássemos o operador %&gt;%. # Fixando uma semente. set.seed(0) rnorm(1000L) %T&gt;% hist(., main = &quot;Histograma Qualquer&quot;, xlab = &quot;x&quot;, ylab = &quot;Frequência&quot;) %&gt;% mean ## [1] -0.01582957 Um outro operador pipe que é bastante útil é o perador de exposição, denotado por %$%. Trata-se de um operador que é bastante útil quando estamos trabalhando com (quadro de dados) data frames ou matrizes, onde temos variáveis dispostas em suas colunas. Com esse operador, poderemos tornar visíveis as variáveis do objeto à sua esquerda nas funções à sua direita. Considere o exemplo que segue: Exemplo: No código que segue, estamos tornando visíveis as variáveis do objeto mtcars na função cor. Dessa forma, poderemos calcular a correlação entre as variáveis cyl e hp do data frame mtcars. mtcars %$% cor(cyl, hp) ## [1] 0.8324475 Nota: Normalmente esse operador é útil quando a função a direita não possui argumento de dados. Por exemplo, se o objetivo fosse calcular uma regressão linear simples com essas variáveis, poderíamos fazer: mtcars %&gt;% lm(cyl ~ hp, data = .) ## ## Call: ## lm(formula = cyl ~ hp, data = .) ## ## Coefficients: ## (Intercept) hp ## 3.00680 0.02168 uma vez que a função lm já possui um argumento para o conjunto de dados a ser utilizado. Ao passar o conjunto de dados para a função lm, todas as variáveis de mtcars estarão visíveis no interior da função lm. Por fim e não menos importante, existe o operador de pipe compostos, denotado por %&lt;&gt;%. Esse operador é útil quando queremos realizar uma operação e atribuir essa modificação ao objeto à esquerda do operador. Considere um exemplo de uso do operador de pipe composto: Exemplo: Utilizando o operador %&lt;&gt;% para alterar o conteúdo da variável disp do data frame mtcars. Perceba que ao chamar mtcars, a variável disp agora é do tipo inteiro. mtcars$disp %&lt;&gt;% as.integer() str(mtcars) ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: int 160 160 108 258 360 225 360 146 140 167 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... Observação: Alguns pacotes de R possuem vinhetas que facilitam o entendimento das funções empacotadas. Não necessariamente as vinhetas irão dissertar sobre todas as funções implementadas. Porém, essas vinhetas normalmente focam no que há de mais importante no pacote. Você poderá encontrar a vinheta do pacote magrittr aqui. Normalmente essas vinhetas são mais fáceis de serem lidas do que as documentações dos pacotes. Porém, consultar a documentação é o caminho correto para encontrar as respostas mais difícies e que muitas vezes não são abordadas nas vinhetas. Exercícios Resolva os exercícios que seguem. Os operadores pipes que você utilizará para resolver os exercícios não necessariamente irão produzir as melhores soluções. Porém, esses exercícios farão você pensar a respeito do emprego dos operadores e, aqui, é isso o que importará. Resolva os itens abaixo utilizando o operador %&gt;% do pacote magrittr: as.character(log(cos(sin(pi)))) round(var(seq(from = 1, to = 10, by = 0.5)), digits = 1) summary(anova(lm(mpg ~ wt, data = mtcars))) summary(lm(dist ~ log(accel), data = na.omit(attenu))) Sem salvar objetos intermediários, utilize operadore(s) pipe(s) para reescrever o código abaixo: dados &lt;- subset(iris, Sepal.Length &gt; mean(Sepal.Length)) cor(dados$Sepal.Length, dados$Sepal.Width) Sem salvar objetos intermediários, utilize operadore(s) pipe(s) para reescrever o código abaixo: vetor &lt;- 1:10 plot(matrix(data = vetor, ncol = 5, nrow = 5)) quantil &lt;- quantile(vetor) print(quantil) Sem fazer uso dos operadores de atribuições &lt;- ou =, reescreva o código abaixo usando operadore(s) pipe(s): mtcars &lt;- transform(mtcars, cyl = cyl * 2) Considere o código abaixo que faz uso do operador %&gt;%. Dica: busque nas documentações do pacote magrittr, o uso das funções subtract e divide_by. O que esse código faz? Reescreva-o sem fazer uso do operador %&gt;%. vetor &lt;- c(1.7, 2.74, 5.66, 8.13, 4.04) vetor %&lt;&gt;% subtract(., mean(.)) vetor %&gt;% divide_by(., sd(.)) Considere o código abaixo e reescreva-o utilizando o operador %&gt;% sem utilizar de passos intermediários. Dica: Procure identificar o uso da função extract do pacote magrittr. # Essa função não deverá entrar no pipe. set.seed(0) x &lt;- runif(n = 100, min = 0, max = 100) x &lt;- x[x &gt; 10 &amp; x &lt; 30] round(mean(x), digits = 1) Reescreva o código abaixo utilizando o operador pipe %&gt;%. dados &lt;- subset(iris, Sepal.Length &gt; 5) aggregate(Sepal.Length ~ Species, dados, FUN = mean) Tente reescrever o código apenas utilizando o operador %&gt;%e depois modifique-o para utilizar o operador de exposição %$%. Dica: procure entender o emprego das funções subset e aggregate, funções dos pacotes base e stats, respectivamente. Estude a vinheta do pacote magrittr. Acesse a vinheta aqui. Explique o que o código abaixo faz: f &lt;- . %&gt;% subtract(., mean(.)) %&gt;% divide_by(., sd(.)) Use o que aprendeu ao resolver o exercício anterior para reescrever o código abaixo usando pipes: vetor &lt;- c(1.7, 2.74, 5.66, 8.13, 4.04) sum(x - mean(x))/sd(x) 5.2 Funções Como já sabemos, uma vez que você deve ter utilizado bastante o confeito de funções ao resolver os exercícios sugeridos, funções são objetos que recebe uma ou algumas entradas, as processas em seu interior e te retorna uma ou mais saída(s). O diagrama 5.2 mostra um comportamento genérico de uma função qualquer (function) que recebe uma quantidade arbitrária de argumentos, com estruturas de dados distintas, e retorna também uma quantidade arbitrária de informações, objetos com estruturas de dados distintas: Figura 5.2: Comportamento genérico da função de nome function que recebe diversos argumentos com estruturas de dados distintas e retorna diversos diversos objetos com estuturas de dados distintas. Note que new structure, no diagrama, deixa claro que o programador poderá criar suas novas estruturas de dados que poderão ser passadas e/ou retornadas por uma função. Importante: Algo que torma uma função bastante flexível é a capacidade de podermos passar funções como argumentos à outras funções. Muito embora esse fato não esteja destacado no diagrama acima, nunca se esqueça que, em R, você facilmente poderá passar uma função como argumento de uma outra função. Exemplo: round(sum(c(1.73, 2.47, 7.21, 8.74, NA), na.rm = TRUE), digits = 1) Uma função em R é dividida em três partes: Lista de Argumentos: Conjunto de argumentos, podendo ter as mais variadas estruras de dados que pode inclusive alterar o comportamento da função. Corpo: Código no interior da função que será capas de processar e tomar decisões de acordo com sua lista de argumentos. Ambiente: Os ambientes (environment) de reconhecimentos de objetos no interior da função. Isso permite que possamos ter objetos com o mesmo nome referindo-se à conteúdos distintos na memória do computador. Como já sabemos, mas irei repetir, a forma geral de implementação de uma função é: f &lt;- function(argumentos){ # Aqui é onde as coisas acontecem. corpo } # Fim da função. Poderemos identificar essas três partes de uma função utilizando as funções formals(), body() e environment(). Por exemplo, considere a função abaixo: f &lt;- function(x, y){ `+`(x,y) } # Lista de argumentos. formals(f) ## $x ## ## ## $y # Corpo da função. body(f) ## { ## x + y ## } # Ambiente que a função foi definida. environment(f) ## &lt;environment: R_GlobalEnv&gt; Além disso, lembre-se que funções podem ter argumentos com valores já pré-definidos, como é o caso de f() no código que segue: f &lt;- function(x = 1, y = 2){ x + y } f(5) ## [1] 7 f(2,4) ## [1] 6 5.2.1 Passando atributos Uma função em R é um objeto qualquer. Dessa forma, assim como qualquer objeto, uma função poderá carregar consigo uma quantidade qualquer de atributos que podem ser recuperados e utilizados a qualquer momento. Considere os códigos que seguem: # Vetor com valores inteiros em memória de 1 à 10. x &lt;- 1L:10L # Introduzindo dois argumentos ao objeto x. # Primeiro argumento: desc, que apresenta uma pequena descrição do objeto x. # Segundo argumento: M, uma matriz qualquer que poderia vir a ser útil guardar. attr(x = x, which = &quot;desc&quot;) &lt;- &quot;vetor com valores inteiros&quot; attr(x = x, which = &quot;M&quot;) &lt;- matrix(data = c(1, 7, 3, 8), ncol = 2, nrow = 2) Note que agora o objeto x carrega não apenas os valores inteiros de 1 a 10. Foram acrescentados dois argumentos à x, são eles, desc que contém uma string descrevendo o que é o objeto x. Perceba que os atributos não afetam as operações que realizamos com x, mas poderemos, se desejarmos, acessar os atributos e trabalharmos com eles, como postra o trecho de código abaixo: # Os atributos não irão afetar as operações realizadas # considerando o objeto x. sum(x + 1) ## [1] 65 # Listando os atributos do objeto x: attributes(x) ## $desc ## [1] &quot;vetor com valores inteiros&quot; ## ## $M ## [,1] [,2] ## [1,] 1 3 ## [2,] 7 8 # Acessando o atributo de nome M (uma matriz) # e invertendo. solve(attr(x, &quot;M&quot;)) ## [,1] [,2] ## [1,] -0.6153846 0.23076923 ## [2,] 0.5384615 -0.07692308 Como é possível introduzir atributos à qualquer objeto em R, e funções são objetos, então considerre o trecho de código que segue, em que é introduzido o atributo M do objeto x como atributo da função f() abaixo: # Retorna os caracteres &quot;-&quot;, &quot;0&quot;, &quot;+&quot; # a depender do valor informado. f &lt;- function(x){ # x é um objeto numérico. if (x == 0) &quot;0&quot; else ifelse(x &gt; 0, &quot;+&quot;, &quot;-&quot;) } # Introduzindo o atributo de nome desc que contém uma breve descrição da # função f(): attr(f, &quot;desc&quot;) &lt;- &quot;retorna -, 0 ou +, a depender do valor passado à x&quot; # Acessando o conteúdo do atributo desc: attr(f, &quot;desc&quot;) ## [1] &quot;retorna -, 0 ou +, a depender do valor passado à x&quot; Sabemos que o uso da função body() permete-nos acessar o corpo de uma função (código da função). Porém, você apenas irá visualizar as partes do código que foram implementadas estritamente em R. Por exemplo, no trecho de código abaixo é apresentado o sudo da função body() sobre uma função implementada em R e outra função que tem o seu código implementado em uma linguagem de mais baixo nível: # Acessando o corpo da fução rm(): body(ls) # Tentando acessar o corpo da função sum(): body(sum) Note que foi possível acessar parte do conteúdo, implementado em R, da função rm(). Porém, no caso da função sum() o retorno foi NULL, uma vez que essa função é por completo implementada em uma linguagem de mais baixo nível. Isso se deve ao fato de que essas funções foram escritas em linguagens compiladas como o caso de C/C++, camhando assim um código objeto e não um código fonte. Em muitas situações desejamos passar uma função como argumento à outra função. O trecho de código abaixo cria duas simples funções, f() e g(), em que passamos f() como argumento à função g(): # As funções não necessariamente necessitam ter argumentos. f &lt;- function(){ &quot;Olá&quot; } g &lt;- function(func){ paste(func, &quot;mundo&quot;, sep = &quot; &quot;) } # Passando a função f() como argumento da função g(): g(func = f()) ## [1] &quot;Olá mundo&quot; # Compondo as funçoes nchar(), g() e f(). # A função nchar() retorna a quantidade de caracteres # na estring retornada por g(). nchar(g(func = f())) ## [1] 9 5.2.2 Funções anônimas Algo que é bastante útil quando estamos trabalhando com funções é a possibilidade de não nomear uma função. Essa estratégia é interessante quando temos funções curtas que não queremos nos dar o trabalho de pensarmos em um nome. Normalmente, aplica-se à casos de funções curtas que são passadas como argumento à outras funções. O trecho de código que segue apresenta o uso de uma função anônima passada como argumento à função integrate() de R: # Passando a função anônima function(x) x ^ 2 como argumento da # função integrate(). integrate(function(x) x ^ 2, lower = 0, upper = 2)$value ## [1] 2.666667 Não esqueça que, em muitos casos, compor funções utilizando o operador %&gt;% pode ser interessante. As composições acimas poderiam ser realizadas da forma que segue: # Primeira composição utilizando o operador %&gt;%: f %&gt;% g %&gt;% nchar # Segunda composição utulizando os operadores pipes %&gt;% e %$%: (function(x) x^2) %&gt;% integrate(lower = 0, upper = 2) %$% value Nota: Utilizar os operadores pipes pode ser interessante quando estamos a fazer uma análise de dados, em que queremos deixar claro uma sequência lógica de operações. Porém, note que pipes não irão tornar o seu código mais eficientes do ponto de vista computacional, nem o contrário, ou seja, utilizar pipes não irão tornar os seus códigos menos eficientes. 5.2.3 Escopo léxico Em computação, o escopo é o que delimita a relação de objetos e expressões, ou seja, em que partes do código um ou mais objetos são reconhecidos por uma dada expressão ou conjunto de expressões. Na maioria das linguagens de programção o escopo é léxico, também chamado de escopo estático, uma vez que podem ser delimitados estaticamente, antes da execução do programa por meio da sintaxe da linguagem, ou seja, por meio da estrutura léxica da linguagem. A linguagem R tem escopo léxico, assim como diversas outras linguagens de programação. Trata-se de tipo de escopo comum em linguagens como Pascal, C, C++, Ada, Go, Haskell, R, Julia, Python, Ruby, entre diversas outras. Considere o exemplo apresentado no código abaixo: x &lt;- &quot;fora&quot; f &lt;- function(){ x &lt;- &quot;dentro&quot; x }; f() ## [1] &quot;dentro&quot; Para quem já programa um pouco em R, o retorno da função f() era esperado, uma vez que olhando para o código, entendemos facilmente qual a saída, uma vez que a sintaxe nos acusa (escopo léxico). Na verdade, o termo vem de lexing, que refere-se ao processo de conversão de partes significativas do código intendíveis para o interpretador. Existem linguagens que fazem uso de escopo dinâmico, como é o caso do Emacs Lisp, shell Bash, LaTeX (linguagem de marcação), entre outras. Como esse não é o caso da linguagem R que frequentemente nos deparamos em R, aqui não é o lugar para dissertar em relação à esse assunto. No código acima, perceba que havia um objeto x definido no interior da função. Dessa forma, o retorno da função buscará por referências à x no mesmo escopo da função, isto é, irá considerar x definido por x &lt;- \"dentro\". Porém, considere a simples modificação do código na forma que segue: x &lt;- &quot;fora&quot; f &lt;- function(){ x }; f() ## [1] &quot;fora&quot; No código acima, a função f() não pode encontrar referências ao objeto x no interior da função. Dessa forma, R considerar-a o objeto x no respectivo escopo mais externo, que nesse caso é o objeto x definido por x &lt;- \"fora\". Esse comportamento é válido se consideramos estruturas mais aninhadas, como a que é apresentada no código que segue: x &lt;- &quot;estou fora de f&quot; f &lt;- function(){ # Podemos definir funções dentro de funções. g &lt;- function(){ x } # fim da função interna list(g = g(), x = x) } # fim da função externa f() ## $g ## [1] &quot;estou fora de f&quot; ## ## $x ## [1] &quot;estou fora de f&quot; Perceba que tanto o retorno da função g() quando o objeto x da função f() referem-se ao valor de x definido fora do escopo da função f(). Isso se deve ao fato da linguagem R procurar um objeto de nome x de froma sucessivas, partindo do escopo ao qual o objeto é invocado à escopos em níveis mais externos. No código acima, tanto g() definida dentro de f() quanto a prórpia função f() apenas encontrará referência à x no ambiente mais externo, isto é, será considerado o objeto x definido por x &lt;- \"estou fora de f\". "]
]
