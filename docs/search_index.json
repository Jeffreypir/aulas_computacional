[
["r-miscelanea-e-topicos-avancados.html", "5 R - miscelânea e tópicos avançados 5.1 Operador %&gt;% - Pipe 5.2 Funções 5.3 Funcionais 5.4 Sistema S3", " 5 R - miscelânea e tópicos avançados Nesse ponto será assumido que você realizou os passos de revisão da linguagem R sugeridos, bem como resolveu os exercícios propostos. Considerá-los é de grande importância para que você consiga assimilar os conceitos apresentados nesse Capítulo. Esse Capítulo visa apresentar algumas miscelâneas a respeito da linguagem de programação R, bem como, alguns tópicos mais avançados de programação em R. O termo “avançado” utilizado aqui não necessariamente tem correlação com dificuldade de entendimento. Aqui utilizo esse termo para abordar assuntos que normalmente eram pouco discutidos em livros mais antigos da linguagem R e que atualmente vem ganhando destaques em livros e discussões mais recentes na internet. Na verdade, a maioria dos conceitos que serão abordados são de fácil compreensão, porẽm ajudarão os programadores em R a construir códigos mais robustos e mais flexíveis. Alguns desses assuntos que serão abordados e divididos em subseções são: Pipe %&gt;% Funções: Funcionais Closures dot-dot-dot, ..1, ..2 e etc Orientação à objeto por função genérica (sistema S3) Regex Tópicos em metaprogramação Paralelismo Empacotando funções 5.1 Operador %&gt;% - Pipe Para que possamos entender a utilidade dos operadores pipe, em especial do operador %&gt;%, vamos fazer um pão de queijo. Adiante, você encontrará a receita com 7 passos enumerados que deverão serem seguidos para que possamos fazer o nosso pão de queijo. Nota: Esse material não garante que você terá sucesso, caso seja curioso e tente fazer a receita. Foque apenas no código. E se você for de Minas Gerais e saiba fazer pão de queijo, desconsidere qualquer inconsistência na receita. =) Ingredientes: 2 copos americanos de leite, 1 copo americano de água, 1/3 de um copo americano de óleo, 1 colher de sopa de sal, 500g de povilho doce, queijo ralado a gosto, 3 ovos. Passos do Preparo: Ferva o leite com a água e o óleo; Em uma vasilha misture o polvilho e o sal; Jogue o liquido fervido e misture com uma colher grande; Espere esfriar (30 minutos) e despeje o queijo ralado e os ovos; Misture a massa com a mão amassando até ficar homogênea; Faça bolinhas do tamanho que preferir; Sirva quentinho; Assuma, por absurdo, que poderemos fazer nossos pães de queijo no R que que os verbos destacados nos passos acima são funções que implementamos em R. Dessa forma, forma, pelo que sabemos de R, poderemos fazer nossos pães de queijo de forma que segue: sirva(fazer(misture(despeje(esperar(misture(ingredientes = c(povilho, sal), add = ferver(c(leite, óleo), add_agua = TRUE), colher_grande = TRUE), tempo = 30), homogenea = TRUE), modo = &quot;amassando&quot;), formato = &quot;bolinha&quot;), modo = &quot;quentinho&quot;) Perceba que o código acima poderá ser um pouco confuso, uma vez que envolve muitas composições de funções. Porém, nada impede que você esteja salvando os resultados intermediários em objetos, de modo a facilitar a leitura do código ao relacionar esses objetos intermediários. Fazer isso funciona bem e eu particularmente utilizo muito. Porém, você também poderá fazer uso de pipes (operador %&gt;%) que poderá, nessas situações, deixar a leitura do código mais fácil, lógica e consequentimente mais compreensível., como veremos adiante. O operador de tubo %&gt;% foi implementando no pacote magrittr por Stefan Milton Bache e atualmente recebe a colaboração de diversas pessoas, incluindo programadores da RStudio, Inc. Atualmente, o pacote não recebe muitas atualizações, muito provavelmente por já está estável e cumprindo bem o seu papel. O nome magrittr muito provavelmente faz alusão à René Magritte, um dos principais pintores surrealista belga, em que a letra r, ao final, obviamente faz referências à linguagem R. É possível inferir isso com base no logo do pacote, apresentado logo abaixo: Figura 5.1: Logo do pacote magrittr com frase Ceci n’est pas une pipe (ouça a pronuncia, mesmo frase que acompanha pintura La trahison des images de René Magritte. Voltemos à algo mais interessante, ao preparo de pães de queijo. O preparo, “em R”, poderia ser quase tão saboroso quanto comer os pães de queijo, se fossem “preparados” utilizando o operador %&gt;%, na forma que segue: # Fazendo pão de queijo utilizando o operador pipe, isto é, # utilizando o operador %&gt;%. ferver(ingradientes = c(leite, água, óleo)) %&gt;% misturar(colher_grande = TRUE) %&gt;% esperar(tempo = 30) %&gt;% despejar(ingredientes = c(&quot;queijo&quot;, &quot;ovos&quot;)) %&gt;% amassar(forma = &quot;mãos&quot;) %&gt;% fazer_bolinhas(volume = 1) %&gt;% sirvir(froma = &quot;quentinho&quot;) É possível observar que o código acima é consideravelmente mais legível que o código apresentado mais acima desta subseção. O código acima é mais legível, por que os verbos/funções são encadeadas na sequência lógica do preparo e não lidos de dentro para fora, como no primeiro exemplo. Olhando rapidamente para cada um dos códigos, percebemos que o código que faz uso do operador %&gt;% fornece mais informações a respeito do que se está à fazer. Importante: Apesar de ser um operador útil, não exagere no uso de %&gt;%, principalmente quando se tem um conjunto de passos demasiadamente grande. Nessas situações, procure atribuir parte do código à objetos intermediários e depois componha esses objetos. Além disso, as funções envolvidas possuem diversas entradas e saídas, pode ser que o uso do operador %&gt;% não seja interessante. No RStudio, você poderá utilizar o atalho Ctrl + Shift + M como atalho para escrever mais rapidamente o operador %&gt;%. Nota: Como curiosidade, o recurso de pipes estão disponíveis em outras linguagens de programação, como F#, e os pielines de sistemas *nix que usa pipes para a comunicação entre os processos utilizando passagem de mensagens. Você poderá instalar o magrittr diretamente pelo CRAN ou por meio do repositório GitHub do pacote, ou seja, por meio de um dos comandos abaixo: # Instalando o pacote magrittr disponível # nos repositórios do CRAN. library(magrittr) # ou # Para instalar pacotes diretamente do GitHub, # você de deve ter instalado o pacote # devtools para poder fazer uso da função # install_github(). # Instalando o repositório magrittr do usuário/organização de # nome tidyverse do GitHub. devtools::install_github(&quot;tidyverse/magrittr&quot;, ref = &quot;master&quot;) Nota: Há pontos positivos e negativos ao considerar a instalação de um pacote diretamente do epositório do pacote no GitHub ou em qualquer outro sistema de hospedagem de código. Mencionarei apenas GitHub, mas o comentário se extende à outros sistemas de hospedagem de códigos, como, por exemplo, o GitLab. Basicamente, o ponto positivo refere-se à possibilidade de estarmos instalando uma versão mais recente do pacote, porém, em alguns casos, o pacote poderá apresentar alguns bugs, muito embora os códigos no branch master são normalmente estáveis e possuem códigos iguais aos que temos no CRAN. Instalar diretamente um pacote que está sendo mantido no GitHub dará a possibilidade de instalar versões mais recentes do pacote que ainda não encontram-se no CRAN. Pelo GitHub, você também terá a vantagem de instalar versões mais antigas do pacote. Por exemplo, no repositório do magrittr, no GitHub, você verá que, em Branch, haverá diversas versões versionadas do pacote, em que uma delas chama-se dev. Fazer devtools::install_github(\"tidyverse/magrittr\", ref = \"dev\") fará com que você instale a versão de desenvolvimento do pacote. Dessa forma, aconselho que sempre considere a instalação da versão no branch master de qualquer pacote que venha instalar diretamente do GitHub. Assim, haverá menos possibilidade de você deparar-se com códigos que ainda não funcionam ou que possuam algum(s) bug(s). Para um entendimento geral do operador %&gt;%, considere a existência dos objetos x, ye f. Então, x %&gt;% f(y) irá atribuir o objeto x à f, como primeiro argumento da função f, ou seja, será equivalente à fazer f(x, y). Porém, nem sempre desejamos introduzir o que está a esquerda do operador %&gt;% como primeiro agumento daquilo que está à sua direita. Para isso, poderemos fazer uso do caracter . (ponto). Esse caracter irá designar em qual posição será introduzido o objeto à esquerda de %&gt;% na função à sua direita. Por exemplo, a expressão x %&gt;% f(a, b = .) fará com que x à esqueda de %&gt;% seja substituído no lugar do caracter ., ou seja, x é passado como argumento à b, segundo argumento de f. Exemplo: Uso do caracter . em um contexto de bloco de instrução. Esse exemplo mostra que o que está a direita do operador %&gt;% não necessariamente precisa ser uma função. Nesses casos, o caracter . é de grande importância para que o operador saiba substituir corretamente o objeto x no bloco de instruções. library(magrittr) x &lt;- mtcars x %&gt;% { if (is.data.frame(.) || is.matrix(.)){ cat(&quot;A dimensão dos dados é&quot;, dim(.)) } else { cat(&quot;Objeto não é uma matriz ou um data frame&quot;) } } ## A dimensão dos dados é 32 11 Nota: Observe que, por exemplo, fazer x %&gt;% f(., y = 1) equivale a fazer x %&gt;% f(y = 1), uma vez que por padrão, o objeto que está à esquerda de %&gt;%sempre será substituído como primeiro argumento da função que está mais a sua direta, caso não seja utilizado o caractere . para indicar o lugar do substituição. Um outro operador útil disponível no pacote magrittr é o operator tee, denotado por %T&gt;%. Esse operador funciona de forma muito parecida com o operador %&gt;%, exceto pelo fato de que ele irá retornar o conteúdo do lado esquedo e não o resultado da operação do seu lado diretio. O uso do operador %T&gt;% não é tão comum. Normalmente a frequência de uso do operador %&gt;% é muito maior. Porém, veja que não é possível resolver o exemplo que segue utilizando apenas o operador %&gt;%. Exemplo: Pelo que entendemos do operador %&gt;%, não faz nenhum sentido o código abaixo: # Fixando uma semente. set.seed(0) rnorm(1000L) %&gt;% hist(., main = &quot;Histograma Qualquer&quot;, xlab = &quot;x&quot;, ylab = &quot;Frequência&quot;) %&gt;% mean ## Warning in mean.default(.): argumento não é numérico nem lógico: retornando ## NA ## [1] NA Nesse exemplo, observamos que o histograma foi construído, porém, não faz nenhum sentido passar um gráfico à função mean. Muito provavelmente o desejo de quem viria escrever um código como esse seria tirar a média do vetor resultante do código rnorm(1000L). Nessas situações, poderemos fazer uso do operador %T&gt;% (operador tee). Exemplo: Aqui temos um típico uso do operador %T&gt;%. Perceba que utilizando o perador %T&gt;%, foi possível passar rnorm(1000L) como argumento à função hist, assim como seria possível utilizando o operador %&gt;%. Porém, com o operador %T&gt;%, conseguimos passar rnorm(1000L) à função mean e não à função hist, que seria esperado se utilizássemos o operador %&gt;%. # Fixando uma semente. set.seed(0) rnorm(1000L) %T&gt;% hist(., main = &quot;Histograma Qualquer&quot;, xlab = &quot;x&quot;, ylab = &quot;Frequência&quot;) %&gt;% mean ## [1] -0.01582957 Um outro operador pipe que é bastante útil é o perador de exposição, denotado por %$%. Trata-se de um operador que é bastante útil quando estamos trabalhando com (quadro de dados) data frames ou matrizes, onde temos variáveis dispostas em suas colunas. Com esse operador, poderemos tornar visíveis as variáveis do objeto à sua esquerda nas funções à sua direita. Considere o exemplo que segue: Exemplo: No código que segue, estamos tornando visíveis as variáveis do objeto mtcars na função cor. Dessa forma, poderemos calcular a correlação entre as variáveis cyl e hp do data frame mtcars. mtcars %$% cor(cyl, hp) ## [1] 0.8324475 Nota: Normalmente esse operador é útil quando a função a direita não possui argumento de dados. Por exemplo, se o objetivo fosse calcular uma regressão linear simples com essas variáveis, poderíamos fazer: mtcars %&gt;% lm(cyl ~ hp, data = .) ## ## Call: ## lm(formula = cyl ~ hp, data = .) ## ## Coefficients: ## (Intercept) hp ## 3.00680 0.02168 uma vez que a função lm já possui um argumento para o conjunto de dados a ser utilizado. Ao passar o conjunto de dados para a função lm, todas as variáveis de mtcars estarão visíveis no interior da função lm. Por fim e não menos importante, existe o operador de pipe compostos, denotado por %&lt;&gt;%. Esse operador é útil quando queremos realizar uma operação e atribuir essa modificação ao objeto à esquerda do operador. Considere um exemplo de uso do operador de pipe composto: Exemplo: Utilizando o operador %&lt;&gt;% para alterar o conteúdo da variável disp do data frame mtcars. Perceba que ao chamar mtcars, a variável disp agora é do tipo inteiro. mtcars$disp %&lt;&gt;% as.integer() str(mtcars) ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: int 160 160 108 258 360 225 360 146 140 167 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... Observação: Alguns pacotes de R possuem vinhetas que facilitam o entendimento das funções empacotadas. Não necessariamente as vinhetas irão dissertar sobre todas as funções implementadas. Porém, essas vinhetas normalmente focam no que há de mais importante no pacote. Você poderá encontrar a vinheta do pacote magrittr aqui. Normalmente essas vinhetas são mais fáceis de serem lidas do que as documentações dos pacotes. Porém, consultar a documentação é o caminho correto para encontrar as respostas mais difícies e que muitas vezes não são abordadas nas vinhetas. Exercícios Resolva os exercícios que seguem. Os operadores pipes que você utilizará para resolver os exercícios não necessariamente irão produzir as melhores soluções. Porém, esses exercícios farão você pensar a respeito do emprego dos operadores e, aqui, é isso o que importará. Resolva os itens abaixo utilizando o operador %&gt;% do pacote magrittr: as.character(log(cos(sin(pi)))) round(var(seq(from = 1, to = 10, by = 0.5)), digits = 1) summary(anova(lm(mpg ~ wt, data = mtcars))) summary(lm(dist ~ log(accel), data = na.omit(attenu))) Sem salvar objetos intermediários, utilize operadore(s) pipe(s) para reescrever o código abaixo: dados &lt;- subset(iris, Sepal.Length &gt; mean(Sepal.Length)) cor(dados$Sepal.Length, dados$Sepal.Width) Sem salvar objetos intermediários, utilize operadore(s) pipe(s) para reescrever o código abaixo: vetor &lt;- 1:10 plot(matrix(data = vetor, ncol = 5, nrow = 5)) quantil &lt;- quantile(vetor) print(quantil) Sem fazer uso dos operadores de atribuições &lt;- ou =, reescreva o código abaixo usando operadore(s) pipe(s): mtcars &lt;- transform(mtcars, cyl = cyl * 2) Considere o código abaixo que faz uso do operador %&gt;%. Dica: busque nas documentações do pacote magrittr, o uso das funções subtract e divide_by. O que esse código faz? Reescreva-o sem fazer uso do operador %&gt;%. vetor &lt;- c(1.7, 2.74, 5.66, 8.13, 4.04) vetor %&lt;&gt;% subtract(., mean(.)) vetor %&gt;% divide_by(., sd(.)) Considere o código abaixo e reescreva-o utilizando o operador %&gt;% sem utilizar de passos intermediários. Dica: Procure identificar o uso da função extract do pacote magrittr. # Essa função não deverá entrar no pipe. set.seed(0) x &lt;- runif(n = 100, min = 0, max = 100) x &lt;- x[x &gt; 10 &amp; x &lt; 30] round(mean(x), digits = 1) Reescreva o código abaixo utilizando o operador pipe %&gt;%. dados &lt;- subset(iris, Sepal.Length &gt; 5) aggregate(Sepal.Length ~ Species, dados, FUN = mean) Tente reescrever o código apenas utilizando o operador %&gt;%e depois modifique-o para utilizar o operador de exposição %$%. Dica: procure entender o emprego das funções subset e aggregate, funções dos pacotes base e stats, respectivamente. Estude a vinheta do pacote magrittr. Acesse a vinheta aqui. Explique o que o código abaixo faz: f &lt;- . %&gt;% subtract(., mean(.)) %&gt;% divide_by(., sd(.)) Use o que aprendeu ao resolver o exercício anterior para reescrever o código abaixo usando pipes: vetor &lt;- c(1.7, 2.74, 5.66, 8.13, 4.04) sum(x - mean(x))/sd(x) 5.2 Funções Como já sabemos, uma vez que você deve ter utilizado bastante o confeito de funções ao resolver os exercícios sugeridos, funções são objetos que recebe uma ou algumas entradas, as processas em seu interior e te retorna uma ou mais saída(s). O diagrama 5.2 mostra um comportamento genérico de uma função qualquer (function) que recebe uma quantidade arbitrária de argumentos, com estruturas de dados distintas, e retorna também uma quantidade arbitrária de informações, objetos com estruturas de dados distintas: Figura 5.2: Comportamento genérico da função de nome function que recebe diversos argumentos com estruturas de dados distintas e retorna diversos diversos objetos com estuturas de dados distintas. Note que new structure, no diagrama, deixa claro que o programador poderá criar suas novas estruturas de dados que poderão ser passadas e/ou retornadas por uma função. Importante: Algo que torma uma função bastante flexível é a capacidade de podermos passar funções como argumentos à outras funções. Muito embora esse fato não esteja destacado no diagrama acima, nunca se esqueça que, em R, você facilmente poderá passar uma função como argumento de uma outra função. Exemplo: round(sum(c(1.73, 2.47, 7.21, 8.74, NA), na.rm = TRUE), digits = 1) Uma função em R é dividida em três partes: Lista de Argumentos: Conjunto de argumentos, podendo ter as mais variadas estruras de dados que pode inclusive alterar o comportamento da função. Corpo: Código no interior da função que será capas de processar e tomar decisões de acordo com sua lista de argumentos. Ambiente: Os ambientes (environment) de reconhecimentos de objetos no interior da função. Isso permite que possamos ter objetos com o mesmo nome referindo-se à conteúdos distintos na memória do computador. Como já sabemos, mas irei repetir, a forma geral de implementação de uma função é: f &lt;- function(argumentos){ # Aqui é onde as coisas acontecem. corpo } # Fim da função. Poderemos identificar essas três partes de uma função utilizando as funções formals(), body() e environment(). Por exemplo, considere a função abaixo: f &lt;- function(x, y){ `+`(x,y) } # Lista de argumentos. formals(f) ## $x ## ## ## $y # Corpo da função. body(f) ## { ## x + y ## } # Ambiente que a função foi definida. environment(f) ## &lt;environment: R_GlobalEnv&gt; Além disso, lembre-se que funções podem ter argumentos com valores já pré-definidos, como é o caso de f() no código que segue: f &lt;- function(x = 1, y = 2){ x + y } f(5) ## [1] 7 f(2,4) ## [1] 6 5.2.1 Passando atributos Uma função em R é um objeto qualquer. Dessa forma, assim como qualquer objeto, uma função poderá carregar consigo uma quantidade qualquer de atributos que podem ser recuperados e utilizados a qualquer momento. Considere os códigos que seguem: # Vetor com valores inteiros em memória de 1 à 10. x &lt;- 1L:10L # Introduzindo dois argumentos ao objeto x. # Primeiro argumento: desc, que apresenta uma pequena descrição do objeto x. # Segundo argumento: M, uma matriz qualquer que poderia vir a ser útil guardar. attr(x = x, which = &quot;desc&quot;) &lt;- &quot;vetor com valores inteiros&quot; attr(x = x, which = &quot;M&quot;) &lt;- matrix(data = c(1, 7, 3, 8), ncol = 2, nrow = 2) Note que agora o objeto x carrega não apenas os valores inteiros de 1 a 10. Foram acrescentados dois argumentos à x, são eles, desc que contém uma string descrevendo o que é o objeto x. Perceba que os atributos não afetam as operações que realizamos com x, mas poderemos, se desejarmos, acessar os atributos e trabalharmos com eles, como postra o trecho de código abaixo: # Os atributos não irão afetar as operações realizadas # considerando o objeto x. sum(x + 1) ## [1] 65 # Listando os atributos do objeto x: attributes(x) ## $desc ## [1] &quot;vetor com valores inteiros&quot; ## ## $M ## [,1] [,2] ## [1,] 1 3 ## [2,] 7 8 # Acessando o atributo de nome M (uma matriz) # e invertendo. solve(attr(x, &quot;M&quot;)) ## [,1] [,2] ## [1,] -0.6153846 0.23076923 ## [2,] 0.5384615 -0.07692308 Como é possível introduzir atributos à qualquer objeto em R, e funções são objetos, então considerre o trecho de código que segue, em que é introduzido o atributo M do objeto x como atributo da função f() abaixo: # Retorna os caracteres &quot;-&quot;, &quot;0&quot;, &quot;+&quot; # a depender do valor informado. f &lt;- function(x){ # x é um objeto numérico. if (x == 0) &quot;0&quot; else ifelse(x &gt; 0, &quot;+&quot;, &quot;-&quot;) } # Introduzindo o atributo de nome desc que contém uma breve descrição da # função f(): attr(f, &quot;desc&quot;) &lt;- &quot;retorna -, 0 ou +, a depender do valor passado à x&quot; # Acessando o conteúdo do atributo desc: attr(f, &quot;desc&quot;) ## [1] &quot;retorna -, 0 ou +, a depender do valor passado à x&quot; Sabemos que o uso da função body() permete-nos acessar o corpo de uma função (código da função). Porém, você apenas irá visualizar as partes do código que foram implementadas estritamente em R. Por exemplo, no trecho de código abaixo é apresentado o sudo da função body() sobre uma função implementada em R e outra função que tem o seu código implementado em uma linguagem de mais baixo nível: # Acessando o corpo da fução rm(): body(ls) # Tentando acessar o corpo da função sum(): body(sum) Note que foi possível acessar parte do conteúdo, implementado em R, da função rm(). Porém, no caso da função sum() o retorno foi NULL, uma vez que essa função é por completo implementada em uma linguagem de mais baixo nível. Isso se deve ao fato de que essas funções foram escritas em linguagens compiladas como o caso de C/C++, camhando assim um código objeto e não um código fonte. Em muitas situações desejamos passar uma função como argumento à outra função. O trecho de código abaixo cria duas simples funções, f() e g(), em que passamos f() como argumento à função g(): # As funções não necessariamente necessitam ter argumentos. f &lt;- function(){ &quot;Olá&quot; } g &lt;- function(func){ paste(func, &quot;mundo&quot;, sep = &quot; &quot;) } # Passando a função f() como argumento da função g(): g(func = f()) ## [1] &quot;Olá mundo&quot; # Compondo as funçoes nchar(), g() e f(). # A função nchar() retorna a quantidade de caracteres # na estring retornada por g(). nchar(g(func = f())) ## [1] 9 5.2.2 Funções anônimas Algo que é bastante útil quando estamos trabalhando com funções é a possibilidade de não nomear uma função. Essa estratégia é interessante quando temos funções curtas que não queremos nos dar o trabalho de pensarmos em um nome. Normalmente, aplica-se à casos de funções curtas que são passadas como argumento à outras funções. O trecho de código que segue apresenta o uso de uma função anônima passada como argumento à função integrate() de R: # Passando a função anônima function(x) x ^ 2 como argumento da # função integrate(). integrate(function(x) x ^ 2, lower = 0, upper = 2)$value ## [1] 2.666667 Não esqueça que, em muitos casos, compor funções utilizando o operador %&gt;% pode ser interessante. As composições acimas poderiam ser realizadas da forma que segue: # Primeira composição utilizando o operador %&gt;%: f %&gt;% g %&gt;% nchar # Segunda composição utulizando os operadores pipes %&gt;% e %$%: (function(x) x^2) %&gt;% integrate(lower = 0, upper = 2) %$% value Nota: Utilizar os operadores pipes pode ser interessante quando estamos a fazer uma análise de dados, em que queremos deixar claro uma sequência lógica de operações. Porém, note que pipes não irão tornar o seu código mais eficientes do ponto de vista computacional, nem o contrário, ou seja, utilizar pipes não irão tornar os seus códigos menos eficientes. 5.2.3 Escopo léxico Em computação, o escopo é o que delimita a relação de objetos e expressões, ou seja, em que partes do código um ou mais objetos são reconhecidos por uma dada expressão ou conjunto de expressões. Na maioria das linguagens de programção o escopo é léxico, também chamado de escopo estático, uma vez que podem ser delimitados estaticamente, antes da execução do programa por meio da sintaxe da linguagem, ou seja, por meio da estrutura léxica da linguagem. A linguagem R tem escopo léxico, assim como diversas outras linguagens de programação. Trata-se de tipo de escopo comum em linguagens como Pascal, C, C++, Ada, Go, Haskell, R, Julia, Python, Ruby, entre diversas outras. Considere o exemplo apresentado no código abaixo: x &lt;- &quot;fora&quot; f &lt;- function(){ x &lt;- &quot;dentro&quot; x }; f() ## [1] &quot;dentro&quot; Para quem já programa um pouco em R, o retorno da função f() era esperado, uma vez que olhando para o código, entendemos facilmente qual a saída, uma vez que a sintaxe nos acusa (escopo léxico). Na verdade, o termo vem de lexing, que refere-se ao processo de conversão de partes significativas do código intendíveis para o interpretador. Existem linguagens que fazem uso de escopo dinâmico, como é o caso do Emacs Lisp, shell Bash, LaTeX (linguagem de marcação), entre outras. Como esse não é o caso da linguagem R que frequentemente nos deparamos em R, aqui não é o lugar para dissertar em relação à esse assunto. No código acima, perceba que havia um objeto x definido no interior da função. Dessa forma, o retorno da função buscará por referências à x no mesmo escopo da função, isto é, irá considerar x definido por x &lt;- \"dentro\". Porém, considere a simples modificação do código na forma que segue: x &lt;- &quot;fora&quot; f &lt;- function(){ x }; f() ## [1] &quot;fora&quot; No código acima, a função f() não pode encontrar referências ao objeto x no interior da função. Dessa forma, R considerar-a o objeto x no respectivo escopo mais externo, que nesse caso é o objeto x definido por x &lt;- \"fora\". Esse comportamento é válido se consideramos estruturas mais aninhadas, como a que é apresentada no código que segue: x &lt;- &quot;estou fora de f&quot; f &lt;- function(){ # Podemos definir funções dentro de funções. g &lt;- function(){ x } # fim da função interna list(g = g(), x = x) } # fim da função externa f() ## $g ## [1] &quot;estou fora de f&quot; ## ## $x ## [1] &quot;estou fora de f&quot; Perceba que tanto o retorno da função g() quando o objeto x da função f() referem-se ao valor de x definido fora do escopo da função f(). Isso se deve ao fato da linguagem R procurar um objeto de nome x de froma sucessivas, partindo do escopo ao qual o objeto é invocado à escopos em níveis mais externos. No código acima, tanto g() definida dentro de f() quanto a prórpia função f() apenas encontrará referência à x no ambiente mais externo, isto é, será considerado o objeto x definido por x &lt;- \"estou fora de f\". Algo interessante de se observar é que muito embora o R procure em escopos mais externos a primeira referência ao objeto que invocamos em um escopo mais interno, escopo este em que não há nenhuma referência à este objeto, em futuras invocações da função, a partir da segunda chamada, o objeto x já encontra-se definido no interior da função f(). x &lt;- 0 f &lt;- function(){ # x encontra-se definido no escopo externo na primeira chamada à # função f. x &lt;- x + 1 x } f() ## [1] 1 f() ## [1] 1 Observe que mesmo que você chame por diversas vezes consecutivas a função f() o retorno sempre será 1. Para ser possível obter somas em 1 iterativas, uma solução para esse problema seria fazer uso do operador de atribuição profunda, denotado por &lt;&lt;-. Esse operador permite que as alterações no objeto x ocorra no primeiro escopo mais abrangente que faz referência à um objeto x. Considere o trecho de código que segue: x &lt;- 0 f &lt;- function(){ # x encontra-se definido no escopo externo na primeira chamada à # função f. x &lt;&lt;- x + 1 # Operador de atribuição profunda. x } f() ## [1] 1 f() ## [1] 2 Porém, perceba o resultado que segue: x &lt;- 0 f &lt;- function(){ x = 7 x &lt;&lt;- x + 1 # Operador de atribuição profunda. x } f() ## [1] 7 x ## [1] 8 Note no código acima que o valor retornado pela função é 7 (sempre) e não 8, como alguns poderiam esperar. Perceba que isso se deve ao fato de que no interior de f(), sempre teremos que x ao lado direito do operador &lt;&lt;- será 7, uma vez que em todas as chamadas, há dentro da função f() a definição de x = 7. Isso também implicará que o valor de x do lado esquerdo do operador &lt;&lt;- sempre será atualizado para 8, em todas as chamadas. Veja que x ao lado esquerdo de &lt;&lt;- refere-se ao objeto x no escopo mais extero ao escopo de x no interior da função. Observação: Em R, os operadores &lt;- e &lt;&lt;- também informam o sentido da atribuição, que normalmente é da direita para a esquerda, assim como ocorre ao considerar o operador =. Quase sempre as atribuições são da esquerda para a direita, com exceção das situações em que invertemos os sentidos dos operadores &lt;- e &lt;&lt;-, isto é, quando consideramos as variantes -&gt; e -&gt;&gt;, respectivamente. Exemplo: f &lt;- function(){ 2 -&gt; x x * 2 -&gt;&gt; x x } f(); x ## [1] 2 ## [1] 4 5.2.4 Avaliação preguiçosa Tecnicamente, os argumentos de uma função são promessas promises e fazem parte do mecanismo de (lazy evaluation). Quando uma função é chamada, cada um de seus argumentos formais são vinculados à uma promessa. Dessa forma, cada promessa, para cada um dos argumentos, armazenam a expressão do argumento e um ponteiro para o ambiente ao qual a função foi chamada. Tais promessas não armazenam nenhum valor, até o momento em que o argumento seja necessário para a função. Sendo assim, (promises) trata-se de uma estrutura de dados. Promisses possuem: Um ambiente: ambiente em que uma função é avaliada/invocada. Uma expressão: uma expressão válida passada para um argumento de uma função; Um valor: resultado da avaliação de uma expressão em um ambiente específico. Em R, os argumentos de uma função são avaliados de forma preguiçosa (lazy evaluation), são apenas promessas, ou seja, só serão avaliados na necessidade de uso do parâmetro. Em outras palavras, um parâmetro poderá eventualmente nunca ser avaliado quando uma função é executada. Considere o código que segue: # A função f() tem o argumento x que # não é utilizado. f &lt;- function(x){ y &lt;- 1 y } f() ## [1] 1 Como é possível observar, a função f() possui x como argumento, argumento este que em nenhum momento é utilizado. Dessa forma, mesmo que x não esteja definido, não teremos como retorno um erro ao executar f(). Isso se deve ao fato de que argumentos de funções, em R, são avaliados de forma preguiçosa. Um dos grandes benefícios da avaliação preguiçosa é a possibilidade que temos de atrasar a computação, de modo que um dos argumentos poderá conter cálculos intensivos que só será avaliado se necessário. Dessa forma, devido a possibilidade de uma função matemática poder ser passado como argumento à uma funçãom, que ventualmente pode ser algo custoso do ponto de vista computacional, lazy evaluation é o padrão da linguagem. Importante: Como estamos a falar de argumeto de funções, destaco algo importante da linguagem R. Ao se utilizar o operador &lt;- para realizar uma atribuição em uma chamada de função, a variável é ligada fora da função, ou seja, no ambiente em que a função é chamada, como mostra o exemplo que segue: Exemplo: y &lt;- 0 f &lt;- function(x){ y &lt;- 2 x + 1 } f(y &lt;- 7) ## [1] 8 y ## [1] 7 Perceba que fazer f(y = 7) retornará um erro, uma vez que R entende que estamos passando o valor 7 à um argumento y que não existe em f(). Note que f(y &lt;- 7) é equivalente a escrever f(x = y &lt;- 7) ou f(x = (y = 7)). Porém, ao utilizarmos o operador &lt;-, além de passarmos os argumentos à f() estamos também criando os objetos à esquerda do operador fora da função. 5.2.5 varargs: … (dot-dot-dot) Algo bastante útil e que torna flexível uma linguagem de programação é a possibilidade de escrever funções com quantidade variádicas de argumentos, isto é, funções varargs. Em R isso é possível especificando o argumento especial ... (dot-dot-dot), ou ponto-ponto-ponto, em português. Um uso comum do operador ... é a possibilidade de passarmos argumentos adicionais para uma função que utilizamos em nossa implementação. Por exmeplo, considere o código abaixo: # Fixando uma semente para gerarmos sempre a mesma amostra. set.seed(0) # Gerando um conjunto de dados com distribuição normal padrão. data &lt;- rnorm(n = 100, mean = 0, sd = 1) myhist &lt;- function(x = data, ...){ # Perceba o uso de ... em hist(): result &lt;- hist(x, ...) list(n = length(result$counts), counts = result$counts) } # A função myhist() não possuia a definição dos argumentos col, # main, ylab e border. myhist(x = data, col = rgb(1, 0.9, 0.8), main = &quot;&quot;, ylab = &quot;Frequência&quot;, border = NA) ## $n ## [1] 10 ## ## $counts ## [1] 1 2 8 15 26 19 14 12 1 2 A função myhist(), implementada acima, constroi um histograma com base em um vetor de dados passado como argumento à x, retornando uma lista com o número de classes e a quantidade de observações da amostra, em cada uma das classes. Note que myhist() possui apenas dois argumentos, x e ..., respectivamente. O argumento especial ... permite que myhist() herde todos argumentos da função hist(). Asim, muito embora a função myhist() não possui os argumentos col, main, ylabe border definidos formalmente, poderemos ascessar esses e os demais argumentos de hist() mesmo sem defini-los. Nas situações em que desejarmos acessar os elementos passados à ... por suas posições, poderemos fazer uso da notação especial ..1, ..2, etc. Considere o trecho de código que segue: f &lt;- function(...){ n &lt;- ...length() if (n != 3) stop(&quot;A função deve ter exatamente 3 argumentos.&quot;) else for(i in 1:...length()){ cat(&quot;O elemento &quot;, i, &quot; de \\&quot;...\\&quot; é: &quot;, ...elt(i), &quot;\\n&quot;) } return(..1 * ..2 + ..3) } f(2, 3, 1) ## O elemento 1 de &quot;...&quot; é: 2 ## O elemento 2 de &quot;...&quot; é: 3 ## O elemento 3 de &quot;...&quot; é: 1 ## [1] 7 Note que a função f() retorna o produto do primeiro com o segundo argumento e soma com o terceiro. Além disso, foram utilizadas as funções ...length() que retorna o tamanho de ... e ...elt(i) que equivale à ..i. A função ...elt(i) nada mais é do que fazer eval(paste0(\"..\", n)). Como dito, uma das grandes vantagens do uso de ... é a possibilidade de passarmos argumento de outras funções que estão sendo utilizadas pela função que estamos a implementar. O uso de funções varargs destacam-se também em situações em que fazemos uso de programação orientada à objeto por função genérica, sistema de orientação à objeto conhecido, em R, como sistema S3 de orientação à objeto e que estudaremos mais a frente. Considerando o sistema S3 de orientação à objeto, note que funções como summary() e print() podem ser utilizadas em diversas situações e que muito provavelmente terão argumentos distintos em cada uma dessas circunstâncias. A capacidade de uma função ter várias formas e se adequar a cada uma delas está fortemente relacionada com a definição de funções polimórficas, uma das principais características do paradigma de programação orientada à objeto e que está intimamente relacionadas com funções varargs, principalmente no sistema S3. Perceba que diversas funções R são varargs, por exemplos, a função sum(). Note, no trecho de código abaixo, que a característica de lazy evaluation quando associada à uma função com um número arbitrário de argumentos poderá retornar algo equivocado e nenhum erro é dado para nos alertarmos de um possível problema: sum(1:5, NA, narm = TRUE) ## [1] NA Para o código acima, gostaríamos que o equívoco a respeito do nome correto do argumento (na.rm) não tivesse ocorrido. Aqui, nosso interesse seria fazer: sum(1:5, NA, na.rm = TRUE) ## [1] 15 Nota: Um outro inconveniente de construir funções varargs além dos equívocos desarpesebidos quando erramos algum de seus arugmentos é que essas funções normalmente são um pouco mais complicadas de serem documentadas, visto que devemos ter um grande cuidado ao deixar claro como os argumentos serão substituídos e utilizados. Esses problemas não são suficientes justificar um desaconselho do uso de funções varargs. Na verdade é muito importante a construção de funções varargs e você deve utilizar, sempre que puder e na medida da necessidade, uma vez que isto tornará suas funções bastante flexíveis. 5.2.6 Funções infixas Para começarmos a falar de funções infixas (infix), os slogans abaixo, traduzidos para o português, poderão ser úteis para um melhor entendimento: \"Para entender a computação em R, dois slogans são úteis: Tudo o que existe é um objeto. Tudo o que acontece é uma chamada de função.\" — John M. Chambers, no artigo intitulado Object-Oriented Programming, Functional Programming and R, Statistical Science, Vol. 29, 2014, p. 170. Nas situações de funções que possuem dois argumentos, construir um operador infixo pode ser de grande utilidade. O exemplo abaixo mostra duas formas de somarmos dois termos utilizando a função `+` e o operador infixo +, respectivamente. Perceba que a segunda forma é mais conveniente que a primeira: x &lt;- y &lt;- 1 # Forma 1 (prefix): `+`(x, y) ## [1] 2 # Forma 2 (infix): x + y ## [1] 2 Além dos operadores matemáticos +, -, * e / serem funções infixas, podendo também chamar de operadores infixos ou infix, diversas outras funções são infixas, como por exemplo, ^, ::, &amp;, |, &amp;&amp;, ||, &lt;=, &gt;=, &lt;, &gt;, ==, !=, $, %%, %*%, %in%, &lt;-, &lt;&lt;-, entre diversas outras funções. O exemplo abaixo apreseta o uso de algumas dessas funções na forma prefixa: `&lt;=`(1,3) ## [1] TRUE `^`(2,3) ## [1] 8 x &lt;- list(a = 1, b = 2) `$`(x, a) ## [1] 1 Assim como existem diversas funções infixas em R previamente implementadas, também poderemos construir nossas funções infixas. Para tanto, basta considerarmos a notação %nome%, em que nome deverá ser substituído por um nome válido de função. Considere o código abaixo: `%+%` &lt;- function(x, n){ rep(x, times = n) } # Forma prefixa: `%+%`(&quot;infix&quot;, 4) ## [1] &quot;infix&quot; &quot;infix&quot; &quot;infix&quot; &quot;infix&quot; # Forma infixa: &quot;infix&quot; %+% 4 ## [1] &quot;infix&quot; &quot;infix&quot; &quot;infix&quot; &quot;infix&quot; 5.2.7 Função de substituição Você muito provavelmente já deve ter feito uso de funções de substituição, como por exemplo, names(), colnames(), rownames(), entre outras funções. Essas são chamadas de funções de substituição devido ao comportamento que é expresso no código que segue: vetor &lt;- c(1,2,3) names(vetor) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) x ## $a ## [1] 1 ## ## $b ## [1] 2 A função names(), para produzir o mesmo resultado do código acima, poderia ser invocada na foma que segue: vetor &lt;- c(1,2,3) `names&lt;-`(x = vetor, value = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## a b c ## 1 2 3 Pelo código acima podemos perceber que as funções de substituição nada mais são que funções de dois argumentos, a saber x e value, respectivamente. Dessa forma, os valores passados à value modificam o objeto x que nesse caso são os nomes do objeto vetor. Exemplo: Implementação da função de substituição samenames() que atribui o mesmo nome à todos elementos do vetor x. `samenames&lt;-` &lt;- function(x, value){ if (length(value) != 1) stop(&quot;Um vetor de comprimento 1 deverá ser atribuído.&quot;) else{ names(x) &lt;- rep(value, times = length(x)) } x } x &lt;- 1L:10L samenames(x) &lt;- &quot;a&quot; x ## a a a a a a a a a a ## 1 2 3 4 5 6 7 8 9 10 Em situações em que a função de substituição necessita de mais argumentos além dos argumentos obrigatórios x e value, deveremos colocá-los entre os argumentos x e value. No exemplo do código abaixo introduzimos o argumento rm.id em que, se desejarmos, poderemos omitir algumas posições do vetor x: `samenames&lt;-` &lt;- function(x, rm.id = NULL, value){ if (length(value) != 1) stop(&quot;Um vetor de comprimento 1 deverá ser atribuído.&quot;) else if (!is.null(rm.id) &amp;&amp; is.numeric(rm.id)){ x &lt;- x[-rm.id] names(x) &lt;- rep(value, times = length(x)) }else{ names(x) &lt;- rep(value, times = length(x)) } x } x &lt;- 1L:10L samenames(x) &lt;- &quot;a&quot; # Removendo a primeira e a décima posição de x. samenames(x, c(1,10)) &lt;- &quot;a&quot; x ## a a a a a a a a ## 2 3 4 5 6 7 8 9 Observação: A linguagem R possui diversos outros recursos, escritos em forma especial, que também são funções. Abaixo pontuarei alguns desses recursos, para que você tenha uma ideia, porém, existem mais: (x) com representação prefixa dada por `(`(x); x[i] com representação prefixa dada por `[`(x, i); x[[i]] com representação prefixa dada por `[[`(x, i); {x} com representação prefixa dada por `{`(x); if(condicao) com representação prefixa dada por `if`(condicao, se_verdade, se_falso); for(variável in conjunto) ação com representação prefixa dada por `for`(variável, conjunto, ação); while(condição) ação com representação prefixa dada por `while`(cond, action). 5.2.8 Closures Como já sabemos, uma utilidade comum de funções anônimas está em criar pequenas funções que não vale a pena nomear. Normalmente são funções pequenas que são passadas como argumento à outras funções, fornecendo assim menos ruídos visuais no código e nos livrando da necessidade de pensarmos em um bom nome para a função. Um outro importante uso de funções anônimas está na necessidade closures. O conceito de closures surgiu na década de 1960 para avaliação de expressões no \\(\\lambda\\)-calculus (um sistema formal na lógica matemática para representar a computação com base na abstração de funções) e teve sua primeira implementação computacional em 1970 como um recurso da linguagem de programação PAL. Com o passar dos anos, diversas linguagens de programação permitiram o uso de closures, um recurso de programação muito utilizado quando necessitamos criar funções escritas por outras funções: Nota: Closure possui esse nome por se tratar de uma função que encerra o seu ambiente, passando seus parâmetros para o ambiente da função mais interna, função esta que será retornada e que executará o trabalho desejado. O trecho de código abaixo exemplifica o uso de closure, em que a função potencia() (função pai) poderá gerar novas funções de interesse, cujo trabalho será executado pela função anônima interna à função potencia(). Por exemplo, poderemos criar os objetos quadrado e cubo que serão as funções quadrado() e cubo(), respectivamente, sem a necessidade de implementar cada uma dessas funções. potencia &lt;- function(expoente) { # Função anônima. function(x) { x ^ expoente } } # Criando as funções quandrado() e cubo(). quadrado &lt;- potencia(2) cubo &lt;- potencia(3) # Utilizando as funções criadas pela função potencia(): quadrado(2) ## [1] 4 cubo(3) ## [1] 27 Importante: Perceba que as funções quadrado() e cubo() não foram implementadas diretamente. Além disso, nesse caso, note essas funções retornadas aos objetos quadrado e cubo são funções que possuem x como argumento que era argumento da função anônima. Exercícios Quais são os três componentes de uma função? Contrua o objeto y que retorne a saída abaixo: ## [1] 1 2 3 4 5 6 7 8 9 10 ## attr(,&quot;att_1&quot;) ## [1] &quot;Isso é um atributo&quot; Remova o atributo att_1 do objeto y acima. O que o código abaixo retorna? Explique. Dica: para certificar-se que esteja entendendo, tente prever sem executar a função. f &lt;- function(x){ f &lt;- function(x){ f &lt;- function(x){ x * 3 } f(x) * 2 } f(x) + 1 } f(7) O que o código abaixo retorna? Explique. Dica: para certificar-se que esteja entendendo, tente prever sem executar a função. x &lt;- 1 f &lt;- function() { x &lt;- 0 x &lt;&lt;- x + 1 x } f(); x O que o código abaixo retorna? Dica: para certificar-se que esteja entendendo, tente prever sem executar a função. f &lt;- function(){ y &lt;- 0 g &lt;- function(){ y &lt;&lt;- y + 1 } list(rep(x = g(), times = y), rep(x = g(), times = y), rep(x = g(), times = y)) } Implemente a função %+% que concatena duas strings. Permita que, por meio do uso prefixo da função, o usuário possa informar o caractere que separa as duas strings. Abaixo encontra-se um exemplo do uso infixo da função. &quot;Estatística&quot; %+% &quot;Computacional&quot; ## [1] &quot;Estatística Computacional&quot; Implemente a função segundo que trabalhe da seguinte forma: x &lt;- 1:10 segundo(x) &lt;- 5 x ## [1] 1 5 3 4 5 6 7 8 9 10 Implemente a função troca() que trabalhe da forma abaixo: x &lt;- 1:10 troca(x, 2) &lt;- 7 x ## [1] 1 7 3 4 5 6 7 8 9 10 Qual o retorno da função abaixo? Explique. f &lt;- function(y) { function(x) { x + y } } g &lt;- f(1) g(x = 2) Utilizando o conceito de closure e o operador ... (dot-dot-dot), construa a função cdf_expg(G) que recebe como argumento uma função de distribuição (qualquer), seja ela denotada por \\(G\\). A função cdf_expg(G) deverá retornar a função de distribuição \\(\\mathrm{Exp}-G\\) definida por \\[F(x) = G^a(x),\\] com \\(a &gt; 0\\). Perceba que \\(F\\) é uma nova distribuição de probabilidade com um parâmetro a mais (\\(a &gt; 0\\)) e que possui a distribuição \\(G\\) como caso particular quando \\(a = 1\\). Por exemplo, se cdf_weibull é a implementação da distribuição Weibull, então cdf_expg(G = cdf_weibull) deverá retornar uma função que implementa a distribuição \\(\\mathrm{Exp-Weibull}\\). 5.3 Funcionais Funcionais não são nada a mais que funções que recebe como argumento uma outra função como argumento e retorna um vetor como saída. O trecho de código que segue implementa o funcional f(), retornando um vetor como saída: # A função f() é um funcional. f &lt;- function(x, func) func(x) # Passando uma função à f() por meio do argumento func. # Foi passado à func uma função anônima. f(x = c(1, 2, 7, 10), func = function(x) x + 1) ## [1] 2 3 8 11 Perceba que a função f() é um funcional, visto que f() recebe uma função por meio do argumento func e retorna um vetor como saída, que nesse caso é o vetor passado ao argumento x de f() acrescido de um. Considere agora o trecho que segue: f &lt;- function() mean(runif(n = 10, min = 0, max = 1)) # A função loop() é um funcional. loop &lt;- function(x, func) { resultado &lt;- NULL for (i in seq_along(x)) resultado &lt;- c(resultado, func()) resultado } loop(x = 1:3, func = f) ## [1] 0.3702804 0.7174270 0.3805153 loop(x = 1:7, func = f) ## [1] 0.5092227 0.4038002 0.5425011 0.5148392 0.2298425 0.3374357 0.3344574 A função loop() é um funcional que reproduz a função passada ao argumento func um quantidade qualquer de vezes. No exemplo acima, loop(x = 1:3, func = f) e loop(x = 1:7, func = f) reproduz f() 3 (três) e 7 (sete) vezes, respectivamente. Em situações em que você deseja reproduzir uma função ou aplicá-la à cada posição de um vetor ou lista e isso se repete por diversas partes do seu código, o uso de um funcional poderá deixar seu código mais limpo, sem a necessidade de escrever muitas estruturas de repetições. No exemplo acima, se em outra parte do código houvesse a necessidade de reproduzir f() 10 (dez) vezes, bastaria fazer loop(x = 1:10, func = f) ao invés de escrever novamente um laço com alguma estrutura de repetição. Escrever estruturas de repetições, na forma acima, não é muito útil do ponto de vista de desempenho computacional, uma vez que não há melhoria no desempenho do código que seria obtido ao se implementar os loops sem o uso do funcional loop(). Nesse exemplo, toda vez que chamamos loop(), o que internamente está sendo feito é um loop utilizando a estrutura de repetição for. A melhor forma, em R, de se fazer uso de funcionais é considerar os que já estão implementados de forma consistente, utilizando linguagens mais eficientes, como, por exemplo, os funcionais de R escritos em C/C++ ou Fortran (códigos mais antigos) e que estão disponíveis no R base ou em pacotes suplementares. Fazer uso desses funcionais nos trará o benefício de escrever estruturas de repetições sem a necessidade de implementar essa estrutura toda vez que necessitarmos, além do benefício de substituir uma estrutura de repetição de R, que naturalmente são lentas, por funcionais que são muito mais eficientes. “Para se tornar significativamente mais confiável, o código deve se tornar mais transparente. Em particular, condições aninhadas e loops devem ser vistos com grande suspeita. Fluxos de controle complicados confundem os programadores. O código bagunçado geralmente esconde bugs.” — Bjarne Stroustrup, criador da linguagem de programação C++. 5.3.1 Funcionais do R Base O pacote base da linguagem R (algumas vezes chamo de R Base) possui alguns funcionais que podem ser bastante úteis em diversas situações. Tentar evitar escrever estruturas de repetições por meio do uso de funcionais é uma prática útil e algo bastante comum em linguagens de programação com paradigma funcional e em linguagens multiparadigmas, como é o caso da linguagem R. Observação: Poderá existir diversas situações que não poderemos escapar do uso de estruturas de repetições, no caso do R, das estruturas for, while e repeat. Porém, existem diversas outras situações que aquilo que encontra-se dentro do loop é uma estrutura bem definida que poderá ser envolvida em uma função e repetida por um funcional. Dessa forma, sempre procure checar se você poderá envolver em uma função o conteúdo que seria colocado no interior de uma estrutura de repetição. Passar esse conteúdo como uma função à um funcional poderá trazer benefícios ao seu código. 5.3.1.1 apply Trata-se de um funcional bastante conhecido em R, implementado no R Base. O funcional apply() é normalmente utilizado quando desejamos aplicar uma função em uma das dimensões de uma matriz. 5.3.1.2 sapply 5.3.1.3 lapply 5.3.1.4 vapply 5.3.1.5 mapply 5.3.1.6 Map 5.3.2 Funcionais do pacote purrr 5.4 Sistema S3 "]
]
