[
["index.html", "ESTATÍSTICA COMPUTACIONAL Disciplina ministrada à alunos do bacharelado em estatística da UFPB Início", " ESTATÍSTICA COMPUTACIONAL Disciplina ministrada à alunos do bacharelado em estatística da UFPB Docente: Prof. Dr. Pedro Rafael Diniz Marinho E-mail: pedro.rafael.marinho@gmail.com / pedro@de.ufpb.br Início Última atualização: 24/08/2019 Departamento de Estatística (UFPB): http://www.de.ufpb.br/ Licença O material Estatística Computacional do Prof. Pedro Rafael. D. Marinho está licenciado com uma Licença Creative Commons - Atribuição-NãoComercial-CompartilhaIgual 4.0 Internacional. Isso quer dizer: Você tem o dirieto de copiar e redistribuir o material em qualquer suporte ou formato; Você tem o direito de remixar, transformar e criar a partir deste material; Você deve dar crédito apropriado, fornecer um link para a licença e indicar se foram feitas alterações. Você pode fazê-lo de qualquer maneira razoável, mas de nenhuma maneira que sugira que o licenciador endossa você ou seu uso; Você não poderá utilizar o material para fins comerciais; Se você remixar, transformar, ou criar a partir do material, tem de distribuir as suas contribuições sob a mesma licença que o original. Sendo assim, não poderá aplicar termos jurídicos ou medidas de caráter tecnológico que restrinjam legalmente outros de fazerem algo que a licença permita. Maiores detalhes a respeito da licença em: https://creativecommons.org/licenses/by-nc-sa/4.0/. Observação: Os códigos que estão presentes nesse material estão sobre os termos GNU General Public License (\\(\\geq 3\\), versão três ou superior). Assim, o leitor poderá fazer uso de qualquer código desse material em seus projetos, pacotes, desde que cite a fonte. Além disso, todas as imagens utilizadas nesse material são de uso livre e não comercial. Na barra superior desse material você poderá encontrar um ícone para download das minhas aulas de R. Trata-se de um Portable Document Format (PDF) que contém minhas aulas de R. O material das aulas está sujeito a mesma licença desse material. Você é livre para utilizar e remixar, desde que referencie o autor e o Departamento de Estatística da UFPB. Além disso, você deverá deixar claro quais foram as modificações realizadas. Importante: Esse material está sob constante aprimoramento e sugestões poderão ser enviadas para o repositório do GitHub que hospeda este conteúdo. Uma vez que o material está sendo mantido e versionado no GitHub, as alterações podem ser realizadas diretamente no arquivo fonte do projeto, bastando clicar no ícone em formato de um lápis, no canto superior esquerdo desta página, ou das páginas em que se desejam sugerir alterações, como correções de palavras, mudanças de parágrafos, alteração de códigos, melhoramento de exemplos, inclusão de novos exemplos, etc. As alterações serão bem vindas e serão acatadas (incorporadas ao arquivo orignal) na medida que forem julgadas como sendo convenientes. Nota: Para que seja possível propor alterações é necessário que você saiba utilizar o git/GitHub e tenha realizado um fork do trabalho em sua conta do GitHub. Apreder a utilizar o git/GitHub poderá ser muito útil (dentro da academia ou fora dela), uma vez que você saberá versionar seus códigos, artigos e trabalhos em geral. "],
["prefacio.html", "Prefácio Tecnologias abordadas no curso Teorias abordadas no curso Sugestões de passos para revisão da linguagem R", " Prefácio Esse material sempre tentará se adequar à ementa da disciplina de Estatística Computacional, sendo esta uma disciplina obrigatória do curso de bacharelado em estatística do Departamento de Estatística da UFPB. Dessa forma, trata-se de um material destinado à alunos do Departamento de Estatística da UFPB. Porém, esse material poderá vir a despertar interesse à outras pessoas que não alunos da instituição. A ementa do curso de Estatística Computacional, que compõe a estrutura do curso como disciplina obrigatória, poderá ser obtida no link. Como pode-se observar, a disciplina é dividida no uso de tecnologias (linguagem de marcação e linguagem de programação) e alguns aspectos teóricos que envolvem a teoria de estatística computacional. O bom uso dos conceitos abordados no curso estará alinhado ao perfeito entendimento das tecnologias e teorias apresentadas. Importante: O tópico referente à tipografia científica em LaTeX não será abordado, visto que esse assunto atualmente está sendo apresentado na disciplina de Metodologia do Trabalho Científico, no início do curso de bacharelado em estatística da UFPB. Além disso, o tópico referente à programação em R abordará aspectos mais avançados da linguagem, uma vez que a essa altura do curso, os alunos entendem os conceitos básicos da linguagem R. Para quem deseja revisar a linguagem R, estou disponibilizando as aulas do meu curso introdutório de programação em R. As aulas estão divididas em dois arquivos. Curso de programação em R: Acesse o primeiro arquivo clicando aqui; Acesse o segundo arquivo clicando aqui. O curso introdutório de programação em R é dividido em dois arquivos, mas você poderá optar em baixar um único arquivo PDF clicando no ícone na barra superior desse material. Note que o Curso de Estatística Computacional não é o material adequado para você, caso o seu enteresse seja aprender a linguagem de programação R. Em um futuro próximo, quando este material estiver concluído e caso você já considere um usuário avançado de R, talvez pular para os assuntos referentes aos aspectos teóricos de estatística computacional venha ser o caminho mais produtivo para o seu aprendizado. Tecnologias abordadas no curso Uso de git e GitHub para versionamento de projetos; Linguagem de marcação: LaTeX; R Markdown; Linguagem de programação R sob um olhar mais avançado: Orientação à objeto utilizando funções genéricas (sistema S3 de orientação à objeto); Sistema R6 de orientação à objeto; Expressões regulares (regex); Uso de funcionais. Nessa parte será revisado os funcionais do base r bem como serão apresentados novos funcionais; Construção de pacotes em R; Uso de pacotes que incorporam características novas à linguagem R, entre eles, alguns dos pacotes da comunidade do RStudio; Closures; Checando a peformance do código e identificando gargalos; Conceitos de metaprogramação; Paralelismo em R (OpenMP). Em substituição ao item 2, trataremos do rmardkown, em especial, do uso do pacote bookdown para a construção de relatórios e livros dinâmicos utilizando a linguagem de marcação markdown. Por exemplo, esse material foi construído utilizando essas ferramentas. Nota: Um bom material em língua portuguesa sobre o LaTeX poderá ser obtido no aqui. Trata-se do curso intitulado Breve Introdução ao LaTeX2\\(\\varepsilon\\), do Prof. Lenimar Nunes de Andrade do Departamento de Matemática da UFPB. Para começar a estudar o LaTeX, você precisará instalar em seu computador um compilador do código de LaTeX e um editor para seus textos escritos utilizando a linguagem de marcação LaTeX. Abaixo listo os programas que você deverá instalar em seu computador para poder iniciar o estudo do material de LaTeX. TeX Live: Trata-se de uma distribuição do TeX padrão para a maior parter dos sistemas *nix (derivados de Unix, incluindo o Linux e macOS). O TeX Live também está disponível para o sistema operacional Windows. Clique aqui para baixar o arquivo de instalação. No processo de instalação você precisará estar conectado à internet, uma vez que o instalador precisará baixar diversos arquivos nos espelhos de distribuição do TeX Live. Uma das vantagens TeX Live é a sua velocidade na compilação de um arquivo com extensão .tex. TeXstudio: O TeXstudio é um editor de texto para o sistema LaTeX. Um outro bom editor que você poderá considerá para utilizar em seus estudos é o Texmaker, que assim como o TeXstudio, está disponível para os sistemas operacionais Linux, macOS e Windows. Teorias abordadas no curso Geração de números pseudo-aleatórios: Método da inversão; Método da aceitação-rejeição; Método da transformação. Métodos de Monte Carlo; Métodos de reamostragem: Jackknife; Bootstrap: estimação de erro-padrão, correção de viés, construção de intervalos aleatórios, testes de hipóteses, bootstrap de Wu (bootstrap selvagem). Algumas dessas metodologias serão apresentadas em esquemas simples (um nível de bootstrap) e duplo (dois níveis de bootstrap). Métodos de otimização não-linear em estatística: métodos de Newton e quasi-Newton. Sugestões de passos para revisão da linguagem R É aconselhado que antes de prosseguir nesse material o leitor faça uma revisão básica da linguagem R. Entre os princiapis conceitos necessários para uma boa progressão nesse curso, destacam-se: Entender as diferenças do funcionamento de um compilador para um interpretador. Lembre-se, R é uma linguagem interpretada; Revise os principais tipo de dados: character, double, integer e logical. Lembre-se que por regra de coerção, os tipos mais flexíveis em R seguem a seguinte regra de flexibilidade: character &gt; double &gt; integer &gt; lógico. Isso quer dizer, por exemplo, que se a é um vetor que possui elementos do tipo character e double, então todos os elementos do vetor serão coagidos para o tipo mais flexível, que nesse caso é o tipo character. Exemplo: a &lt;- c(1, letters[1:5]); is.character(a[1]) retornará TRUE. Lembre-se que R “não possui” constantes. Constantes são tratadas como vetores atômicos de comprimento 1. Esses são chamados de atômicos por serem a estrutura básica da linguagem, uma vez que R é uma linguagem vetorial. Além disso, lembres-se que listas também são vetores, porém, não-atômicos. Veja que, por exemplo, is.vector(list(1)) retornará TRUE. Por falar em vetores atômicos, chamaremos simplesmente de vetores, revise as principais estruturas de dados em R: vetores (c()), fatores (factor()), listas (list()), matrizes (matrix()), sequência de matrizes (arrays()) e tabelas (data.frames()). Note que uma matriz é um array de comprimento 1. Não confunda estrutura de dados com tipo de dados. Estruturas de dados refere-se ao mecanismo de organização de dados, já o tipo de dados refere-se ao tipo básico das informações que são organizadas nessas estruturas; Entenda o uso das funções is.troque() e as.troque(), em que troque poderá ser ser substituido por: Um Estrutura de dados: vector, factor, list, numeric, data.frame, matrix, array, etc. Um Tipos de dados: integer, double, numeric, character, logical, etc. Revise os operadores relacionais e lógicos: Operadores Relacionais: ==(igual), &lt; (menor), &lt;= (menor ou igual), &gt; (maior), &gt;= (maior ou igual), != (diferente); Operadores Lógicos: || (OU lógico), &amp;&amp; (E lógico), ! (NÃO lógico). Esses são operadores não vetorizados. Os operadores | e &amp; são as versões vetorizadas dos operadores || e &amp;&amp;, ou seja, por exemplo, c(2,3) &lt; c(1,1)) | (c(2,1) &gt;= c(2,3)) retornará o vetor c(TRUE, FALSE) e (c(2,3) &lt; c(1,4)) | (c(2,1) &gt;= c(2,3)) retornará c(TRUE, TRUE), respectivamente. Perceba que utilizar o operador | OU lógico é realizado sobre a ordem das posições dos elementos nos vetores; Revise as estruturas de condições: if, else, switch e ifelse. A função ifelse() equivale à estrutura (condição) ? retorno 1 : retorno 2 das linguagens C/C++; Revise as estruturas de repetições: while, for e repeat. Entenda o uso das instruções break e next quando utilizadas dentro dessas estruturas. Revise a definição de funções. Tente entender a flexibilidade embutida em funções que retornam uma lista. Isso se deve ao fato de uma lista ser uma estrutura heterogênea que poderá retornar qualquer estrutura de dados, incluindo outra(s) lista(s). Isso é interessante, uma vez que normalmente desejamos que uma função retorne mais de um objeto, sendo estes objetos quaisques, podendo ter as mais variadas estruturas e tipos de dados. Se achar necessário, revise algumas funções úteis: ls(), rm(), length(), sum(), abs(), mean(), median(), var(), sd(), cor(), summary(), sqrt(), exp(), expm1() (fornece uma boa proximação para exp(x) - 1, quando x é pequeno), log(), log10(), log1p() (fornece uma boa aproximação para log(x+1) quando x é pequeno), round(), union(), intersect(), choose(), factorial(), dim(), ncol(), nrow(), diag(), %*%, t(), solve(), det(), eigen(), print(), cat(), paste(), paste0(), substring(),str(), sort(), quantile(), match() e %in%. Lembre-se que quando os operadores +, -, *, /, %% (módulo / resto da divisão) e ^ são aplicados entre matrizes, ou entre matrizes e vetores de comprimento 1 (“constantes”), as operações serão realizadas elemento à elemento. Diversas outras características da linguagem R são importantes e serão lembradas, aos poucos, na medida que for necessário. Ficará a cargo do leitor fazer as sugestões de revisões acima. O capítulo que inicia esse material é dedicado à apresentação de exercício que o leitor deverá resolver. Trata-se de um capítulo em que os exercícios envolvem as sugestões de revisão da linguagem R apresentadas acima. Os exercícios para serem resolvidos poderão exigir revisões de outros conceitos que não foram listados na proposta de revisão acima. No entanto, se esses exercícios forem bem resolvidos, utilizando-se de boas práticas de programação em R, a leitura desse material será a mais agradável possível. Considere as aulas de R disponibilizadas como um ponto de apoio. "],
["revisao-basica-da-linguagem-r.html", "1 Revisão básica da linguagem R Exercícios propostos", " 1 Revisão básica da linguagem R Mesmo que você se considere um programador razoável de R, aconselho que venha resolver a lista de exercícios apresentada adiante. É comum que venhamos esquecer de alguns conceitos de linguagens em que programamos. Esses exercícios é uma oportunidade que você irá ter de revisar lógica de programação utilizando a linguagem R e consequentemente revisar alguns conceitos importantes, porém básicos, da linguagem. Tente resolver esses exercícos após um olhar detalhado das sugestões apresentadas. A lista de assuntos para revisão sugerem temas bastante simples para quem já programa um pouco na linguagem R. Tais sugestões aliadas com as resoluções desses exercício irão lapidar os conhecimentos necessários e fará com que você necessariamente revise outros assuntos inseridos nos exercícios. Estes assuntos/exercícios também são simples e não envolverão conceitos avançados da linguagem R. Conceitos mais avançados serão abordados no decorrer do curso de Estatística Computacional e exercícios estarão disponíveis no decorrer de outros capítulos, à medida que forem necessários. Observação: A google disponibilizou um guia de estilo de programação em R. Trata-se de um guia de boas práticas de programação, no que diz respeito à escrita do código. Esse guia não trata de boas práticas de programação para a obtenção de melhorias de desempenho da linuguagem R. Você não é obrigado adotar essas normas. Porém, segui-las tornará o seu código mais legível. Exercícios propostos Descreva o funcionamento e as diferenças de um compilador para um interpretador. Liste exemplos de linguagens de programação compiladas e interpretadas. Responda os itens abaixo: Descreva os principais tipos de dados da linguagem R. Descreva as principais estruturas de dados da linguagem R. Disserte sobre as diferenças entre tipos de dados e estruturas de dados. Descreva quais estruturas de dados são homogêneas e quais estruturas são heterogêneas. Explique o por quê das saídas abaixo: x &lt;- c(7.1, 2.3, 3L, TRUE) x ## [1] 7.1 2.3 3.0 1.0 y &lt;- c(TRUE, letters[1:3]) y ## [1] &quot;TRUE&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; z &lt;- c(1.0, 5, 7, 0L) z ## [1] 1 5 7 0 Sem utilizar o R, o que você espera como retorno de x &lt;- c(1, c(2, c(3, 4))); x. Qual a estrutura de dados de x? Irá ocorrer erro ao tentar criar um vetor atômico (vetor) com objetos de tipos diferentes? Como o interpretador de R trata essas situações. Explique detalhadamente. O que signicica NA, NaN, Inf e -Inf, em R? Liste algumas das situações em que utilizando-se das operações básicas +, -, * e / poderemos ter NaN como retorno. Considere vetor &lt;- c(2, 7, 10, 8). Qual o tipo de dados do objeto vetor? Crie os objetos vetor_int, vetor_character e vetor_logical. Dica: crie esses objetos utilizando funções para conversão dos tripos dos elementos do objeto vetor. O que faz o código abaixo? Explique detalhadamente o que cada função faz. objects(grep(&quot;bas&quot;, search())) Qual o retorno do código abaixo? Explique detalhadamente o código. search()[(grep(&quot;gr&quot;, search()))] Forneça o código que acessa o caracter \"a\" de l, em que l &lt;- c(list(c(3, 2), \"a\"), c(1,2)). Depois, converta l em um vetor atômico. Sem executar os códigos abaixo, descreva as saídas esperadas: Qual a saída esperada para os códigos c(1, FALSE), c(\"a\", 1), c(list(1), \"a\"), c(TRUE, 1L)? Por que 1 == \"1\" retornará TRUE? Explique. Por que -1 &lt; FALSE retornará TRUE? Explique. Considere o objeto vetor &lt;- 1:25. Com o objeto vetor, construa uma matriz de ordem 5x5 usando a função matrix() e depois utilizando a função dim(). Crie a matriz M, de ordem 50x50, com elementos de 1 à 2500 preenchidos por linha. Atribua nomes às linhas (l_1 à l_50) e colunas (c_1 à c_50) de M. Dica: certamente você percebeu que não será nada interessante digitar os nomes das linhas e colunas de M. Tente utilizar as funções paste() e rep()como soluções para esse problema. Remova os nomes das linhas e colunas da matriz M criada no exercício anterior. Sejam V1 &lt;- matrix(1:12, ncol = 4, nrow = 3) e W1 &lt;- matrix(1:8, ncol = 4, nrow = 2). Crie a matriz M1que é o resultado da concatenação, por linha, de V1 e W1. Considere os objetos V2 &lt;- matrix(1:12, ncol = 2, nrow = 4) e W2 &lt;- matrix(1:12, ncol = 3, nrow = 4). Cria a matriz M2como resultados da concatenação, por coluna, de V2 e W2. Considere obj &lt;- list(1:3, \"a\" , TRUE, 1.0). Construa uma matriz de ordem 2x2 a partir de obj. O que de interessante você observa? Construa a matriz A (matriz de avaliações), de ordem 30x2, em que a primeira coluna são os nomes dos alunos (Aluno_1 à Aluno_30) e a segunda coluna são as notas de 3 avaliações, por aluno. Dica: para facilitar, gere as avaliações dos alunos de forma aleatória. O que a função dim() retorna quando aplicada à um vetor? Se is.matrix(x) retorna TRUE, o que irá retornar de is.array(x)? Explique. Descreva os objetos objetos x1, x2 e x3 construídos na forma apresentada abaixo: x1 &lt;- array(1:5, c(1, 1, 5)) x2 &lt;- array(1:5, c(1, 5, 1)) x3 &lt;- array(1:5, c(5, 1, 1)) Considere o código apresentado abaixo: df &lt;- data.frame(x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df$y ## [1] a b c ## Levels: a b c Qual a estrutura de dados de df$y? Como poderemos alterar o comportamento do data frame df para que df$y retorne um vetor atômico com elementos do tipo character? Ao tentar criar um data frame com o código abaixo obteremos um erro. Corrija o código: data.frame(x = 1:3, y = list(1:2, 1:3, 1:4)) ## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 2, 3, 4 Considere a lista abaixo: notas &lt;- list(c(7.1, 3.2, NA), c(2.7, 8.8, 10.0), c(0.0, NA, NA), c(7.7, 8.4, 6.3), c(3.6, 6.6, 8.1), c(NA, NA, NA), c(7.4, 7.1, 7.3), c(10.0, NA, 7.0), c(1.6, 3.2, 5.3), c(8.8, 9.2, 8.0)) Responta os itens abaixo: Atribua nomes (Aluno_1 à Aluno_10) à cada elemento de notas. Crie o vetor status contendo o status dos dez alunos. Considere: A (aprovado), REP (reprovado), F (final). Dica: construa o vetor status atribuindo literalmente as categorias A, REP ou F para cada aluno, ou seja, não é preciso criar uma função para fazer isso automaticamente. Considere A para os alunos com média no intervalo \\([7, 10]\\), R para os alunos com média no intervalo \\([0, 4)\\) e F para os alunos com média no intervalo \\([4, 7)\\). Crie o vetor alunos com os nomes dos alunos. Obtenha esse vetor por meio do objeto notas. Construa o data frame historico com as variáveis nomes, notas e status. Com base no data frame historico, construa o data frame aprovados com os alunos aprovados. De forma análoga, construa um data frame para cada um dos demais status, respectivamente. Suponha que o professor está interessado em saber quais alunos foram ou tem alguma chance de assumir o status de aprovado. Construa o data frame bons_alunos com estes alunos. Modifique os nomes das linhas do data frame historico colocando id_1 na primeira linha e respectivamente, no mesmo padrão, para as demais linhas. Obtenha por meio do data frame historico um novo data frame (historico_na) com os alunos que deixaram ao menos uma prova para repor. Apenas para os alunos que fizeram as três avaliações, obtenha a média aritmética das avaliações. Acrescente a variável de nome media como última coluna do data frame historico. Consideremos o conjunto de dados state.x77 do pacote datasets (pacote padrão de R). A base state.x77 refere-se à um objeto de ordem 50x8, em que cada linha refere-se à um dos 50 estados dos EUA. Consulte a documentação (help(state.x77)) para obter maiores informações. Responda os itens abaixo: Qual a estrutura de dados do objeto state.x77? Construa o data frame dados utilizando state.x77. Obtenha o data frame de nome dados_1 com os estados estadunidenses que possuem população maior que 4246 (quatro milhões duzentos e quarenta e seis mil). Obtenha o data frame dados_2 com os estatdos estadunidenses que possuem população maior que 4246 e menor que 8 milhões, isto é, menor que 8000. Obtenha o vetor vetor_est com os nomes dos estados que obedecem os critérios do item 3. Construa o data frame dados_3 com os estados estadunidenses que possuem população maior que 1.5 vezes a média dos 50 estados considerados. Obtenha um vetor com o nome dos estados que obedecem essa restrição. Construa o data frame dados_4 com os estados estadunidenses que possuem população maior que duas vezes a mediana dos 50 estados e que tenha uma população com expectativa de vida maior que 71.84 anos. Obtenha o data frame dados_5 com os estados estadunidenses cuja população possuem renda maior que a média nacional e expectativa de vida maior que 72 anos. Adicione ao data frame dados duas linhas com as médias e variâncias de todas as variáveis, respectivamente. Escreva um programa que retorne a saída baixo: i1 = 1 i2 = 2 i3 = 3 i4 = 4 i5 = 5 i6 = 6 i7 = 7 Dica: Resolva esse simples exercício de três formas diferentes (usando while, for e repeat). Escreva uma função que retorne o imposto pago por mulheres e por homens, sabendo que as mulheres pagam \\(10\\%\\) e que os homens pagam \\(5\\%\\) a mais do que as mulheres. Resolva o exercício anterior utilizando a função switch(). Implemente a função tab(num, inicio, fim) que é responsável por escrever no prompt de commando a tabuada de um número passado como argumento à num. Nota: os argumentos inicio e fim referem-se ao início e fim da tabuada, ou seja, tab(num = 1, inicio = 7, fim = 12) deverá escrever no prompt: 1 x 7 = 7 1 x 8 = 8 1 x 9 = 9 1 x 10 = 10 1 x 11 = 11 1 x 12 = 12 Implemente tab() utilizando as diferentes escruturas de repetição da linguagem R (for, while e repeat). Escreva a função celtofar() que converte um vetor de temperaturas em graus Celsius para graus Fahrenheit. Considere: \\[F = 1.8 \\times C + 32,\\] em que \\(C\\) é a temperatura em graus Celsius e \\(F\\) é a temperatura em graus Fahrenheit. Melhore a função celtofar() para que critique valores não válidos de temperaturas. Modifique a função celtofar() para que funcione também para conversões no sentido oposto, isto é, para que converta de graus Fahrenheit para graus Celsius. Construa a função imc() que calcula o IMC (Índice de Massa Corporal) de uma pessoa. A função deverá retornar o IMC e um status. Observe que: \\[\\mathrm{IMC} = \\frac{\\mathrm{peso}}{\\mathrm{altura}^2},\\] em que \\(\\mathrm{peso}\\) é dado em \\(kg\\) e a \\(\\mathrm{altura}\\) é fornecida em \\(cm\\). Alem disso, considere: IMC Status \\(&lt; 17.0\\) Muito abaixo do peso \\([17.0, 18.5)\\) Abaixo do peso \\([18.5, 25.0)\\) Peso normal \\([25.0, 30.0)\\) Acima do peso \\([30.0, 35.0)\\) Obesidade nível I \\([35.0, 40.0)\\) Obesidade nível II (severa) \\(\\geq 40.0\\) Obesidade nível III (mórbida) Dica: Uma função robusta deverá tratar problema(s) com a(s) entrada(s), isto é, deverá criticar informações inconsistentes passadas como argumento. Utilizando a instrução de repetição for construa um pequeno programa que com base em um vetor de valores no intervalo \\([0, 1]\\), some apenas os valores maiores que 0.7. Dica: para economizar tempo, considere vetor &lt;- runif(n = 1e5, min = 0, max = 1). Resolva o exercício anterior sem utilizar nenhuma instrução de repetição. Avalie o custo computacional dos exercícios anteriores (exercícios 34 e 35) utilizando a função Sys.time(). Discuta o resultado. Construa a função central(x) que recebe como argumeto um vetor passado à x e retorna algumas medidas de tendência central. A função central() deverá retornar: Média aritmética (média amostral): \\(\\overline{x} = n^{-1}\\sum_{i = 1}^n x_i.\\) Média geométrica: \\(G = (\\prod_{i=1}^n x_i)^{\\frac{1}{n}}.\\) Média harmônica: \\(H = \\frac{n}{\\frac{1}{x_1} + \\cdots + \\frac{1}{x_n}}.\\) Algumas exigências a respeito do funcionamento da função central() encontram-se enumeradas abaixo: 1 - A função deverá retornar todas as três medidas de tendência central ou apenas uma das estatísticas, a depender do interesse do usuário. 2 - Observações Not Availables NA serão eleminadas do cálculo. Porém, uma mensagem de aviso ao usuário da função deverá ser emitida informando-o a repseito do número de observações eliminadas e em quais posições encontravam-se estas observações. 3 - A função deverá alertar o usuário se uma estrutura/tipo de dados não suportado por central() for passado como argumento à x. A função deverá alertar qual estrutura/tipo de dados foi passado, avinsando assim que essa estrutura/tipo de dados não poderá vir a ser processado(a). Nota: Não utilize a vetorização da linguagem R. Nesse exercício desejamos treinar o uso das estruturas de repetições da linguagem. Não utilizar vetorização da linguagem quer dizer que você não poderá aplicar uma função à todos elementos de um vetor. Por exemplo, se x é um vetor, você não poderá fazer x^2, sqrt(x), mean(x), length(), etc. Aplique a função a cada posição do vetor utilizando estruturas de repetições. Em seus projetos reais, utilize a capacidade de vetorização da linguagem e evite o quanto der as estruturas de repetições. Isso fará com que os seus códigos sejam mais eficientes. Aqui apenas queremos exercitar o uso das estruturas de repetições. Além disso, central() poderá ter outros argumentos além de x. Sem utilizar a capacidade de vetorização da linguagem R, nas formas do exercício anterior, implemente a função myvar(x) que retorna a variância amostral de um vetor passado como argumetno à x. Algumas exigências a respeito do funcionamento da função myvar() encontram-se enumeradas abaixo: 1 - A função deverá retornar todas as três medidas de dispersão ou apenas uma das estatísticas, a depender do interesse do usuário. 2 - Observações Not Availables NA serão eleminadas do cálculo. Porém, uma mensagem de aviso ao usuário deverá ser passada informando o número de observações eliminadas e em quais posições encontravam-se. 3 - A função deverá alertar o usuário se uma estrutura ou tipo de dados não coerente com o interesse da função for passado como argumento à x. Nota: Não utilize a vetorização da linguagem R. Nesse exercício desejamos treinar o uso das estruturas de repetições da linguagem. Não utilizar vetorização da linguagem quer dizer que você não poderá aplicar uma função à todos elementos de um vetor. Por exemplo, se x é um vetor, você não poderá fazer x^2, sqrt(x), mean(x), length(), etc. Aplique a função a cada posição do vetor utilizando estruturas de repetições. Em seus projetos reais, utilize a capacidade de vetorização da linguagem e evite o quanto der as estruturas de repetições. Isso fará com que os seus códigos sejam mais eficientes. Aqui apenas queremos exercitar o uso das estruturas de repetições. Além disso, myvar() poderá ter outros argumentos além de x. Se x, na função myvar(), for um vetor não numérico? E se x for um vetor de caracteres numéricos? E se x for uma string numérica como \"1,2,3\" que desejamos tratar como sendo o c(1, 2, 3)? Modifique a função myvar() para que venham tratar/considerar essas situações. Implemente a função disp(x) que deverá retornar uma das medidas de dispersão listadas logo abaixo: Amplitude: \\(A = x_{\\mathrm{max}} - x_{\\mathrm{min}}.\\) Variância amostral: \\(S^2 = \\frac{\\sum_{i=1}^{n}(x_i - \\overline{x})^2}{n-1}.\\) Desvio padrão amostral: \\(S = \\sqrt{S^2}.\\) Coeficiente de variação: \\(CV = \\frac{100 \\times S}{\\overline{x}}.\\) Algumas exigências a respeito do funcionamento da função disp() encontram-se enumeradas abaixo: 1 - A função deverá retornar todas as quatro estatísticas ou apenas uma das estatísticas, a depender do interesse do usuário. 2 - Observações Not Availables NA serão eleminadas do cálculo. Porém, uma mensagem de aviso ao usuário deverá ser passada informando o número de observações eliminadas e em quais posições encontravam-se. 3 - A função deverá alertar o usuário se uma estrutura ou tipo de dados não coerente com o interesse da função for passado como argumento à x. Nota: Não utilize a vetorização da linguagem. Nesse momento também desejamos treinar o uso das estruturas de repetições da linguagem. Implemente a função mycor(x, y, pearson = TRUE, rm.na = TRUE) que deverá receber como argumentos dois vetores passados para x e y, respectivamente. A função mycor() deverá retornar o coeficiente de correlação de Pearson se pearson = TRUE, caso contrário, retornará o coeficiente de correlação de Spearman. Além disso, se rm.na = TRUE, a função mycor() deverá eliminar os Not Availables NA dos respectivos vetores. Por exemplo, se x &lt;- c(1, 8, -1, NA, NA) e y &lt;- c(NA, 7, -2, 10, 5) forem passados para mycor(), esta deverá eliminará as duas últimas observações de x e y, bem como a primeira observação de x e y, resultando, nesse exemplo, em x &lt;- c(8, -1) e y &lt;- c(7, -2), respectivamente. A função deverá alertar a respeito das eliminações e informar quais as posições eliminadas dos vetores. Algumas outras exigências a respeito do funcionamento da função mycor() encontram-se enumeradas abaixo: 1 - A função deverá parar e alertar o usuário nas situações em que os vetores não tenham os mesmos comprimentos. 2 - A função deverá retornar dois objetos, rho e level, em que rho (\\(\\rho\\)) é o valor da correlação e level informa o nível dessa correlação. Os níveis possível a ser retornados são: desprezível se \\(\\rho \\in [0, 0.3)\\), fraca se \\(\\rho \\in [0.3, 0.5)\\), moderada se \\(\\rho \\in [0.5, 0.7)\\), forte se \\(\\rho \\in [0.7, 0.9)\\) e fortíssima se \\(\\rho \\in [0.9, 1]\\). Dica: A função warning() pode ser útil para emitir uma mensagem de aviso (alerta) ao usuário da função mycor(). Construa duas funções, tree1() e tree2(), que escrevam, no prompt de comando, as imagens abaixo, respectivamente. O programa deverá utilizar instruções de repetições para resolver o problema. A primeira função deverá imprimir: ********** ********* ******** ******* ****** ***** **** *** ** * A segunda função deverá imprimir: *-*-*-*-*- *-*-*-*-* *-*-*-*- *-*-*-* *-*-*- *-*-* *-*- *-* *- * Implemente as funções utilizando as estruturas de repetições for, while e repeat. Escreva a função tree3(), utilizando instruções de repetições, de modo a fornecer as seguintes estruturas, adepender do valor de n. Para \\(n = 1\\): * Para \\(n = 2\\): * ** Para \\(n = 3\\): * ** *** e assim por diante para outros valores de \\(n\\). Implemente tree3() utilizando as estruturas de repetições for, while e repeat. Melhore as funções tree1(), tree2() e tree3() de modo que estas possam considerar caracteres distintos e não somento o caracter asterisco. Modifique a função tree1(), de tal forma que a estrutura obtida seja: Para \\(n = 1\\): A Para \\(n = 2\\): A BB Para \\(n = 3\\): A BB CCC e assim por diante para outros valores de \\(n\\). Dica: Note que \\(n \\leq 26\\). Assim, retorne uma mensagem de advertência se um valor de \\(n\\) inapropriado for informado. Dica: utilize a função stop(). Implemente a função aprox_e() que retorna uma aproximação para \\(\\mathrm{e}^x\\), em que: \\[\\mathrm{e}^x = \\sum_{n = 0}^{\\infty} \\frac{x^n}{n!}.\\] Dica: A função aprox_e() deverá receber como argumento o número de somas a serem consideradas. Crie a função aprox_pi(), fazendo uso de instruções de repetição, que forneça uma aproximação para o valor da constante \\(\\pi\\). Essa aproximação deverá considerar: \\[\\pi = 4 - \\frac{4}{3} + \\frac{4}{5} - \\frac{4}{7} + \\frac{4}{9} - \\frac{4}{11} + \\dots\\] Dica: Premita que o usuário de sua função forneça a quantidade de termos a serem somados. Além disso, faça com que sua função critique valores indevidos para a quantidade de termos somados. Implemente a função fib(), utilizando instruções de repetição, que retorna o Fibonacci de um número. Lembre-se, a sequência de Fibonacci é dada por \\(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \\ldots\\) . Note que Fibonacci de \\(n\\) é dado por \\(F_n = F_{n-1} + F_{n-2},\\, n &gt; 2\\), com \\(F_1 = 1\\) e \\(F_2 = 1\\). Por exemplo, Fibonacci de 5 é dado por \\(F_5 = F_{4} + F_{3} = 3 + 2 = 5\\). Implemente o exercício anterior usando funções recursivas. Lembre-se: chamamos de funções recursivas as funçãos que chamam a si mesma. Um esboço de função recursiva: func_f &lt;- function(...){ # Ué? ... # Sim! Estamos chamando a função que estamos criando. ;) func_f(...) # Será preciso parar em algum momento # somos finitos :) if (contition) break } Implemente a função aprox_pi() de forma recursiva. Implemente a função nachange(df), em que df recebe um data frame/matriz. A função nachange() deverá trocar NA pelo character “?”. Dica: Em caso de df não possuir nenhum elemento NA, a função nachange() deverá retornar o objeto passado à df. Construa a função searchindf(df, value), em que df é um data frame/matriz e value é um vetor de uma única posição. A função searchindf()deverá retorna TRUE se o valor passado para value é encontrado em alguma posição do data frame/matriz passado(a) para df e FALSE caso contrário. Dica: tente construir a função da forma mais robusta possível. Por exemplo, considere criticar os argumentos, caso estes não tenham a estrutura de dados adequada ao objetivo da função. Construa a função namecolsort(df), em que df receberá como argumento um(a) data frame/matriz. A função namecolsort() deverá retorna o(a) data frame/matriz com as colunas ordenadas. Dica: ordene as colunas considerando o primeiro caracter que compõe o nome da coluna (variável). Escreva a função exclusive(df), em que df receberá como argumento um(a) data frame/matriz. A função exclusive() deverá retornar a posição das linhas exclusivas, ou seja, as linhas que não possuem elementos repetidos. Escreva uma função extremeindex(df, max = NULL), em que df receberá como primeiro argumento um(a) data frame/matriz. A função maxindex() deverá retornar a posição (linha, coluna) do valor máximo contido no objeto passado para df, caso max = TRUE. Em caso de max = FALSE, a função maxindex() deverá retornar a posição (linha, coluna) do valor mínimo contido no objeto passado à df. Para o caso de max = NULL (caso padrão), a função maxindex() deverá retornar uma matriz de ordem 2x2, em que cada linha deverá retornar a posição do elemento mínimo e máximo, respectivamente, contidos no objeto passado à df. Implemente a função myt(df), em que dfrecebe como argumento um(a) data frame/matriz. A função myt() deverá “girar”, em 90 graus, a(o) matriz/data frame passado à df. Dica: não utilize a função t() para transpor a matriz. Crie a função anagram(x, y) que recebe dois argumentos (duas strings). A função anagram() deverá retornar TRUE se uma palavra (string) é anagrama da outra e FALSE em situação contrária. A função deverá considerar que ambas as strings possuem a mesma quantidade de caracteres. Caso a quantidade de caracteres não seja igual, em ambas as strings, a função deverá parar e advertir o usuário. Dica: você poderá utilizar a função strsplit(). Implemente a função strposition(x), em que dado uma palavra (string) fromada por letras do alfabeto Romano e passada como argumento para x, retorna a posição das letras em um vetor. Por exemplo, a string (palavra) cada passada para a função fará com que strposition() retorne o vetor formados pelos elementos 3, 1, 4 e 1. Dica: a função não poderá aceitar strings que são formadas por pelo menos um caracter que não seja uma letra do alfabeto Romano. Altere a função strposition(x) para que em situação da string (palavra) possuir um ou mais caracteres não pertencentes ao alfabeto Romano, o retono seja NA, nas respectivas posições destes caracteres. "],
["o-evangelho-do-gnulinux.html", "2 O Evangelho do GNU/Linux 2.1 Um breve histórico 2.2 Vantagens em utilizar GNU/Linux 2.3 Algumas distribuições", " 2 O Evangelho do GNU/Linux Nesse capítulo tentarei convencê-lo, sem imposições, que o uso de alguma distribuição GNU/Linux poderá ser um caminho coerente e que trará facilidades para quem deseja um sistema operacional flexível, fácil de manter e livre. Tentarei aqui expressar minhas experiências no uso do linux, de uma forma geral, e na estatística. Ao final, listarei algumas distribuições GNU/Linux que considero interessantes. Observação: Você é livre para escolher o sistema operacional (SO) que deseja trabalhar. Porém, em situações em que seja necessário dissertar sobre alguma configuração específica do sistema (não serão muitas), as explicações apresentadas levarão em consideração, na maioria dos casos, sistemas GNU/Linux. Se você for meu aluno, tentarei esforçar-me um pouco mais. 2.1 Um breve histórico Em meados de 1970, o Unix foi (ainda é) um dos sistemas operacionais mais amplamente utilizados em mainframes devido à sua ampla confiabilidade, distribuição e suporte. Muitos desses sistemas Unix tratavam-se de sistemas proprietários. Entre os sistemas Unix mais populares e livres estava o Berkley Software Distribution (BSD) cujo desenvolvimento (1977 a 1995) era realizado pela Computer Systems Research Group (CSRG), vinculado à Universidade da Califórnia, em Berkely. Nota: Nos dias de hoje, o termo BSD é utilizado para designar qualquer sistema operacional do tipo Unix (sistemas Unix-like). Muitas vezes o termo Unix-like é substituído por UN*X ou *nix. Tratam-se de sistemas operacionais baseados em Unix, mas que não necessariamente estão de acordo com a especificação Single UNIX. O sistema Linux (kernel) foi baseado no Unix, sendo este o sistema Unix-like mais popular dentre diversos outros que são razoavelmente conhecidos pelo público em geral e bastante conhecidos por profissionais que tem alguma afinidade com a computação. A maioria dos sistemas BSD’s, disponíveis na atualidade, possuem o código fonte aberto, porém fazem o uso da licença BSD que é menos restritiva, permitindo, por exemplo, que apenas os arquivos binários sejam distribuídos. Trata-se de uma licença atraente para aplicativos embarcados, em que empresas não estão obrigadas a disponibilizar o código fonte das suas aplicações, quando estes forem solicitados. Devido a licença BSD ser menos restritivas que a licença GNU General Public License, utilizada pelo Linux, por diversos outros programas e bibliotecas de código aberto, alguns sistemas BSD’s conhecidos possuem código proprietário. No caso dos sistemas BSD’s proprietários, muito provavelmente se você solicitar os códigos às empresas que os construíram o seu pedido não será atendido. Entre os sistemas operacionais BSD’s de código fechado mais conhecidos, destacam-se dois: 1 - O sistema Solaris, em que nas suas primeiras versões era chamado de SunOS. Esse sistema BSD foi desenvolvido pela Sun Microsystems, que em 2009, foi adquirida pela Oracle Corporation. Detalhes a respeito do sistema Solaris podem ser encontrados no site da Oracle. 2 - O macOS, sistema operacional produzido pela empresa Apple. Muito provavelmente o macOS é um dos *nix mais conhecidos. Porém, o macOS está longe de ser o sistema *nix mais amplamente utilizados em supercomputadores. Saindo do território dos sistemas BSD’s proprietários, abaixo listo alguns dos mais conhecidos sistemas BSD’s, em que os códigos dos projetos são abertos, isto é, com iniciativas Open Source: 1 - FreeBSD: Trata-se de um sistema moderno, livre e que é bastante utilizado em servidores, desktops e plataformas embarcadas. O FreeBSD é talvez o sistema BSD, de código livre, que é mais amplamente utilizado entre os sistemas dessa lista. A melhor forma de acompanhar as novidades do FreeBSD é ler o FreeBSD Journal, um jornal livre dos desenvolvedores do FreeBSD. Seu mascote genérico é o BSD daemon, apelidado de Beastie. 2 - NetBSD: Trata-se de uma derivação do sistema 4.4BSD da Universidade da California, Berkley e do 386BSD, às vezes chamado de Jolix. Assim como o FreeBSD, o NetBSD é um sistema que pode rodar em diversas arquiteturas de computadores. O seu logo é uma bandeirola. 3 - OpenBSD: Trata-se de um projeto baseado no sistema 4.4BSD. O projeto OpenBSD desenvolveu aplicações como o OpenSSH que é a principal ferramenta de conectividade para login remoto utilizando o protocolo Secure Shell (SSH). O seu mascote é o Puffy. 4 - DragonFly BSD: Os seus desenvolvedores afirmam que trata-se de um sistema operacional pertencente à mesma classe de outros sistemas baseados em BSD e Linux, porém inclue recursos que o diferenciam de outros sistemas operacionais. Por exemplo, o DragonFly BSD possue o HAMMER, um moderno sistema de arquivos de alta peformance. O mascote do projeto é uma libélula. Observação: Linux é uma marca registrada de Linus Torvalds. Você poderá ver essa informação aqui. Além disso, Linux é um *nix, UN*X ou Unix-like (como queira chamar), mas Linux não é um BSD, nem um BSD é um Linux. Por exemplo, a biblioteca C do BSD é baseada nos códigos de Berkeley e não na GNU C Library. Dessa forma, diferentemente dos diversos sistemas BSD’s, o Linux utiliza-se de alguns recursos fornecidos pelo GNU C. O sistema operacional Linux foi inicialmente desenvolvido pelo engenheiro de software Linus Torvalds em 1991. Atualmente o Linux conta com diversos desenvolvedores espalhados pelo mundo, em que Linus Torvads é o principal desenvolvedor. Não é difícil adivinhar o porquê do nome Linux. Figura 2.1: Linus Torvalds em uma conferência para o TED intitulada A mente por trás do Linux, 2016. Nessa época, inícios dos anos 90, Linus Torvalds era discente na Universidade de Helsinque, Finlândia como estudante de ciência da computação. Sua dissertação de mestrado intitulada Linux: a Portable Operating System (56 páginas) foi defendida no Departamento de Ciência da Computação da Universidade de Helsinque, em 31 de janeiro de 1997. A dissertação introduz problemas de protabilidade do kernel Linux em diferentes arquiteturas de computadores. O autor comenta que quem acompanhou os primórdios do desenvolvimento do kernel Linux, o título de sua dissertação poderia soar como ironia, uma vez que o projeto original do Linux não estava realmente preocupado com a portabilidade do sistema em diversas arquiteturas de processadores. À época, a preocupação maior do projeto era com a execução do Linux em computadores com processadores Motorola 68k Amiga e Atari, ambos de 32 bits. Isso restringia o uso de Linux em algumas arquiteturas de PCs doméstricos da época. Segundo Torvalds, a implementação do Linux foi baseada em três questões principais. São elas: 1 - Simplicidade: Muito embora o kernel de um sistema operacional é algo complexo, e isso não é diferente no Linux, a implementação mais simples possível é um dos pilares do projeto. 2 - Eficiência: Uma vez que o kernel está envolvido com quase todas as atividades de uma máquina (PCs, mainframes, entre outros), a implementação do kernel Linux busca a eficiência, ou seja, o kernel nunca poderá ser visto como uma restrição de desempenho. 3 - Compatibilidade: O que está ocorrendo por baixo do kernel de um sistema operacional poderá ser de interesse para pesquisadores na área de sistemas operacionais. Dessa forma, um sistema operacional não poderá impor “surpresas” ao usuário comum ou mesmo à um programador. O Linux é um sistema operacional robusto e disponível para funcionar em diversas arquiteturas e sem “surpresas”. “Embora o projeto Linux tenha sido intimamente associado a mim pessoalmente, em parte devido ao nome, gostaria de deixar bem claro que o sistema operacional Linux é um grande projeto feito cooperativamente por muitas pessoas em todo o mundo. Mesmo se você desconsiderar todos os programas em nível de usuário que são parte integrante de qualquer sistema Linux, apenas o kernel contém código de centenas de pessoas ao redor do mundo. Obrigado a todos vocês.” — Linus Torvalds, Linux: a Portable Operating System, página 3. A todo momento, nessa nossa conversa, a expressão kernel foi utilizada junto com o termo Linux. Isso normalmente é feito para deixar claro que o Linux é um programa que gerencia os seus hardwares e o funcionamento dos programas que você utiliza no seu dia a dia, caso você esteja utilizando uma distribuição Linux, é claro. Porém, se você ainda não está utilizando o Linux nesse momento, saiba que o seu sistema operacional possui um kernel, sendo este a parte mais importante do sistema. Figura 2.2: Tux, logo desenvolvido pelo programador Larry Ewing e idealizado por Linus Torvalds como mascote do projeto Linux. Para que um sistema operacional venha ser utilizado pela maioria das pessoas, em que nesse grupo nos incluímos, este deverá conter diversos outros programas e recursos além do kernel propriamente dito. Para nós que trabalhamos com estatística, por exemplo, precisamos de ter a nossa disposição outras linguagens de programação além de C, como R, C++, Java, Go, Lua, Rust, Ruby, Julia, Python, entre outras linguagens, além de IDEs (Integrated Development Environment) para desenvolvimento dos nossos programas, softwares para escrita de relatórios, sistemas de gerenciamento de banco de dados, sistermas de versionamento, entre diversos outros programas de interesse. Anterior ao início do desenvolvimento do Linux (kernel), Richard Matthew Stallman, conhecido por muitos programadores pela sigla rms, tinha anunciado no final de 1983 o projeto do sistema operacional GNU (Projeto GNU). Figura 2.3: Logo do projeto GNU, lançado em 27 de setembro de 1983, por Richard Stallman Richard Matthew Stallman (rms). O desenvolvimento do sistema operacional GNU (sistema tipo Unix, Unix-like) teve início em 1984 com o auxílio de diversos programadores. Nesse projeto, os programadores iniciaram o desenvolvimento das ferramentas principais de um sistema operacional em paralelo ao desenvolvimento de editores de textos, compiladores da linguagem C, clientes de e-mail, interfaces gráficas, entre outras aplicações de interesses para o usuário final. Figura 2.4: Richard Matthew Stallman (rms), fundador do movimento de software livre, do projeto GNU e da Free Software Fundation em uma de suas palestras. Por volta de 1990, o sistema operacional GNU já estava quase todo completo mas faltava uma peça fundamental e indispensável em qualquer SO - o kernel. Nessa época, já havia-se um microkernel de nome GNU Hurd. Então, após a construção das aplicações principais, o foco seria em concentrar esforços no melhoramento do kernel Hurd. Porém, por volta de 1992, quando o kernel Linux foi anunciado como software livre, este pareceu ser mais viável a se juntar ao sistema GNU. Dessa forma, a combinação do kernel Linux com o quase completo sistema GNU resultou em um sistema opracional completo e assim sugiu o GNU/Linux. Nota: No início do desenvolvimento do Linux (kernel), por volta de 1991, o compilador GCC do projeto GNU já estava pronto (lançamento em 23 de maio de 1987) e este compunha umas das diversas ferramentas construídas para o sistema GNU. Linus Torvalds utilizada e ainda utiliza o GCC como compilador de C para o desenvolvimento do kernel Linux. Como já dito anteriormente, o Linux utiliza alguns recursos fornecidos do GNU C. Assim, note a grande importância do projeto GNU e do próprio Richard Stallman para o projeto Linux. Originalmente o GCC suportava apenas a linguagem C e à época era denominado de GNU C Compiler (compilador C GNU). Atualmente o GCC tem suporte à diversas linguagens de programação e pode ser utilizado para compilar em diversas arquiteturas de computadores. Abaixo enumero algumas linguagens de programação em que atualmente é possível compilar utilizando o GCC: 1- C: linguagem de programação compilada de propósito geral, estruturada, imperativa, procedural criada em 1972 por Dennis Ritchie na empresa AT&amp;T Bell Labs para desenvolvimento do sistema operacional Unix. 2- C++: linguagem de programação compilada, multi-paradigma e de uso geral desenvolvida por Bjarne Stroustrup, um famoso cientística da computação dinamarquês e professor catedrático da Universidade do Texas. C++, inicialmente denominada de C com classes (C with Classes) surgiu em 1983 no Bell Labs. 3- Fortran: família de linguagens de programação conhecida globalmente como Fortran. Fortran foi desenvolvida a partir da década de 1950 e continua a ser usada hoje em dia. O nome é um acrônimo da expressão IBM Mathematical FORmula TRANslation System. Fortran foi muito utilizada na área de computação científica e ainda continua sendo bastante utiliza pelo pessoal da “velha guarda”. 4- Object-C: linguagem de programação orientada a objeto inspirada nas linguagens Smalltalk e C. 5- Java: linguagem de programação orientada a objetos desenvolvida na década de 90, por uma equipe de programadores chefiada por James Gosling, na empresa Sun Microsystems. Em 2008 o Java foi adquirido pela empresa Oracle Corporation. 6- Go: linguagem de programação criada pela Google e lançada como código livre em novembro de 2009. 7- D: linguagem de programação de uso geral projetada por Walter Bright da Digital Mars. É baseada majoritariamente em C++, apesar de não ser apenas uma variante. A versão estável da primeira especificação foi lançada em janeiro de 2007. 8- Ada: linguagem de programação estruturada e de tipagem estática. É uma linguagem imperativa, orientada a objetos e de alto nível, originada de Pascal, Simula e outras linguagens. Figura 2.5: Logo do GNU Compiler Collection, denominado de GCC produzidos pelo projeto GNU, em que o ovo faz alusão à origem do (Projeto GNU). O logo do GCC acima é interessante e resume um pouco do que foi dito. Uma das primeiras ferramentas para se construir programas de computador, principalmente em uma época dominada por linguagens compiladas, é um compilador. Sendo assim, foi por meio do GCC que surgiu todas as aplicações do projeto GNU. O logo representa o nascimento de um gnu, mamífero nativo do continente africano que é utilizado como símbolo/logo (Figura 2.3) do projeto GNU. Observação: O compilador GCC está em amplo desenvolvimento, incorporando novas ferramentas, tecnologias e suporte à novas linguagens de programação. Voltando ao Linux, no seu desenvolvimento existem colaborações de diversos programadores ao redor do mundo, em que Linus Torvalds é o pricipal desenvolvedor e gerencia o rumo que o projeto deverá seguir. Nota: Aqui você poderá acessar a conta oficial do Linus Torvalds no GitHub. Você poderá acompanhar todas as modificações e quando estas foram incluídas no projeto Linux. Mais adiante, nesse material, trataremos a respeito do uso do git/GitHub. Por sinal, o git foi criado pelo Linus Torvalds. Diversas distribuições de GNU/Linux são mantidas de acordo com suas características particulares, combinações de softwares, interfaces gráficas, estruturas de diretórios, sistemas de configurações, comunidades, entre outras. Dessa forma, entenda as distribuições Linux com uma combinação de versões de kernel Linux (agora chamaremos apenas de Linux) com diversas ferramentas/softwares do projeto GNU e outros softwares e bibliotecas podendo ser proprietários ou não. Porém, em sua essência, as distribuições Linux são livres para serem modificadas. O que normalmente poderá haver de proprietário em algumas distribuições Linux refere-se à drives, como por exemplo os drives de placas de vídeos, impressoras ou de algum hardware que você esteja utilizando. É bastante comum que diversas empresas disponibilizem versões com iniciativas Open Source de seus drives. Quando não fazem isso, sendo assim mais restritivas, estas empresas disponibilizam versões de softwares que são free (de graça para uso) mas de código fechado. Porém, quando se utiliza alguma distribuição GNU/Linu,x não é algo comum a dependência de softwares proprietários, uma vez que a a comunidade Linux é muito grande e já desenvolveu diversas alternativas com iniciativas Open Source para softwares proprietários. 2.2 Vantagens em utilizar GNU/Linux O uso de alguma distribuição GNU/Linux taz diversas facilidades para o usuário comum, aquele que utiliza o computador no seu dia a dia ou para nós que programamos e temos interesse com a estatística, em especial na área de estatística computacional. Essas facilidades estão fortimente relacionadas com a desenvoltura que um sistema GNU/Linux tem de ser configurado e adaptado para as necessidades do usuário. Há diversas outras vantagens em inclinar-se para o uso de alguma distribuição GNU/Linux, como por exemplo a sua robustez, confiabilidade e seu gerenciamento eficiente de memória. Essa última característica do Linux é algo de grande importância para os estatísticos ou programadores que trabalham com estatística, uma vez que é comum termos que carregar objetos (matrizes, tabelas, vetores, etc) que ocupam muito espaço na memória do computador. Abaixo enumero, sob minha ótica, as vantagens que um “não convertido” poderá considerar na hora de meditar sobre a necessidade de considerar uma distribuição GNU/Linux: 1 - Imagine que você precisa comprar um carro e que uma de suas opções refere-se à um carro com o motor totalmente lacrado, ou seja, suponha que jamais você irá conseguir ver o que está abaixo do capô. No início, muito provavelmente tudo funcionará bem, ao menos aparentemente. O carro irá parecer ágil, seguro e com o som do funcionamento do motor aparentemente perfeito. Porém, a medida que você vai utilizando o carro, problemas irão aparecendo, sons estranhos, motor aquecenendo, etc. Em distribuições GNU/Linux o capô é aberto, ou seja, se utilizam de iniciativas Open Source. 2 - Por consequência do item 1, você não precisa pagar para utilizar uma distribuição GNU/Linux. Dessa forma, você será um profissional que uma empresa poderá querer, uma vez que ela não precisará pagar licenças anuais de um sistema operacional para você utilizar. 3 - As distribuições GNU/Linux são normalmente menos vulneráveis à vírus e malwares, não havendo assim, em minha opinião, a necessidade de instalação de anti-vírus, muito embora estes existam para sistemas GNU/Linux. 4 - A medida que os sistemas operacionais evoluem, seus requisitos de hardwares aumentam de forma exponencial. Existem inúmeras distribuições GNU/Linux disponíveis. Algumas dessas distribuições irão exigir muito pouco dos seus hardwares. Dessa forma, você poderá dar vida à uma máquina antiga. 5 - É muito fácil, em uma distribuição GNU/Linux, manter o SO e os seus programas atualizados. Não há a necessidade de dilapidar o seu tempo para manter o sistema e softwares atualizados. Dependendo da distribuição GNU/Linux escolhida, o programa utilizado para essa tarefa poderá ser diferente. Seja qual for, eles normalmente cumprem o papel ao qual foram destinados. 6 - Linux é instalado na maioria dos servidores, demonstrando que trata-se de uma ótima escolha. Além disso, à medida que diversos aplicativos estão migrando para plataforma nas nuvens, a quantidade de aplicações, que hoje já é muito grande, está ficando ainda maior. 7 - Linux está em todo lugar e muito provavelmente está, de alguma forma, no seu celular ou TV, caso estes utilizem o sistema Android. O Android desenvolvido pela Google é baseado no kernel do Linux. 8 - A quantidade de usuários do GNU/Linux capacitados é muito grande. Nas comunidades você muito provavelmente encontrará alguém disposto para te ajudar com alguma dúvida/problema relacionado ao sistema/programação. 9 - Para nós que precisamos constantemente realizar simulações científicas, poderá surgir a necessidade da utilização de computadores eficientes (supercomputadores) em que você irá acessar a distância. Normalmente esses supercomputadores rodam alguma distribuição GNU/Linux. Acessar e submeter suas simulações nessas máquinas de alta performance é algo muito mais simples e sem grandes dores de cabeça quando usamos o GNU/Linux (alguma distribuição Linux). No Brasil há diversos CENAPAD (Centro Nacional de Processamento de Alto Desempenho), em que você poderá submeter uma proposta de projeto e usufruir do poder computacional dessas máquinas. Após conseguir uma conta, você terá que ler a documentação de como utilizar o sistema para submeter seus jobs (suas simulações), ou seja, isso exigirá que você esteja familiarizado com o uso de sistemas GNU/Linux. 2.3 Algumas distribuições Como mencionado anteriormente, as distribuições GNU/Linux fornecem diversas experiências/“sabores” no uso de Linux, variando no que diz respeito ao tamanho das comunidades, interfaces gráficas, pré-configurações realizadas, repositórios de programas, entre diversas outras características. Porém, todas as distribuições GNU/Linux tem em comum o uso do kernel Linux, podendo variar as versões e as frequências de atualizações do kernel e dos demais programas. Nota: Algumas distribuições GNU/Linux são mais papulares que outras. Isso não diz muito sobre a qualidade da distribuição, uma vez que todas elas utilizam um kernel robusto - o kernel Linux. O nível de popularidade de uma distribuição Linux normalmente está diretamente relacionado ao nível de facilidade que você terá em conseguir soluções para possíveis problemas que sempre nos deparamos ao utilizar qualquer SO. Abaixo listo algumas distribuições GNU/Linux populares: 1 - Debian: é uma distribuição GNU/Linux lançada em 1993. A distribuição Debian também tem grande importância história devido ao fato de ter influenciado diversas distribuições GNU/Linux, entre elas Ubuntu e Mint. 2 - Arch: Trata-se de uma distribuição GNU/Linux bastante flexível e com uma comunidade muito ativa. O Arch Linux foi lançado em 2002 e inicialmente desenvolvido por Judd Vinet. Porém, atualmente o projeto Arch Linux é mantido por diversos programadores espalhados pelo mundo. Outras grandes características da distribuição Arch além de ter uma comunidade intensa é a qualidade de suas documentações, em que muito provavelmente você encontrará uma instrução para tudo o que você precisa. Além disso, um ponto importante refere-se ao seu gerenciador de pacote (pacman) que é bastante organizado e fácil de utilizar. Arch é uma distribuição Rolling Release, ou seja, ao contrário das distribuições Fixed Relase que divulgam novos lançamentos importantes em intervalos regulares de tempo, uma distribuição Rolling Release tem atualizações passadas de forma mais contínua. 2 - Fedora: Trata-se de uma distribuição GNU/Linux lançada em 2003 e financiada principalmente pela Red Hat. 3 - Ubuntu: É uma distribuição Linux muito conhecida, baseada no Debian e que foi desenvolvida pela Canonical Ltd. A distribuição Ubuntu diferencia da distribuição Debian em torno da filosofia de sua concepção e periodicidade de atualizações. 5 - Manjaro: Trata-se de uma das distribuições GNU/Linux lançada em 2011, bastante robusta e baseada no Arch Linux. Todas as características destacadas para o Arch Linux são características também presente no Manjaro. Ao contrário do Arch Linux, em que um usuário iniciante no Linux poderia sentir dificuldades em utilizar, o Manjaro é uma distribuição Linux fácil de instalar e utilizar. Em um ambiente de trabalho poderemos não querer gastar muitos esforços para instalar uma distribuição GNU/Linux. Uma lista de algumas distribuções populares de sistemas *nix podem ser obtida no DistroWatch.com. Porém, note que há diversas outras distribuições GNU/Linux sendo criadas ou mesmo já criadas mas que não estão listadas no site. Como sugestão de uma boa distribuição Linux a se considerar, sugiro que testem a distribuiçao Manjaro. Muito provavelmente vocês irão desejar possuir uma distribuição bem atualizada e com as versões mais recentes de programas, linguagens e bibliotecas. A distribuição Manjaro é distribuída oficialmente com as interfaces gráficas XFCE, KDE e GNOME. Abaixo apresento algumas figuras do Manjaro utilizando as interfaces gráficas XFCE, KDE e GNOME, respectivamente. Manjaro com XFCE Figura 2.6: Distribuição Manjaro utilizando XFCE como interface gráfica. Manjaro com KDE Figura 2.7: Distribuição Manjaro utilizando KDE como interface gráfica. Manjaro com GNOME Figura 2.8: Distribuição Manjaro utilizando GNOME como interface gráfica. Você poderá baixar a iso de instalação da distribuição Manjaro, com algumas dessas interfaces gráficas, clicando aqui. Há diversos vídeos no YouTube ensinando a baixar, instalar e configurar o Manjaro. Busque pelo termo Instalando Manjaro Linux ou clique aqui. Nota: Além dessas interfaces gráficas, o Manjaro é mantido pela comunidade com outras interfaces gráficas, a exemplo das interfaces MATE, Cinnamon e Deepin. Aconselho que venha considerar o download da versão com a interface GNOME, mas esse é um gosto pessoal meu. Independente da interface que você deseja utilizar, você continua utilizando o Manjaro com o kernel Linux. É isso o que realmente importa! Entre diversas comunidades disponíveis, você poderá considerar a comunidade Manjaro Brasil. Trata-se de uma comunidade ativa e receptiva. Essa comunidade é um exemplo de um bom lugar para você sanar suas dúvidas e fazer perguntas sobre Linux e especialmente a respeito do Manjaro. Além dos diversos sites que te ajudam a aprender o Linux, você poderá procurar por vídeos no YouTube a respeito do assunto. Por exemplo, procure pelos termos Instalando manjaro, Comandos no manjaro, Utilizando pacman instalar programas, etc. Vasculhar a internet é uma ótima maneira para entender o Linux e a distribuição de sua escolha. "],
["versionamento-de-codigo.html", "3 Versionamento de código 3.1 Git 3.2 GitHub", " 3 Versionamento de código Na estatística, bem como em diversas outras áreas, a todo momento estamos editando documentos, como por exemplo, códigos de programação, artigos, relatórios, aulas, apresentações, livros, dentre inúmeros outros possíveis. Nesses processos de edições dos mais variádos documentos, quase sempre sentimos a necessidade de versionar as alterações, uma vez que se não houver um versionamento e se desejarmos voltar à um estado de edição anterior, estariamos sobre uma tarefa extremamente difícil ou mesmo impossível, a depender do número de passos anteriores ao qual desejamos voltar. Quando não dominamos nenhum sistema de controle de versão, normalmente o que fazemos para ter a possibilidade de voltar para uma dada versão de edição é armazenar diversas cópias do projeto em diretórios distintos. Versionar dessa forma pode servir quando temos poucas versões, porém, mesmo assim, é comum os desarranjos e atrapalhos no gerenciamento de diversos diretórios. Quando há o domínio de um sistema de controle de versão evitamos esse tipo de problema, uma vez que continuaremos trabalhando sobre um mesmo diretório que terá seus estados modificados quando solicitado, isto é, será possível voltar para a distribuição de arquivos e conteúdos anteriores, mesmo se nesse processo de edição alguns arquivos foram deletados, renomeados ou fortemente modificados. Importante: Não se preocupe se você voltar à estados anteriores e desistir. Você poderá retornar à estados mais recentes (incluindo o último) sem nenhum problema. Deixe o trabalho sujo com o sistema de versionamento. Além disso, para nós estatísticos que vivemos codificando e constantemente alterando códigos de programação, versionar de forma eficiente é algo crucial. 3.1 Git Visando ajudar o desenvolvedor na tarefa de versionamento de projetos/códigos, a ferramenta git foi desenvolvida, escrita utilizando a linguagem C, por Linus Torvalds (criador do Linux) e atualmente mantido por Jun Hamano, um engenheiro de sofware japonês. No git, cada diretório de trabalho é um repositório com histórico completo das versões e não depende de acesso à um servidor ou rede central. Essa é uma das características que torna o git uma ferramenta rápida, além, é claro, de ser escrito em C, que reduz a sobrecarga de tempos de execução que é algo normalmente comum em linguagens de nível superior. Inicialmente essa ferramenta visava ajudar os desenvolvedores do kernel do Linux na tarefa de versionar, de forma eficiente, as mudanças no kernel que antes eram versionadas por meio do BitKeeper, um software proprietário desenvolvido pela BitMover Inc, Califórnia. Isso era um dilema entre os desenvolvedores do Linux, uma vez que ao contrário do BitKeeper, o Linux é conhecido por suas iniciativas Open Source. À época, o projeto Linux tinha acesso gratuito ao BitKeeper. Porém, com a acusação de programadores do kernel Linux estarem utilizando engenharia reversa, o acesso gratuito foi removido. Esse foi o fato que forçou Linus Torvalds a desenvolver o git. Além do git, atualmente existem algumas ferramentas para versionamento de códigos. Entre tais ferramentas, enumero duas que considero as mais conhecidas: mercurial: Trata-se de um sistema de versionamento, assim como o git, com iniciativas Open Source. Na internet é fácil encontrar diversos comparativos, em que muitos usuários citam como uma de suas vantagens a facilidade. O mercurial é o sistema de versionamento mais popular no Bitbucket, uma plataforma de hospedagem de código fonte que não é tão utilizada quanto o GitHub e o GitLab; subversion: Trata-se de um sistema de versionamento distribuido sobre os termos da Apache License e que foi desenvolvido pela Apache Software Foundation. Assim como o mercurial, o subversion não é tão popular quanto o git. Por se tratar do sistema de versionamento mais amplamente utilizado (mais popular) em versionamentos locais e remotos (a exemplo do GitHub e GitLab que são plataformas de hospedagem de código, em que é possível facilmente enviar códigos versionados usando git), trataremos apenas do uso do git. Nota: A ferramenta git poderá ser facilmente instalada em Linux/Unix, Windows e macOS. Clique aqui e faça o download da versão desejada e instale em seu sistema operacional. Há diversos vídeos na internet ensinando a configurar o git em sistemas Windows. Após a instalação do git em seu sistema operacional, abaixo listarei algumas funções interessantes para o uso do git via o prompt de comando (terminal). O terminal ao qual você deverá trabalhar com o git é algo parecido com as imagens abaixo: Figura 3.1: A imagem mais a esquerda refere-se ao terminal bash no linux e a mais a direita refere-se terminal bash instalado no Windows para o uso do git. Essas imagens são meramente ilustrativas e poderão variar um pouco a depender do sitema operacional. Observação: Para usuários de sistemas operacionais baseados em Arch Linux, por exemplo, usuários do Manjaro Linux, a instalação do git é bastante fácil. No terminal do Linux, basta fazer: sudo pacman -S git Caso você tenha optado em utilizar alguma distribuição GNU/Linux que não é derivada do Arch, muito provavelmente você não seguiu as considerações da distribuição Linux sugeridas na Seção Algumas distribuições, em que sugiro o uso do Manjaro Linux ou de distribuições GNU/Linux derivadas do Arch. Dessa forma, busque na distribuição GNU/Linux escolhida o comando para a instalação do git. Nota: Se você está utilizando alguma distribuição GNU/Linux baseada em Debian/Ubuntu, você poderá instalar o git fazendo sud apt-get install git. Outros a respetio da instalação do git poderão ser encontrados aqui. No Linux, o terminal bach, que é instalado por padrão, será o terminal que utilizaremos o git. Não há nenhuma necessidade de utilização de termais complementares. No terminal bach, para facilitar, você pode chamar simplesmente de “terminal do linux” é onde configuramos o sistema operacional, instalamos programas, removemos programas, programamos, compilamos, utilizamos o git, etc. É incrível a flexibilidade e a quantidade de coisas que podemos fazer no terminal do Linux. Usuários do sistema operacional Windows poderão instalar facilmente o git considerando o executável fornecido aqui. Se o seu sistema for 64 bits, vá ao final da página e faça o download do arquivo Git-x-64-bit.exe, em que x dá lugar a versão do git. Para esses usuários, durante o processo de instalação, no passo Adjusting your PATH environment, é importante selecionar a última opção, conforme a imagem abaixo: Após a instalação do git, em seu sistema operacional, abra o terminal e execute o comando git --version. Em caso de retorno da versão instalada do git, muito provavelmente a instalação ocorreu corretamente. Após instalar corretamente o git, a primeira coisa que você precisa fazer é configurar o seu nome de usuário e endereço de e-mail. Isso é de grande importância, uma vez que cada commit (compromentimento), a informação do usuário que fez alguma atualização do documento/projeto é utilizada. Ou seja, trata-se de uma espécie de “carimbar” o autor da modificação. Sendo assim, no terminal, faça: git config --global user.name &quot;seu nome ou sigla&quot; git config --global user.email seu_email Nota: A configuração acima só precisará ser realiazada uma única vez, uma vez que foi utilizado a opção --global no momento de definir o usuário e senha. Além disso, você sempre poderá realizar essas configurações, sem a necessidade de instalar novamente o git, caso deseje trocar o nome do usuário e e-mail utilizado. Após instalar e configurar corretamente o git em seu sistema operacional, considere os comandos enumerados adiante. Esses comandos devem ser realizados no diretório ao qual queremos versionar com o git. Dessa forma, você deverá, no terminal estar no diretório a ser versionado. Importante: Os comandos cd, cd .., ls, cp, mkdir, rm e mv são comandos úteis do terminal de linux e que normalmente precisamos deles quando estamos trabalhando com o git. Muito provavelmente, esses comandos serão reconhecidos no terminal do git quando instalado no Windows. Esses comandos foram apresentados em sala de aula. Comando úteis do git: git help &lt;verbo&gt;: Esse é o comando mais importante do git. Com ele você encontrará informações a respeito de um &lt;verbo&gt;, em que &lt;verbo&gt; deverá ser substituído por um comando git válido. Por exemplo, faça git help help para obter informações sobre o comando help de git. Outras variantes de git help &lt;verbo&gt; pode ser: git &lt;verbo&gt; --help man git-&lt;verbo&gt; git --version: Como mencionado anteriormente, esse comando retornará a versão do git que encontra-se instalada no seu sistema operacional. git config --list: Esse comando lista as configurações do git que você está utilizando, ou seja, retornará o nome do usuário e e-mail que você configurou ao final da insatalação do git. git config --global core.excludesfile .gitignore: O arquivo .gitignore trata-se de um arquivo oculto (inicia-se com um ponto) e normalmente é colocado no diretório ao qual estamos querendo versionar. Dentro desse arquivo colocamos os nomes dos arquivos do diretório que estamos versionando e que desejamos não considerar no versionamento. O conteúdo desse arquivo de nome .gitignore poderia ser algo como: codigo1.R codigo2.cpp .diretorioOculto .ArquivoOculto.Rmd meulivro.pdf figura.png Com o arquivo .gitignore acima estaríamos dizendo para o git ingnorar um código R de nome codigo1.R, um código em C++ de nome codigo2.cpp, o diretório oculto de nome .diretórioOculto, um arquivo oculto R Markdown de nome .ArquivoOculto.Rmd, um livro em formato PDF de nome meulivro.pdf e uma figura no formato png de nome figura.png. Nota: Normalmente não utilizamos o comando git config --global core.excludesfile .gitignore, uma vez que esse comando irá sempre ignorar do versionamento qualquer um desses arquivos/diretórios que encontram-se listado em .gitignore. Algo mais útil seria apenas criar o arquivo .gitignore com a lista de diretórios e arquivos ao qual queremos desconsiderar no versionamento do nosso projeto. git init: No terminal, no diretório ao qual se quer versionar, esse comanto irá inicializar o versionamento do repositório. Por exemplo, o código abaixo mostra que estamos versionando o repositório de nome DocVersionado: cd /home/usuario/DocVersionado git init git status: verifica o status das modificações dos arquivos e diretórios no interior de DocVersionado. Serão listados os arquivos que foram modificados, deletados e acrescentados no projeto. git add .: adiciona todas as modificações que foram realizadas no Working Directory na Staging Area. git commit -m \"comentário útil\": Ao utilizar o comando git add ., as modificações ainda não foram versionadas, ou seja, não foram adicionadas no Git Directory. Para que as modificações adocionadas na Staging Area sejam versionadas, será preciso utilizar o comando git commit -m \"comentário útil\", em que \"comentário útil\", como o próprio nome diz, é um comentário útil a respeito das modificações realizadas no projeto. Cada commit realizado é internamente identificado por uma chave. Será por meio dessa chave que conseguiremos retroagir ou progredir no histórico do versionamento do nosso projeto. git log: exibe os históricos com todas as modificações realizadas, comentários dos commits realizados, as chaves de cada commit, horário da realização da introdução das modificações e informações do usuário que realizou as alterações. Algo parecido com a imagem abaixo: git log --stat: trás informações detalhadas das modificações realizadas em todos os arquivos e diretórios versionados dentro de um projeto. Com esse comando é possível inclusive ver a quantidade de alterações (deleções e inserções). git log --pretty=oneline: retorna informações resumidas de todos os commits realizados. Na maioria das vezes é o comnando mais utilizado para obter as chaves a chave de um dado commit, uma vez que não desejamos poluir o terminal com informações que muitas vezes podem ser desnecessárias. Você poderá utiliar o comando clear ou as teclas de atalho Ctrl + L para limpar o terminal. A imagem abaixo mostra cada commit em uma linha (chave e comentário): git checkout chave: modifica o projeto para o estado do commit referente à chave fornecida. Se deserjarmos voltar ao último commit, devemos fazer git checkout master. As chaves poderão ser fornecidas utilizando as diferentes variações do comando git log paresentadas acima. (OUTROS DETALHES FORAM ABORDADOS EM AULA NO DIA 17/06/2019) 3.2 GitHub (CONTEÚDO ABORDADO EM SALA DE AULA NO DIA 17/06/2019) "],
["relatorio-markdown-em-r.html", "4 Relatório Markdown em R 4.1 Markdown 4.2 R Markdown", " 4 Relatório Markdown em R Uma das tarefas mais importantes e frequentes na vida de um estatístico refere-se à construção de documentos (relatórios, manuais, etc). A construção desses documentos é algo que demanda tempo, uma vez que, por exemplo, temos que escrever a respeito das metodologias estatísticas consideradas e justificar o seu uso, organizar as informações obtidas de um modelo estatístico e interpretá-las, tabular os resultados de algumas simulação, escolher o formato de saída do documento e escrever de forma clara e robusta os resultados obtidos (muitos que irão ler seu documento não são estatísticos). Um pouco dessa rotina encontra-se no diagrama a baixo: Figura 4.1: Fluxo de trabalho - organização dos dados, escolhas das metodologias, implementações e edição de documento. Como descrito no diagrama 4.1, o processo de construção de um relatório é um processo frequente, uma vez que você muito provavelmente, em alguma empresa, irá deparar-se com documentos em que deverão ser atualizados, dia após dia. Por exemplo, você poderá vir a trabalhar em uma empresa em que diariamente terá que enviar relatório(s) ao seu chefe ou para um grupo de pessoas. Por exemplo, em muitas situações, esse(s) documentos(s) poderão possuir um layout predefinido, onde serão apenas alterados os resultados/retornos obtidos por suas funções implementadas em R. Ou seja, estamos considerando o caso em que você diariamente tem o mesmo relatório com diferentes estatísticas (indicadores descritivos, resultados inferenciais, etc). Com o R e o Markdown, bem como utlizando outras ferramentas disponíveis para programadores de R, você poderá automatizar, ao máximo, o processo de construção documentos. Por tratar-se de uma comunidade grande e que envolve muitos estatísticos, a comunidade de R vem constantemente desenvolvendo ferramentas de interesse para quem trabalha com estatística e aprendizado estatístico. Muitas dessas ferramentas são disponibilizadas na forma de pacotes, no CRAN (The Comprehensive R Archive Network), bem como no GitHub. Isso mostra a grande flexivilidade de R e o quanto essa linguagem se adapta às necessidades de um estatístico ou à quem for de interesse a análise de dados. Você poderá programar em qualquer linguagem, porém, programar em R tornará sua vida de progamador/estatístico mais fácil, caso o seu seu interesse esteja em resolver problemas estatísticos e/ou que envolvam aprendizado estatístico, denominado por muitos de machine learning (aprendizado de máquina). Observação: Nada impedirá que você venha trabalhar com problemas não estatísticos em R. R é uma linguagem elegante, flexível e que permite se comunicar com diversas outras linguagens de programação. Como mostra o diagrama 4.1, a linguagem R está no meio de importantes etapas de um estudo. O estatístico poderá utilizar o R para organizar os dados, implementar as metodologias estatísticas adotadas no estudo e se quiser, poderá utilizar o R para construir o relatório. Note que no diagrama 4.1, descrevemos a linguagem R como uma ferramenta que está presente entre quase todos os passos na construção dos resultados de um estudo. Integrando o Markdown com a linguagem R, você fará com que o R esteja presente entre todos os processos do estudo, o que certamente trará grande flexibilidade (possibilidades) às suas análises. Assim, seu fluxo de trabalho passará de 4.1 para 4.2 otimizando assim, as suas análises. Figura 4.2: Linguagem R entre todos os fluxos de trabalho de um estudo estatístico. Destaque para o uso de R para a construção de um relatório. Nota: Esse material que você está lendo agora mostra um pouco do que você consegue fazer com o R + Markdown utilizando algumas ferramentas (pacotes) disponíveis para o R. As ferramentas que integram R com Markdown são bem integradas com a IDE de programação RStudio, o que facilita um pouco o trabalho de edição. 4.1 Markdown Markdown é uma linguagem de marcação desenvolvida em 2004 por John Gruber com a colaboração de Aaron Swartz. Markdown é uma linguagem muito leve e diponível sob os termos de uma licença de código aberto no estilo BSD. Nota: Algo curioso com relação a linguagem Markdown é que o seu lançamento inicial se deu em 19 de março de 2004 e o seu último lançamento (versão 1.0.1) foi em 17 de dezembro do mesmo ano. A versão 1.0.1 do Markdown possui apenas 18 KB. Figura 4.3: Logo da linguagem de marcação Markdown utilizada para conversão de texto em HTML. Importante: Arquivos em Markdown devem possuir a extensão .md. A linguagem Markdown faz com que a tarefa de construir páginas em HTML seja algo bem mais fácil e prazeroso. Sinceramente, você não estaria lendo esse material se eu tivesse que escrever todo esse conteúdo diretamente em HTML. Para entender um pouco do que estou falando, logo abaixo você encontrará dois exemplos do mesmo texto escrito utilizando as linguagens de marcação Markdown e HTML, respectivamente. Ambos nos levarão ao mesmo resultado de uma página em HTML. Note como é mais claro e limpo o código em Markdown em comparação ao código em HTML. Texto escrito utilizando Markdown: # Seção Escrevendo alguma coisa nessa minha seção. ## Subseção Escrevendo alguma coisa nessa minha subseção. Outra linha. Colocando texto em itálico _texto em itálico_ ou *texto em itálico*, em negrito **texto em negrito** e destacando um código `f &lt;- function() ...`. Criando uma linha horizontal: --- Listando itens: * R é Open Source * R é uma ótima linguagem de progrmação * Estatísticos em todo o mundo usam R * R é utilizado por grandes empresas para análise de dados e em aprendizagem de máquina. --- Enumerando itens: 1. R Agro 2. R é Tec 3. R é Pop 4. R é Tudo --- Um bom curso de estatística computacional utilizando R poderá ser encontrado em [**Estatística Computacional**](https://prdm0.github.io/aulas_computacional). ![Logo da linguagem de programação R.](https://www.r-project.org/logo/Rlogo.png &quot;icon&quot;) Lembre-se: &gt; Batatinha quando nasce, esparrama pelo chão. &gt; Se você não aprender em R irá sofrer de montão. &gt; --- Autor desconhecido, 2019. &lt;strong&gt;Se eu desejar, poderei utilizar código HTML&lt;/strong&gt;. Texto escrito utilizando HTML: &lt;h1&gt;Seção&lt;/h1&gt; &lt;p&gt;Escrevendo alguma coisa nessa minha seção.&lt;/p&gt; &lt;h2&gt;Subseção&lt;/h2&gt; &lt;p&gt;Escrevendo alguma coisa nessa minha subseção.&lt;/p&gt; &lt;p&gt;Outra linha.&lt;/p&gt; &lt;p&gt;Colocando texto em itálico &lt;em&gt;texto em itálico&lt;/em&gt; ou &lt;em&gt;texto em itálico&lt;/em&gt;, em negrito &lt;strong&gt;texto em negrito&lt;/strong&gt; e destacando um código &lt;code&gt;f &amp;lt;- function() ...&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Criando uma linha horizontal:&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;Listando itens:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;R é Open Source&lt;/li&gt; &lt;li&gt;R é uma ótima linguagem de progrmação&lt;/li&gt; &lt;li&gt;Estatísticos em todo o mundo usam R&lt;/li&gt; &lt;li&gt;R é utilizado por grandes empresas para análise de dados e em aprendizagem de máquina.&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;p&gt;Enumerando itens:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;R Agro&lt;/li&gt; &lt;li&gt;R é Tec&lt;/li&gt; &lt;li&gt;R é Pop&lt;/li&gt; &lt;li&gt;R é Tudo&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;p&gt;Um bom curso de estatística computacional utilizando R poderá ser encontrado em &lt;a href=&quot;https://prdm0.github.io/aulas_computacional&quot;&gt;&lt;strong&gt;Estatística Computacional&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;https://www.r-project.org/logo/Rlogo.png&quot; alt=&quot;Logo da linguagem de programação R.&quot; title=&quot;icon&quot; /&gt;&lt;/p&gt; &lt;p&gt;Lembre-se:&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Batatinha quando nasce, esparrama pelo chão. Se você não aprender em R irá sofrer de montão.&lt;/p&gt; &lt;p&gt;--- Autor desconhecido, 2019.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;strong&gt;Se eu desejar, poderei utilizar código HTML&lt;/strong&gt;.&lt;/p&gt; Nota: Os códigos apresentados acima, utilizando as linguagens de marcação Markdown e HTML, irão nos levar aos mesmos resultados. Para observar o resultado, clique aqui. É claro que o HTML produzido ainda é bem simples e “rústico”, lembrando um pouco das páginas do início da popularização da internet. Mas calma, utilizando as ferramentas corretas e que estão disponíveis em R, poderemos produzir texto como esse que você está lendo agora. A boa notícia é que você não precisará alterar em nada o código escrito em Markdown para obtenção de uma saída mais agradável. Você apenas precisará associá-lo à ferramenta correta dispiníveis em R. Antes de conversarmos a respeito das ferramentas disponíveis, em R, para a construção de saídas em HTML mais atraentes, precisaremos entender melhor a sintaxe do Markdown. A seção que segue é dedicada ao entendimento da sintaxe do Markdown. 4.1.1 Sintaxe Entender a sintaxe de Markdown é algo interessante por alguns motivos. Elencarei três deles abaixo: A sintaxe de Markdown é fácil e não requer uma grande curva de aprendizado; Seus documentos podem ser facilmente compartilhados dentro de uma empresa ou grupo de pessoas. Seu relatório em HTML poderá estar hospedado utilizando algum serviço e as pessoas poderão acessar o conteúdo clicando em um link. Por exemplo, não haverá a necessidade de compartilhar arquivos por e-mail ou em dispositivos de armazenamento. Você não precisará levar esse arquivo com você, caso tenha acesso à internet; Markdown poderá ser utilizado em vários lugares, e não apenas em conjunto com o R. Por exemplo, você poderá utilizar o Markdown no GitHub ou no Stack Overflow, site este de perguntas e respostas que é muito útil no aprendizado de programação. Por sinal, aconselho que você crie uma conta e venha utilizado o Stack Overflow para fazer peguntas de programação em R. Há uma comunidade grande de programadores de R no Stack Overflow. No Stack Overflow você não poderá fazer perguntas genéricas. Se você tiver com problemas em algum código, construa um exemplo do código resumido e explique detalhadamente o seu problema e o que deseja obter. Assim, você terá grandes chances de sua pergunta ser respondida de forma eficiente, cordial e sem correr o risco de ter a sua pergunta apagada por algum moderador. Nota: Por falar em Stack Overflow, a equipe do Stack Overflow utiliza o R e o RStudio em suas análises. Veja um depoimento aqui. Utilizar o Markdown com o R dentro do RStudio é algo interessante e fácil. Porém, para aprender a sintaxe, consideraremos essa ferramenta. Por ela, você poderá testar rapidamente o que o que irá aprender. 4.1.1.1 Parágrafo, cabeçalho e bloco de códigos Um parágrafo em Markdown é constrído por uma ou mais linhas de textos separadas por uma ou mais linhas em branco. Escrevendo três parágrafos em Markdown: Aqui estou criando meu primeiro parágrafo em Markdown. Espero que eu possa aprender o markdown e assim venha obter sucesso na minha carreira como estatístico. Darei um espaço abaixo: Aqui é o meu segundo parágrafo. Só passando para lembrar que R é uma ótima linguagem de programação. Abaixo colocarei 2 espaços: &quot;Qualquer um pode, com algum estudo, escrever códigos que o computador enteda. Bons programadores esvrevem códigos que os humanos entendam.&quot; - Alguém, 5 mil anos a.C. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. Acrescendando um cabeçalho: Você poderá utilizar uma sequencia do caracter = para iniciar uma seção. Analogamente, utilizando o caracter - você poderá criar uma subseção. Um texto com parágrafos soltos ============================== Aqui estou criando meu primeiro parágrafo em Markdown. Espero que eu possa aprender o markdown e assim venha obter sucesso na minha carreira como estatístico. Darei um espaço abaixo: Aqui é o meu segundo parágrafo. Só passando para lembrar que R é uma ótima linguagem de programação. Abaixo colocarei 2 espaços: Um programador que não organiza o seu código deveria morrer mais cedo --------------------------------------------------------------------- &quot;Qualquer um pode, com algum estudo, escrever códigos que o computador enteda. Bons programadores esvrevem códigos que os humanos entendam.&quot; - Alguém, 5 mil anos a.C. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. Importante: É importante dizer que esse comportamento poderá veriar de uma ferramenta que suporta a sintaxe de Markdown para outra. Com o uso frequente de alguma dessas ferramentas, você irá familiarizar-se com algumas possíveis divergências. 4.1.1.2 Seções/subseções aninhadas Podemos utilizar sequências do caracter # para criar seções aninhadas. O código acima poderia ser alterador por: # Um texto com parágrafos soltos Aqui estou criando meu primeiro parágrafo em Markdown. Espero que eu possa aprender o markdown e assim venha obter sucesso na minha carreira como estatístico. Darei um espaço abaixo: Aqui é o meu segundo parágrafo. Só passando para lembrar que R é uma ótima linguagem de programação. Abaixo colocarei 2 espaços: ## Um programador que não organiza o seu código deveria morrer mais cedo &quot;Qualquer um pode, com algum estudo, escrever códigos que o computador enteda. Bons programadores esvrevem códigos que os humanos entendam.&quot; - Alguém, 5 mil anos a.C. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. De uma forma geral, tem-se: # Seção ## Subseção ### Subsubseção #### Subsubsubseção ... — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. 4.1.1.3 Bloco de Frases É possível criar, por meio do caracter &gt; frases em bloco. Por exemplo, com a ferramenta que utilizo para a construção desse material, temos abaixo três frases utilizando três níveis de blocos. Primeiro nível de bloco. Segundo nível de bloco. Terceiro nível de bloco. &gt; Primeiro nível de bloco. &gt; &gt; Segundo nível de bloco. &gt; &gt; &gt; Terceiro nível de bloco. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. 4.1.1.4 Dando ênfase É possível que venhamos dar ênfase à um trecho de um texto. Isso é feito utilizando * (asterisco), _ (subilinhado/underscore), ** (duplo asterisco) ou __ (duplo subilinhado/underscore). Essas combinações de caracteres devem envolver o texto a ser destacado e fazem: * (asterisco): Deixa o texto envolvido em itálico. Isso é feito fazendo *texto em itálico* — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. _ (sublinhado/underscore): Faz o mesmo que *, isto é, deixa o texto envolvido em itálico. _texto em itálico_ — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. ** (duplo asterisco): Deixa o texto envolvido em negrito. **texto em negrito** — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. __(dublo subilinhado/underscore): Faz o mesmo que envolver o texto por **, isto é, deixa o texto envolvido em negrito. __texto em negrito__ — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. O código abaixo faz uso do que aprendemos até aqui: # Um texto com parágrafos soltos Aqui estou criando meu primeiro parágrafo em **Markdown**. Espero que eu possa aprender o markdown e assim venha obter sucesso na minha carreira como estatístico. Darei um espaço abaixo: _Aqui é o meu segundo parágrafo_. Só passando para lembrar que R é uma ótima linguagem de programação. __Abaixo colocarei 2 espaços__: ## Um programador que não organiza o seu código deveria morrer mais cedo *&quot;Qualquer um pode, com algum estudo, escrever códigos que o computador enteda. Bons programadores esvrevem códigos que os humanos entendam.&quot;* - **Alguém**, _5 mil anos a.C_. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. 4.1.1.5 Listando Itens Em seu texto, é possível que tenha o intenresse de listar itens de forma não ordenada. Isso é possível utilizando os caracteres *, + ou -. Considere o exemplo: * Meu primeiro item; * Meu segundo item; * Meu terceiro item. ou + Meu primeiro item; + Meu segundo item; + Meu terceiro item. ou ainda - Meu primeiro item; - Meu segundo item; - Meu teceiro item. Nota: Você poderá intercambiar os caracteres *, + e -. Ou seja, você poderá fazer: * Meu primeiro item; + Meu segundo item; - Meu terceiro item. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K.. 4.1.1.6 Enumerando Itens As vezes necessitamos de itens dispostos segundo uma ordem. Você poderá ordenar os itens utilizando um número seguido de um ponto. Considere o exemplo abaixo: 1. Meu primeiro item enumerado; 2. Meu segundo item enumerado; 3. Meu terceiro item enumerado. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. Nota: Os itens enumerados ou não enumerados podem ser formados por parágrafos. Você deverá colocar 4 (quatro) espaços para iniciar um parágrafo de um respectivo item. Considere o código abaixo: 1. Aqui é o meu primeiro item. Aqui é um novo parágrafo do meu primeiro item. 2. Aqui é o meu segundo item. Aqui é um novo parágrafo do meu segundo item. 3. Aqui é o meu terceiro item. Aqui é um novo parágrafo do meu terceiro item. Essa mesma regra vale para os itens não enumerados. Considere o código abaixo: * Aqui é o meu primeiro item. Aqui é um novo parágrafo do meu primeiro item. * Aqui é o meu segundo item. Aqui é um novo parágrafo do meu segundo item. * Aqui é o meu terceiro item. Aqui é um novo parágrafo do meu terceiro item. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. 4.1.1.7 Criando Links A linguagem de marcação Markdown te permite inserir links no meio do seu texto. Markdown suporta dois estilos de inserção de links. São eles: Link não resumido: As vezes temos o interesse de deixar claro, em nosso texto, qual o endereço completo de um e-mail ou site. Por exemplo, considere o texto do exemplo abaixo: Exemplo 1: Se você precisar, acesse o http://www.de.ufpb.br/ do Departamento de Estatística da UFPB. Também, em caso de necessidade, você poderá mandar um e-mail para mim. Meu e-mail é pedro.rafael.marinho@gmail.com. A forma geral para a construção de links não resumido é &lt;link&gt;. Para obtermos o retorno acima, devemos fazer: Se você precisar, acesse o &lt;http://www.de.ufpb.br/&gt; do Departamento de Estatística da UFPB. Também, em caso de necessidade, você poderá mandar um e-mail para mim. Meu e-mail é &lt;pedro.rafael.marinho@gmail.com&gt;. Link resumido: Trata-se do link que é substituido por um texto sugestivo ao seu conteúdo. Trata-se de uma forma de se construir um link sem a necessidade expor todo o caminho/endereço (froma resumida). Por exemplo, considere o texto do exemplo abaixo: Exemplo 2: Se você precisar, acesse o site do Departamento de Estatística da UFPB. Também, em caso de necessidade, você poerá mandar um e-mail para mim. A forma geral para construção de links resumido (sugestivos) é [testo do link](link). Por exemplo, o exemplo cima poderá ser obtido pelo código abaixo: Se você precisar, acesse o [**site**](http://www.de.ufpb.br/) do Departamento de Estatística da UFPB. Também, em caso de necessidade, você poerá mandar um [**e-mail**](mailto:pedro.rafael.marinho@gmail.com) para mim. — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. Nota: Em se tratando de link resumido, para linkar corretamente um e-mail com o programa de envio e recebimento padrão instalado no computador, você deverá utilizar a expressão mailto: antes da definição do e-mail ao qual deseja linkar com o programa. Por exemplo: [e-mail](mailto:pedro.rafael.marinho@gmail.com) Se você desejar, você poderá ter uma lista enumerada de links ao final do arquivo e invoca-los, por sua numeração, no corpo do seu texto. Considere o texto do exemplo que segue: Exemplo: “Adoro programar utilizando a linguagem R. Para uma melhor experiência, considere programar utilizando a IDE RStudio. Programar em R com o RStudio torna a tarefa de programar ainda mais agradável. Mais agradável ainda é saber que a linguagem R possui um grande número de pacotes para trabalhar com estatística.” Um solução, com o que já aprendemos de Markdown, para esse exemplo acima, poderia ser: Solução 1: &quot;**Adoro programar** utilizando a linguagem [**R**](https://www.r-project.org). Para uma melhor experiência, considere programar utilizando a IDE [RStudio](https://www.rstudio.com/products/RStudio/). Programar em [R](https://www.r-project.org) com o [**RStudio**](https://www.rstudio.com/products/RStudio/) torna a tarefa de programar ainda mais agradável. Mais agradável ainda é saber que a linguagem [R](https://www.r-project.org) possui um grande número de [*pacotes*](https://cloud.r-project.org/web/packages/available_packages_by_date.html) para trabalhar com estatística.&quot; — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. Solução 2 &quot;**Adoro programar** utilizando a linguagem [**R**][1]. Para uma melhor experiência, considere programar utilizando a IDE [RStudio][2]. Programar em [R][1] com o [**RStudio**][2] torna a tarefa de programar ainda mais agradável. Mais agradável ainda é saber que a linguagem [R][1] possui um grande número de [*pacotes*][3] para trabalhar com estatística.&quot; [1]: https://www.r-project.org &quot;R&quot; [2]: https://www.rstudio.com/products/RStudio/ &quot;RStudio&quot; [3]: https://cloud.r-project.org/web/packages/available_packages_by_date.html &quot;packages&quot; — Teste Aqui ou salve o código em um arquivo com extensão .md e, no RStudio, faça Ctrl + Shift + K. Nota: Note que o exemplo acima poderá ser útil em situações que que repetimos linkamos uma palavra ao longo de todo o texto. Nesses casos, a linkagem considerando a numeração dos links poderá ser menos cansativa. 4.1.1.8 Inserindo figuras no texto Se você trabalha com estatística muito provavelmente sente corriqueiramente a necessidade de introduzir, em um texto, gráfico(s) e imagen(s) que explica(m) um resultado obtido ou que nos auxilia(m) à etender um detarminado problema. A sintaxe de inserção de figuras é muito semelhante à sintaxe de inserção de links. Exemplo: Suponha que desejamos inserir o logo da linguagem de programação R, na forma abaixo: Figura: Logo da linguagem de programação R obtido em aqui. A Figura acima poderá ser inserida na forma que segue: &lt;center&gt; ![](https://www.r-project.org/logo/Rlogo.png){height=&quot;100px&quot; width=&quot;100px&quot;} &lt;/br&gt; Figura: Logo da linguagem de programação **R** obtido em [**aqui**](https://www.r-project.org/logo/Rlogo.png). &lt;/center&gt; Observação: Poderá ser que a depender de onde você esteja testando esse código, a expressão {height=\"100px\" width=\"100px\"} não venha funcionar. Além disso, não se preocupe com o alinhamento da imagem nem com outros pormenores. Com pouco esforço e utilizando as ferramentas necessárias de R, tudo se ajustará. O objetivo aqui é apenas expor o básico da sintaxe de Markdown. Você poderá achar estranho algumas sintaxes acima. Abaixo esclareço todas elas: &lt;center&gt; … &lt;/center&gt;: Essas expressões faz com que tudo o que está envolvido entre elas sejam centralizados na página em HTML que será gerada. Essas expressões também poderá ser útil para centralizar textos. Exemplo: Reproduza o exemplo que segue: &lt;center&gt; Envolver algum texto entre `&lt;center&gt;`e &lt;/center&gt; &lt;center&gt; fará com que tudo que esteja envolvido seja centralizado. &lt;/center&gt; &lt;/br&gt;: Trata-se de um expressão de HTML responsável por pular uma linha. Essa expressão poderá ser utilizada em qualquer lugar do seu código escrito em Markdown. {height=\"100px\" width=\"100px\"}: Essa expressão é utilizada para definirmos as dimensões da imagens, a ser inserida, nesse caso em pixels, altura e largura, respectivamente. Exercícios Construa um código em Markdown que retorne a saída abaixo: R é um ambiente de software livre para computação estatística e gráficos. Ele compila e é executado em uma ampla variedade de plataformas UNIX, Windows e MacOS. Para fazer o download do R, escolha o seu espelho CRAN (Comprehensive R Archive Network) preferido. Modifique o código em Markdown utilizado no exercício anterior para que forneça: R é um ambiente de software livre para computação estatística e gráficos. Ele compila e é executado em uma ampla variedade de plataformas UNIX, Windows e MacOS. Para fazer o download do R, escolha o seu espelho CRAN (Comprehensive R Archive Network) preferido. Construa o código em Markdown que forneça uma saída próxima a da imagem abaixo: Forneça o código Markdown para a obtenção do resultado que segue: Aqui é o item 1: Subitem 1 Subitem 2 Subitem 3 Aqui é o item 2: Subitem 1 Subitem 2 Subitem 3 Aqui é o item 3: Subitem 1 Subsubitem 1 Subsubitem 2 Subitem 2 Subsubitem 1 Subsutitem 2 Forneça o código Markdown que retore o resultado que segue: Aqui é o item 1: Eu serei um programador de R. Eu prometo de sempre serei fiel, na alegria e na tristeza, até que a morte nos separe… Além dos votos acima, abaixo segue dois motivos para você apresender a programar em R: Se você não programar, você não irá passar na disciplina. =( Acho que o motivo acima é suficiente. R é uma linguagem legal. R tem vários pacotes: Mais algumas coisas … : Bla bla bla bla bla bla bla bla … Bla Bla … Se tudo der errado, mande um email para jesus@aomeudeus.com com o título: “Estou Chegando”. Considere o a imagem desse link. Crie um arquivo Markdown de modo a ser inserido a imagem com dimensões 50 por 50 pixels centralizada no HTML resultante após a compilação. O resultado que você deverá obter é o que segue: Figura: Importando o logo do RStudio figura qualquer. 4.2 R Markdown Se você chegou à esse ponto da leitura, muito provavelmente deverá estar se perguntando sobre muitas coisas. Algumas dessas perguntas poderiam ser: Como referenciar um texto ou figura? E se eu quiser colocar figuras lado a lado? Como incorporar fórmulas matemáticas no corpo do texto? Como colocar referências no texto? É possível incorporar tabelas? As respostas à estas perguntas não foram respondidas por serem bastante inconveniente ou mesmo impossível de respondê-las utilizando a linguagem Markdown. A linguagem Markdown é bastante simples e útil para muitos casos. Aliás, na maior parte do tempo estamos utilizando a sintaxe de Markdown, sendo que algumas vezes é que nós nos deparamos com com algumas dessas necessidades. Visando atender à diversas exigências, entre elas as que estão enumeradas acima, houve a necessidade de se extender a sintaxe do Markdown em R. Essas necessidades corriqueiras são atendidas pelo pacote rmarkdown que disponibiliza ao usuário o R Markdown. O pacote rmarkdown foi criado por Yihui Xie, PhD em estatística e que atualmente trabalha como engenheiro de software na RStudio, Inc. Yihui Xie atualmente mantem diversos pacotes em R em seus repositórios no GitHub. Figura 4.4: Logo do pacote rmarkdown - permite programadores R extender a sintaxe de marcação Markdown utilizando R Markdown. Como dito anteriormente, para fazer uso de R Markdown será necessário o uso do pacote rmarkdown. Esse pacote, por sua vez, trabalha sobre duas importantes ferramentas. São elas: knitr: Um pacote também criado por Yihui Xie e que hoje possui diversos colaborados. O pacote knitr permite converter um texto escrito em R Markdown (arquivo com extensão .Rmd) para Markdown (arquivo com extensão .md). Em 2012, o pacote knitr já permitia com algumas linguagens de marcação, entre as mais importantes destacam-se a linguagem LaTeX e HTML. Apenas em 2015 é que foi introduzido o R Markdown (arquivos com extensão .Rmd), uma vez que o Markdown tinha se mostrado ser um formato de documento popular e bastante utilizado pela comunidade. Pandoc: Um “canivete suíço” escrito utilizando a linguagem de programação Haskell e que permite converter textos escritos em uma linguagem de marcação para outra. Muito embora você não precisa utilizar diretamente os comandos do Pandoc quando fizer uso do pacote rmarkdown, você poderá instalar facilmente o Pandoc em seus sistema operacional e utilizar o Pandoc para converter arquivos .tex (TeX) em .docx (DOCX, formato relacionado com a ferramenta Microsoft Word), .md (Markdown) em .pdf (PDF), .tex (LaTeX) para .md (Markdown), entre diversas outras conversões. Maiores detalhes a repseito das possíveis conversões você encontrará aqui. Nota: Com o R Markdown teremos a nossa disposição diversas ferramentas e ainda poderemos usufruir da simplicidade do Markdown. O funcionamento geral e interações entre o pacote rmarkdown com o pacote knitr e o Pandoc poderão ser resumidos com diagrama abaixo: Figura 4.5: Funcionamento do pacote rmarkdown que permite trabalharmos com arquivos .Rmd e sua interação com o knitr e Pandoc na converção para formatos intermediários. Como podemos observar no diagrama 4.5, o pacote knitr é responsável por converter o arquivo .Rmd que contém códigos em R Markdown para um arquivo .md que contém código em Markdown puro. Depois, o Pandoc irá agirar sobre o aquivo .md e irá converter para o formato desejado, em que por padrão, o formato é .html. A conversão para HTML é de longe a mais utilizada, uma vez que trata-se de um formato que facilita o compartilhamento do seu conteúdo, sendo possível, por exemplo, hospedar os HTMLs gerados em um servidor para o acesso de qualquer lugar, desde que se tenha um browser e uma conecção com uma rede de internet. O pacote knitr também incorpora algumas funcionalidades quando estamos trabalhando com R Markdown, em que a mais importante delas é a possibilidade de incorporar e avaliar pedaços (chuncks) de códigos R dentro do documento, isto é, dentro do arquivo .Rmd. Essa é uma grande funcionalidade que nos permitirá fazer duas coisas importantes: Utilizar funções de R para plotagem de gráficos; Incorporar retornos de funções no interior do relatório; Nota: Acima listei apenas duas funcionalidades de julgo como mais importantes do pacote knitr, além, é claro, de converter arquivos R Markdown para arquivos em Markdown puro. Uma outra funcionalidade do pacote knitr que vale a pena ser destacada aqui, é a possibilidade de utilizar uma de suas função para incorporá figuras previamente salvas (os formatos mais populares de imagens são suportados) e controrar seu tamanhol, título, alinhamento bem como outras características de interesse. Importante: Tudo que você aprendeu a respeito de Markdown continuará valendo para arquivos R Markdown (arquivos com extensão .Rmd). Antes de iniciarmos as próximas seções a respeito do R Markdown, certifique-se que você possue o rmarkdown e o knitr instalados. Muito provavelmente esses pacotes juntamente com o Pandoc já estarão instalados, caso você esteja utilizando o RStudio. Em todos os exemplos que seguem nas seções que seguem, no RStudio, acesse as opções File, New File e R Markdown, respectivamente, para criar um novo arquivo R Mardown (arquivo com extensão .Rmd). Você também poderá utilizar as teclas de atalho Ctrl + Shift + N para criar um arquivo com extensão .R e no momento de salvar mude a extensão do arquivo para .Rmd. Nota: Você poderá compilar o código de R Markdown de três formas: Utilizando, no RStudio, a combinação das teclas de atalho Ctrl + Shift + K; Clicando no ícone do pacote knitr; Utilizando a função rmarkdown::render(input = \"arquivo.Rmd\"). Será criado no diretório de trabalho o arquivo arquivo.html. "],
["r-miscelanea-e-topicos-avancados.html", "5 R - miscelânea e tópicos avançados 5.1 Operador %&gt;% - Pipe 5.2 Funções 5.3 Funcionais 5.4 Sistema S3", " 5 R - miscelânea e tópicos avançados Nesse ponto será assumido que você realizou os passos de revisão da linguagem R sugeridos, bem como resolveu os exercícios propostos. Considerá-los é de grande importância para que você consiga assimilar os conceitos apresentados nesse Capítulo. Esse Capítulo visa apresentar algumas miscelâneas a respeito da linguagem de programação R, bem como, alguns tópicos mais avançados de programação em R. O termo “avançado” utilizado aqui não necessariamente tem correlação com dificuldade de entendimento. Aqui utilizo esse termo para abordar assuntos que normalmente eram pouco discutidos em livros mais antigos da linguagem R e que atualmente vem ganhando destaques em livros e discussões mais recentes na internet. Na verdade, a maioria dos conceitos que serão abordados são de fácil compreensão, porẽm ajudarão os programadores em R a construir códigos mais robustos e mais flexíveis. Alguns desses assuntos que serão abordados e divididos em subseções são: Pipe %&gt;% Funções: Funcionais Closures dot-dot-dot, ..1, ..2 e etc Orientação à objeto por função genérica (sistema S3) Regex Tópicos em metaprogramação Paralelismo Empacotando funções 5.1 Operador %&gt;% - Pipe Para que possamos entender a utilidade dos operadores pipe, em especial do operador %&gt;%, vamos fazer um pão de queijo. Adiante, você encontrará a receita com 7 passos enumerados que deverão serem seguidos para que possamos fazer o nosso pão de queijo. Nota: Esse material não garante que você terá sucesso, caso seja curioso e tente fazer a receita. Foque apenas no código. E se você for de Minas Gerais e saiba fazer pão de queijo, desconsidere qualquer inconsistência na receita. =) Ingredientes: 2 copos americanos de leite, 1 copo americano de água, 1/3 de um copo americano de óleo, 1 colher de sopa de sal, 500g de povilho doce, queijo ralado a gosto, 3 ovos. Passos do Preparo: Ferva o leite com a água e o óleo; Em uma vasilha misture o polvilho e o sal; Jogue o liquido fervido e misture com uma colher grande; Espere esfriar (30 minutos) e despeje o queijo ralado e os ovos; Misture a massa com a mão amassando até ficar homogênea; Faça bolinhas do tamanho que preferir; Sirva quentinho; Assuma, por absurdo, que poderemos fazer nossos pães de queijo no R que que os verbos destacados nos passos acima são funções que implementamos em R. Dessa forma, forma, pelo que sabemos de R, poderemos fazer nossos pães de queijo de forma que segue: sirva(fazer(misture(despeje(esperar(misture(ingredientes = c(povilho, sal), add = ferver(c(leite, óleo), add_agua = TRUE), colher_grande = TRUE), tempo = 30), homogenea = TRUE), modo = &quot;amassando&quot;), formato = &quot;bolinha&quot;), modo = &quot;quentinho&quot;) Perceba que o código acima poderá ser um pouco confuso, uma vez que envolve muitas composições de funções. Porém, nada impede que você esteja salvando os resultados intermediários em objetos, de modo a facilitar a leitura do código ao relacionar esses objetos intermediários. Fazer isso funciona bem e eu particularmente utilizo muito. Porém, você também poderá fazer uso de pipes (operador %&gt;%) que poderá, nessas situações, deixar a leitura do código mais fácil, lógica e consequentimente mais compreensível., como veremos adiante. O operador de tubo %&gt;% foi implementando no pacote magrittr por Stefan Milton Bache e atualmente recebe a colaboração de diversas pessoas, incluindo programadores da RStudio, Inc. Atualmente, o pacote não recebe muitas atualizações, muito provavelmente por já está estável e cumprindo bem o seu papel. O nome magrittr muito provavelmente faz alusão à René Magritte, um dos principais pintores surrealista belga, em que a letra r, ao final, obviamente faz referências à linguagem R. É possível inferir isso com base no logo do pacote, apresentado logo abaixo: Figura 5.1: Logo do pacote magrittr com frase Ceci n’est pas une pipe (ouça a pronuncia, mesmo frase que acompanha pintura La trahison des images de René Magritte. Voltemos à algo mais interessante, ao preparo de pães de queijo. O preparo, “em R”, poderia ser quase tão saboroso quanto comer os pães de queijo, se fossem “preparados” utilizando o operador %&gt;%, na forma que segue: # Fazendo pão de queijo utilizando o operador pipe, isto é, # utilizando o operador %&gt;%. ferver(ingradientes = c(leite, água, óleo)) %&gt;% misturar(colher_grande = TRUE) %&gt;% esperar(tempo = 30) %&gt;% despejar(ingredientes = c(&quot;queijo&quot;, &quot;ovos&quot;)) %&gt;% amassar(forma = &quot;mãos&quot;) %&gt;% fazer_bolinhas(volume = 1) %&gt;% sirvir(froma = &quot;quentinho&quot;) É possível observar que o código acima é consideravelmente mais legível que o código apresentado mais acima desta subseção. O código acima é mais legível, por que os verbos/funções são encadeadas na sequência lógica do preparo e não lidos de dentro para fora, como no primeiro exemplo. Olhando rapidamente para cada um dos códigos, percebemos que o código que faz uso do operador %&gt;% fornece mais informações a respeito do que se está à fazer. Importante: Apesar de ser um operador útil, não exagere no uso de %&gt;%, principalmente quando se tem um conjunto de passos demasiadamente grande. Nessas situações, procure atribuir parte do código à objetos intermediários e depois componha esses objetos. Além disso, as funções envolvidas possuem diversas entradas e saídas, pode ser que o uso do operador %&gt;% não seja interessante. No RStudio, você poderá utilizar o atalho Ctrl + Shift + M como atalho para escrever mais rapidamente o operador %&gt;%. Nota: Como curiosidade, o recurso de pipes estão disponíveis em outras linguagens de programação, como F#, e os pielines de sistemas *nix que usa pipes para a comunicação entre os processos utilizando passagem de mensagens. Você poderá instalar o magrittr diretamente pelo CRAN ou por meio do repositório GitHub do pacote, ou seja, por meio de um dos comandos abaixo: # Instalando o pacote magrittr disponível # nos repositórios do CRAN. library(magrittr) # ou # Para instalar pacotes diretamente do GitHub, # você de deve ter instalado o pacote # devtools para poder fazer uso da função # install_github(). # Instalando o repositório magrittr do usuário/organização de # nome tidyverse do GitHub. devtools::install_github(&quot;tidyverse/magrittr&quot;, ref = &quot;master&quot;) Nota: Há pontos positivos e negativos ao considerar a instalação de um pacote diretamente do epositório do pacote no GitHub ou em qualquer outro sistema de hospedagem de código. Mencionarei apenas GitHub, mas o comentário se extende à outros sistemas de hospedagem de códigos, como, por exemplo, o GitLab. Basicamente, o ponto positivo refere-se à possibilidade de estarmos instalando uma versão mais recente do pacote, porém, em alguns casos, o pacote poderá apresentar alguns bugs, muito embora os códigos no branch master são normalmente estáveis e possuem códigos iguais aos que temos no CRAN. Instalar diretamente um pacote que está sendo mantido no GitHub dará a possibilidade de instalar versões mais recentes do pacote que ainda não encontram-se no CRAN. Pelo GitHub, você também terá a vantagem de instalar versões mais antigas do pacote. Por exemplo, no repositório do magrittr, no GitHub, você verá que, em Branch, haverá diversas versões versionadas do pacote, em que uma delas chama-se dev. Fazer devtools::install_github(\"tidyverse/magrittr\", ref = \"dev\") fará com que você instale a versão de desenvolvimento do pacote. Dessa forma, aconselho que sempre considere a instalação da versão no branch master de qualquer pacote que venha instalar diretamente do GitHub. Assim, haverá menos possibilidade de você deparar-se com códigos que ainda não funcionam ou que possuam algum(s) bug(s). Para um entendimento geral do operador %&gt;%, considere a existência dos objetos x, ye f. Então, x %&gt;% f(y) irá atribuir o objeto x à f, como primeiro argumento da função f, ou seja, será equivalente à fazer f(x, y). Porém, nem sempre desejamos introduzir o que está a esquerda do operador %&gt;% como primeiro agumento daquilo que está à sua direita. Para isso, poderemos fazer uso do caracter . (ponto). Esse caracter irá designar em qual posição será introduzido o objeto à esquerda de %&gt;% na função à sua direita. Por exemplo, a expressão x %&gt;% f(a, b = .) fará com que x à esqueda de %&gt;% seja substituído no lugar do caracter ., ou seja, x é passado como argumento à b, segundo argumento de f. Exemplo: Uso do caracter . em um contexto de bloco de instrução. Esse exemplo mostra que o que está a direita do operador %&gt;% não necessariamente precisa ser uma função. Nesses casos, o caracter . é de grande importância para que o operador saiba substituir corretamente o objeto x no bloco de instruções. library(magrittr) x &lt;- mtcars x %&gt;% { if (is.data.frame(.) || is.matrix(.)){ cat(&quot;A dimensão dos dados é&quot;, dim(.)) } else { cat(&quot;Objeto não é uma matriz ou um data frame&quot;) } } ## A dimensão dos dados é 32 11 Nota: Observe que, por exemplo, fazer x %&gt;% f(., y = 1) equivale a fazer x %&gt;% f(y = 1), uma vez que por padrão, o objeto que está à esquerda de %&gt;%sempre será substituído como primeiro argumento da função que está mais a sua direta, caso não seja utilizado o caractere . para indicar o lugar do substituição. Um outro operador útil disponível no pacote magrittr é o operator tee, denotado por %T&gt;%. Esse operador funciona de forma muito parecida com o operador %&gt;%, exceto pelo fato de que ele irá retornar o conteúdo do lado esquedo e não o resultado da operação do seu lado diretio. O uso do operador %T&gt;% não é tão comum. Normalmente a frequência de uso do operador %&gt;% é muito maior. Porém, veja que não é possível resolver o exemplo que segue utilizando apenas o operador %&gt;%. Exemplo: Pelo que entendemos do operador %&gt;%, não faz nenhum sentido o código abaixo: # Fixando uma semente. set.seed(0) rnorm(1000L) %&gt;% hist(., main = &quot;Histograma Qualquer&quot;, xlab = &quot;x&quot;, ylab = &quot;Frequência&quot;, col = rgb(1, 0.9, 0.8), border = NA) %&gt;% mean ## Warning in mean.default(.): argumento não é numérico nem lógico: retornando ## NA ## [1] NA Nesse exemplo, observamos que o histograma foi construído, porém, não faz nenhum sentido passar um gráfico à função mean. Muito provavelmente o desejo de quem viria escrever um código como esse seria tirar a média do vetor resultante do código rnorm(1000L). Nessas situações, poderemos fazer uso do operador %T&gt;% (operador tee). Exemplo: Aqui temos um típico uso do operador %T&gt;%. Perceba que utilizando o perador %T&gt;%, foi possível passar rnorm(1000L) como argumento à função hist, assim como seria possível utilizando o operador %&gt;%. Porém, com o operador %T&gt;%, conseguimos passar rnorm(1000L) à função mean e não à função hist, que seria esperado se utilizássemos o operador %&gt;%. # Fixando uma semente. set.seed(0) rnorm(1000L) %T&gt;% hist(., main = &quot;Histograma Qualquer&quot;, xlab = &quot;x&quot;, ylab = &quot;Frequência&quot;, col = rgb(1, 0.9, 0.8), border = NA) %&gt;% mean ## [1] -0.01582957 Um outro operador pipe que é bastante útil é o perador de exposição, denotado por %$%. Trata-se de um operador que é bastante útil quando estamos trabalhando com (quadro de dados) data frames ou matrizes, onde temos variáveis dispostas em suas colunas. Com esse operador, poderemos tornar visíveis as variáveis do objeto à sua esquerda nas funções à sua direita. Considere o exemplo que segue: Exemplo: No código que segue, estamos tornando visíveis as variáveis do objeto mtcars na função cor. Dessa forma, poderemos calcular a correlação entre as variáveis cyl e hp do data frame mtcars. mtcars %$% cor(cyl, hp) ## [1] 0.8324475 Nota: Normalmente esse operador é útil quando a função a direita não possui argumento de dados. Por exemplo, se o objetivo fosse calcular uma regressão linear simples com essas variáveis, poderíamos fazer: mtcars %&gt;% lm(cyl ~ hp, data = .) ## ## Call: ## lm(formula = cyl ~ hp, data = .) ## ## Coefficients: ## (Intercept) hp ## 3.00680 0.02168 uma vez que a função lm já possui um argumento para o conjunto de dados a ser utilizado. Ao passar o conjunto de dados para a função lm, todas as variáveis de mtcars estarão visíveis no interior da função lm. Por fim e não menos importante, existe o operador de pipe compostos, denotado por %&lt;&gt;%. Esse operador é útil quando queremos realizar uma operação e atribuir essa modificação ao objeto à esquerda do operador. Considere um exemplo de uso do operador de pipe composto: Exemplo: Utilizando o operador %&lt;&gt;% para alterar o conteúdo da variável disp do data frame mtcars. Perceba que ao chamar mtcars, a variável disp agora é do tipo inteiro. mtcars$disp %&lt;&gt;% as.integer() str(mtcars) ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: int 160 160 108 258 360 225 360 146 140 167 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... Observação: Alguns pacotes de R possuem vinhetas que facilitam o entendimento das funções empacotadas. Não necessariamente as vinhetas irão dissertar sobre todas as funções implementadas. Porém, essas vinhetas normalmente focam no que há de mais importante no pacote. Você poderá encontrar a vinheta do pacote magrittr aqui. Normalmente essas vinhetas são mais fáceis de serem lidas do que as documentações dos pacotes. Porém, consultar a documentação é o caminho correto para encontrar as respostas mais difícies e que muitas vezes não são abordadas nas vinhetas. Exercícios Resolva os exercícios que seguem. Os operadores pipes que você utilizará para resolver os exercícios não necessariamente irão produzir as melhores soluções. Porém, esses exercícios farão você pensar a respeito do emprego dos operadores e, aqui, é isso o que importará. Resolva os itens abaixo utilizando o operador %&gt;% do pacote magrittr: as.character(log(cos(sin(pi)))) round(var(seq(from = 1, to = 10, by = 0.5)), digits = 1) summary(anova(lm(mpg ~ wt, data = mtcars))) summary(lm(dist ~ log(accel), data = na.omit(attenu))) Sem salvar objetos intermediários, utilize operadore(s) pipe(s) para reescrever o código abaixo: dados &lt;- subset(iris, Sepal.Length &gt; mean(Sepal.Length)) cor(dados$Sepal.Length, dados$Sepal.Width) Sem salvar objetos intermediários, utilize operadore(s) pipe(s) para reescrever o código abaixo: vetor &lt;- 1:10 plot(matrix(data = vetor, ncol = 5, nrow = 5)) quantil &lt;- quantile(vetor) print(quantil) Sem fazer uso dos operadores de atribuições &lt;- ou =, reescreva o código abaixo usando operadore(s) pipe(s): mtcars &lt;- transform(mtcars, cyl = cyl * 2) Considere o código abaixo que faz uso do operador %&gt;%. Dica: busque nas documentações do pacote magrittr, o uso das funções subtract e divide_by. O que esse código faz? Reescreva-o sem fazer uso do operador %&gt;%. vetor &lt;- c(1.7, 2.74, 5.66, 8.13, 4.04) vetor %&lt;&gt;% subtract(., mean(.)) vetor %&gt;% divide_by(., sd(.)) Considere o código abaixo e reescreva-o utilizando o operador %&gt;% sem utilizar de passos intermediários. Dica: Procure identificar o uso da função extract do pacote magrittr. # Essa função não deverá entrar no pipe. set.seed(0) x &lt;- runif(n = 100, min = 0, max = 100) x &lt;- x[x &gt; 10 &amp; x &lt; 30] round(mean(x), digits = 1) Reescreva o código abaixo utilizando o operador pipe %&gt;%. dados &lt;- subset(iris, Sepal.Length &gt; 5) aggregate(Sepal.Length ~ Species, dados, FUN = mean) Tente reescrever o código apenas utilizando o operador %&gt;%e depois modifique-o para utilizar o operador de exposição %$%. Dica: procure entender o emprego das funções subset e aggregate, funções dos pacotes base e stats, respectivamente. Estude a vinheta do pacote magrittr. Acesse a vinheta aqui. Explique o que o código abaixo faz: f &lt;- . %&gt;% subtract(., mean(.)) %&gt;% divide_by(., sd(.)) Use o que aprendeu ao resolver o exercício anterior para reescrever o código abaixo usando pipes: vetor &lt;- c(1.7, 2.74, 5.66, 8.13, 4.04) sum(x - mean(x))/sd(x) 5.2 Funções Como já sabemos, uma vez que você deve ter utilizado bastante o confeito de funções ao resolver os exercícios sugeridos, funções são objetos que recebe uma ou algumas entradas, as processas em seu interior e te retorna uma ou mais saída(s). O diagrama 5.2 mostra um comportamento genérico de uma função qualquer (function) que recebe uma quantidade arbitrária de argumentos, com estruturas de dados distintas, e retorna também uma quantidade arbitrária de informações, objetos com estruturas de dados distintas: Figura 5.2: Comportamento genérico da função de nome function que recebe diversos argumentos com estruturas de dados distintas e retorna diversos diversos objetos com estuturas de dados distintas. Note que new structure, no diagrama, deixa claro que o programador poderá criar suas novas estruturas de dados que poderão ser passadas e/ou retornadas por uma função. Importante: Algo que torma uma função bastante flexível é a capacidade de podermos passar funções como argumentos à outras funções. Muito embora esse fato não esteja destacado no diagrama acima, nunca se esqueça que, em R, você facilmente poderá passar uma função como argumento de uma outra função. Exemplo: round(sum(c(1.73, 2.47, 7.21, 8.74, NA), na.rm = TRUE), digits = 1) Uma função em R é dividida em três partes: Lista de Argumentos: Conjunto de argumentos, podendo ter as mais variadas estruras de dados que pode inclusive alterar o comportamento da função. Corpo: Código no interior da função que será capas de processar e tomar decisões de acordo com sua lista de argumentos. Ambiente: Os ambientes (environment) de reconhecimentos de objetos no interior da função. Isso permite que possamos ter objetos com o mesmo nome referindo-se à conteúdos distintos na memória do computador. Como já sabemos, mas irei repetir, a forma geral de implementação de uma função é: f &lt;- function(argumentos){ # Aqui é onde as coisas acontecem. corpo } # Fim da função. Poderemos identificar essas três partes de uma função utilizando as funções formals(), body() e environment(). Por exemplo, considere a função abaixo: f &lt;- function(x, y){ `+`(x,y) } # Lista de argumentos. formals(f) ## $x ## ## ## $y # Corpo da função. body(f) ## { ## x + y ## } # Ambiente que a função foi definida. environment(f) ## &lt;environment: R_GlobalEnv&gt; Além disso, lembre-se que funções podem ter argumentos com valores já pré-definidos, como é o caso de f() no código que segue: f &lt;- function(x = 1, y = 2){ x + y } f(5) ## [1] 7 f(2,4) ## [1] 6 5.2.1 Passando atributos Uma função em R é um objeto qualquer. Dessa forma, assim como qualquer objeto, uma função poderá carregar consigo uma quantidade qualquer de atributos que podem ser recuperados e utilizados a qualquer momento. Considere os códigos que seguem: # Vetor com valores inteiros em memória de 1 à 10. x &lt;- 1L:10L # Introduzindo dois argumentos ao objeto x. # Primeiro argumento: desc, que apresenta uma pequena descrição do objeto x. # Segundo argumento: M, uma matriz qualquer que poderia vir a ser útil guardar. attr(x = x, which = &quot;desc&quot;) &lt;- &quot;vetor com valores inteiros&quot; attr(x = x, which = &quot;M&quot;) &lt;- matrix(data = c(1, 7, 3, 8), ncol = 2, nrow = 2) Note que agora o objeto x carrega não apenas os valores inteiros de 1 a 10. Foram acrescentados dois argumentos à x, são eles, desc que contém uma string descrevendo o que é o objeto x. Perceba que os atributos não afetam as operações que realizamos com x, mas poderemos, se desejarmos, acessar os atributos e trabalharmos com eles, como postra o trecho de código abaixo: # Os atributos não irão afetar as operações realizadas # considerando o objeto x. sum(x + 1) ## [1] 65 # Listando os atributos do objeto x: attributes(x) ## $desc ## [1] &quot;vetor com valores inteiros&quot; ## ## $M ## [,1] [,2] ## [1,] 1 3 ## [2,] 7 8 # Acessando o atributo de nome M (uma matriz) # e invertendo. solve(attr(x, &quot;M&quot;)) ## [,1] [,2] ## [1,] -0.6153846 0.23076923 ## [2,] 0.5384615 -0.07692308 Como é possível introduzir atributos à qualquer objeto em R, e funções são objetos, então considerre o trecho de código que segue, em que é introduzido o atributo M do objeto x como atributo da função f() abaixo: # Retorna os caracteres &quot;-&quot;, &quot;0&quot;, &quot;+&quot; # a depender do valor informado. f &lt;- function(x){ # x é um objeto numérico. if (x == 0) &quot;0&quot; else ifelse(x &gt; 0, &quot;+&quot;, &quot;-&quot;) } # Introduzindo o atributo de nome desc que contém uma breve descrição da # função f(): attr(f, &quot;desc&quot;) &lt;- &quot;retorna -, 0 ou +, a depender do valor passado à x&quot; # Acessando o conteúdo do atributo desc: attr(f, &quot;desc&quot;) ## [1] &quot;retorna -, 0 ou +, a depender do valor passado à x&quot; Sabemos que o uso da função body() permete-nos acessar o corpo de uma função (código da função). Porém, você apenas irá visualizar as partes do código que foram implementadas estritamente em R. Por exemplo, no trecho de código abaixo é apresentado o sudo da função body() sobre uma função implementada em R e outra função que tem o seu código implementado em uma linguagem de mais baixo nível: # Acessando o corpo da fução rm(): body(ls) # Tentando acessar o corpo da função sum(): body(sum) Note que foi possível acessar parte do conteúdo, implementado em R, da função rm(). Porém, no caso da função sum() o retorno foi NULL, uma vez que essa função é por completo implementada em uma linguagem de mais baixo nível. Isso se deve ao fato de que essas funções foram escritas em linguagens compiladas como o caso de C/C++, camhando assim um código objeto e não um código fonte. Em muitas situações desejamos passar uma função como argumento à outra função. O trecho de código abaixo cria duas simples funções, f() e g(), em que passamos f() como argumento à função g(): # As funções não necessariamente necessitam ter argumentos. f &lt;- function(){ &quot;Olá&quot; } g &lt;- function(func){ paste(func, &quot;mundo&quot;, sep = &quot; &quot;) } # Passando a função f() como argumento da função g(): g(func = f()) ## [1] &quot;Olá mundo&quot; # Compondo as funçoes nchar(), g() e f(). # A função nchar() retorna a quantidade de caracteres # na estring retornada por g(). nchar(g(func = f())) ## [1] 9 5.2.2 Funções anônimas Algo que é bastante útil quando estamos trabalhando com funções é a possibilidade de não nomear uma função. Essa estratégia é interessante quando temos funções curtas que não queremos nos dar o trabalho de pensarmos em um nome. Normalmente, aplica-se à casos de funções curtas que são passadas como argumento à outras funções. O trecho de código que segue apresenta o uso de uma função anônima passada como argumento à função integrate() de R: # Passando a função anônima function(x) x ^ 2 como argumento da # função integrate(). integrate(function(x) x ^ 2, lower = 0, upper = 2)$value ## [1] 2.666667 Não esqueça que, em muitos casos, compor funções utilizando o operador %&gt;% pode ser interessante. As composições acimas poderiam ser realizadas da forma que segue: # Primeira composição utilizando o operador %&gt;%: f %&gt;% g %&gt;% nchar # Segunda composição utulizando os operadores pipes %&gt;% e %$%: (function(x) x^2) %&gt;% integrate(lower = 0, upper = 2) %$% value Nota: Utilizar os operadores pipes pode ser interessante quando estamos a fazer uma análise de dados, em que queremos deixar claro uma sequência lógica de operações. Porém, note que pipes não irão tornar o seu código mais eficientes do ponto de vista computacional, nem o contrário, ou seja, utilizar pipes não irão tornar os seus códigos menos eficientes. 5.2.3 Escopo léxico Em computação, o escopo é o que delimita a relação de objetos e expressões, ou seja, em que partes do código um ou mais objetos são reconhecidos por uma dada expressão ou conjunto de expressões. Na maioria das linguagens de programção o escopo é léxico, também chamado de escopo estático, uma vez que podem ser delimitados estaticamente, antes da execução do programa por meio da sintaxe da linguagem, ou seja, por meio da estrutura léxica da linguagem. A linguagem R tem escopo léxico, assim como diversas outras linguagens de programação. Trata-se de tipo de escopo comum em linguagens como Pascal, C, C++, Ada, Go, Haskell, R, Julia, Python, Ruby, entre diversas outras. Considere o exemplo apresentado no código abaixo: x &lt;- &quot;fora&quot; f &lt;- function(){ x &lt;- &quot;dentro&quot; x }; f() ## [1] &quot;dentro&quot; Para quem já programa um pouco em R, o retorno da função f() era esperado, uma vez que olhando para o código, entendemos facilmente qual a saída, uma vez que a sintaxe nos acusa (escopo léxico). Na verdade, o termo vem de lexing, que refere-se ao processo de conversão de partes significativas do código intendíveis para o interpretador. Existem linguagens que fazem uso de escopo dinâmico, como é o caso do Emacs Lisp, shell Bash, LaTeX (linguagem de marcação), entre outras. Como esse não é o caso da linguagem R que frequentemente nos deparamos em R, aqui não é o lugar para dissertar em relação à esse assunto. No código acima, perceba que havia um objeto x definido no interior da função. Dessa forma, o retorno da função buscará por referências à x no mesmo escopo da função, isto é, irá considerar x definido por x &lt;- \"dentro\". Porém, considere a simples modificação do código na forma que segue: x &lt;- &quot;fora&quot; f &lt;- function(){ x }; f() ## [1] &quot;fora&quot; No código acima, a função f() não pode encontrar referências ao objeto x no interior da função. Dessa forma, R considerar-a o objeto x no respectivo escopo mais externo, que nesse caso é o objeto x definido por x &lt;- \"fora\". Esse comportamento é válido se consideramos estruturas mais aninhadas, como a que é apresentada no código que segue: x &lt;- &quot;estou fora de f&quot; f &lt;- function(){ # Podemos definir funções dentro de funções. g &lt;- function(){ x } # fim da função interna list(g = g(), x = x) } # fim da função externa f() ## $g ## [1] &quot;estou fora de f&quot; ## ## $x ## [1] &quot;estou fora de f&quot; Perceba que tanto o retorno da função g() quando o objeto x da função f() referem-se ao valor de x definido fora do escopo da função f(). Isso se deve ao fato da linguagem R procurar um objeto de nome x de froma sucessivas, partindo do escopo ao qual o objeto é invocado à escopos em níveis mais externos. No código acima, tanto g() definida dentro de f() quanto a prórpia função f() apenas encontrará referência à x no ambiente mais externo, isto é, será considerado o objeto x definido por x &lt;- \"estou fora de f\". Algo interessante de se observar é que muito embora o R procure em escopos mais externos a primeira referência ao objeto que invocamos em um escopo mais interno, escopo este em que não há nenhuma referência à este objeto, em futuras invocações da função, a partir da segunda chamada, o objeto x já encontra-se definido no interior da função f(). x &lt;- 0 f &lt;- function(){ # x encontra-se definido no escopo externo na primeira chamada à # função f. x &lt;- x + 1 x } f() ## [1] 1 f() ## [1] 1 Observe que mesmo que você chame por diversas vezes consecutivas a função f() o retorno sempre será 1. Para ser possível obter somas em 1 iterativas, uma solução para esse problema seria fazer uso do operador de atribuição profunda, denotado por &lt;&lt;-. Esse operador permite que as alterações no objeto x ocorra no primeiro escopo mais abrangente que faz referência à um objeto x. Considere o trecho de código que segue: x &lt;- 0 f &lt;- function(){ # x encontra-se definido no escopo externo na primeira chamada à # função f. x &lt;&lt;- x + 1 # Operador de atribuição profunda. x } f() ## [1] 1 f() ## [1] 2 Porém, perceba o resultado que segue: x &lt;- 0 f &lt;- function(){ x = 7 x &lt;&lt;- x + 1 # Operador de atribuição profunda. x } f() ## [1] 7 x ## [1] 8 Note no código acima que o valor retornado pela função é 7 (sempre) e não 8, como alguns poderiam esperar. Perceba que isso se deve ao fato de que no interior de f(), sempre teremos que x ao lado direito do operador &lt;&lt;- será 7, uma vez que em todas as chamadas, há dentro da função f() a definição de x = 7. Isso também implicará que o valor de x do lado esquerdo do operador &lt;&lt;- sempre será atualizado para 8, em todas as chamadas. Veja que x ao lado esquerdo de &lt;&lt;- refere-se ao objeto x no escopo mais extero ao escopo de x no interior da função. Observação: Em R, os operadores &lt;- e &lt;&lt;- também informam o sentido da atribuição, que normalmente é da direita para a esquerda, assim como ocorre ao considerar o operador =. Quase sempre as atribuições são da esquerda para a direita, com exceção das situações em que invertemos os sentidos dos operadores &lt;- e &lt;&lt;-, isto é, quando consideramos as variantes -&gt; e -&gt;&gt;, respectivamente. Exemplo: f &lt;- function(){ 2 -&gt; x x * 2 -&gt;&gt; x x } f(); x ## [1] 2 ## [1] 4 5.2.4 Avaliação preguiçosa Tecnicamente, os argumentos de uma função são promessas promises e fazem parte do mecanismo de (lazy evaluation). Quando uma função é chamada, cada um de seus argumentos formais são vinculados à uma promessa. Dessa forma, cada promessa, para cada um dos argumentos, armazenam a expressão do argumento e um ponteiro para o ambiente ao qual a função foi chamada. Tais promessas não armazenam nenhum valor, até o momento em que o argumento seja necessário para a função. Sendo assim, (promises) trata-se de uma estrutura de dados. Promisses possuem: Um ambiente: ambiente em que uma função é avaliada/invocada. Uma expressão: uma expressão válida passada para um argumento de uma função; Um valor: resultado da avaliação de uma expressão em um ambiente específico. Em R, os argumentos de uma função são avaliados de forma preguiçosa (lazy evaluation), são apenas promessas, ou seja, só serão avaliados na necessidade de uso do parâmetro. Em outras palavras, um parâmetro poderá eventualmente nunca ser avaliado quando uma função é executada. Considere o código que segue: # A função f() tem o argumento x que # não é utilizado. f &lt;- function(x){ y &lt;- 1 y } f() ## [1] 1 Como é possível observar, a função f() possui x como argumento, argumento este que em nenhum momento é utilizado. Dessa forma, mesmo que x não esteja definido, não teremos como retorno um erro ao executar f(). Isso se deve ao fato de que argumentos de funções, em R, são avaliados de forma preguiçosa. Um dos grandes benefícios da avaliação preguiçosa é a possibilidade que temos de atrasar a computação, de modo que um dos argumentos poderá conter cálculos intensivos que só será avaliado se necessário. Dessa forma, devido a possibilidade de uma função matemática poder ser passado como argumento à uma funçãom, que ventualmente pode ser algo custoso do ponto de vista computacional, lazy evaluation é o padrão da linguagem. Importante: Como estamos a falar de argumeto de funções, destaco algo importante da linguagem R. Ao se utilizar o operador &lt;- para realizar uma atribuição em uma chamada de função, a variável é ligada fora da função, ou seja, no ambiente em que a função é chamada, como mostra o exemplo que segue: Exemplo: y &lt;- 0 f &lt;- function(x){ y &lt;- 2 x + 1 } f(y &lt;- 7) ## [1] 8 y ## [1] 7 Perceba que fazer f(y = 7) retornará um erro, uma vez que R entende que estamos passando o valor 7 à um argumento y que não existe em f(). Note que f(y &lt;- 7) é equivalente a escrever f(x = y &lt;- 7) ou f(x = (y = 7)). Porém, ao utilizarmos o operador &lt;-, além de passarmos os argumentos à f() estamos também criando os objetos à esquerda do operador fora da função. 5.2.5 varargs: … (dot-dot-dot) Algo bastante útil e que torna flexível uma linguagem de programação é a possibilidade de escrever funções com quantidade variádicas de argumentos, isto é, funções varargs. Em R isso é possível especificando o argumento especial ... (dot-dot-dot), ou ponto-ponto-ponto, em português. Um uso comum do operador ... é a possibilidade de passarmos argumentos adicionais para uma função que utilizamos em nossa implementação. Por exmeplo, considere o código abaixo: # Fixando uma semente para gerarmos sempre a mesma amostra. set.seed(0) # Gerando um conjunto de dados com distribuição normal padrão. data &lt;- rnorm(n = 100, mean = 0, sd = 1) myhist &lt;- function(x = data, ...){ # Perceba o uso de ... em hist(): result &lt;- hist(x, ...) list(n = length(result$counts), counts = result$counts) } # A função myhist() não possuia a definição dos argumentos col, # main, ylab e border. myhist(x = data, col = rgb(1, 0.9, 0.8), main = &quot;&quot;, ylab = &quot;Frequência&quot;, border = NA) ## $n ## [1] 10 ## ## $counts ## [1] 1 2 8 15 26 19 14 12 1 2 A função myhist(), implementada acima, constroi um histograma com base em um vetor de dados passado como argumento à x, retornando uma lista com o número de classes e a quantidade de observações da amostra, em cada uma das classes. Note que myhist() possui apenas dois argumentos, x e ..., respectivamente. O argumento especial ... permite que myhist() herde todos argumentos da função hist(). Asim, muito embora a função myhist() não possui os argumentos col, main, ylabe border definidos formalmente, poderemos ascessar esses e os demais argumentos de hist() mesmo sem defini-los. Nas situações em que desejarmos acessar os elementos passados à ... por suas posições, poderemos fazer uso da notação especial ..1, ..2, etc. Considere o trecho de código que segue: f &lt;- function(...){ n &lt;- ...length() if (n != 3) stop(&quot;A função deve ter exatamente 3 argumentos.&quot;) else for(i in 1:...length()){ cat(&quot;O elemento &quot;, i, &quot; de \\&quot;...\\&quot; é: &quot;, ...elt(i), &quot;\\n&quot;) } return(..1 * ..2 + ..3) } f(2, 3, 1) ## O elemento 1 de &quot;...&quot; é: 2 ## O elemento 2 de &quot;...&quot; é: 3 ## O elemento 3 de &quot;...&quot; é: 1 ## [1] 7 Note que a função f() retorna o produto do primeiro com o segundo argumento e soma com o terceiro. Além disso, foram utilizadas as funções ...length() que retorna o tamanho de ... e ...elt(i) que equivale à ..i. A função ...elt(i) nada mais é do que fazer eval(paste0(\"..\", n)). Como dito, uma das grandes vantagens do uso de ... é a possibilidade de passarmos argumento de outras funções que estão sendo utilizadas pela função que estamos a implementar. O uso de funções varargs destacam-se também em situações em que fazemos uso de programação orientada à objeto por função genérica, sistema de orientação à objeto conhecido, em R, como sistema S3 de orientação à objeto e que estudaremos mais a frente. Considerando o sistema S3 de orientação à objeto, note que funções como summary() e print() podem ser utilizadas em diversas situações e que muito provavelmente terão argumentos distintos em cada uma dessas circunstâncias. A capacidade de uma função ter várias formas e se adequar a cada uma delas está fortemente relacionada com a definição de funções polimórficas, uma das principais características do paradigma de programação orientada à objeto e que está intimamente relacionadas com funções varargs, principalmente no sistema S3. Perceba que diversas funções R são varargs, por exemplos, a função sum(). Note, no trecho de código abaixo, que a característica de lazy evaluation quando associada à uma função com um número arbitrário de argumentos poderá retornar algo equivocado e nenhum erro é dado para nos alertarmos de um possível problema: sum(1:5, NA, narm = TRUE) ## [1] NA Para o código acima, gostaríamos que o equívoco a respeito do nome correto do argumento (na.rm) não tivesse ocorrido. Aqui, nosso interesse seria fazer: sum(1:5, NA, na.rm = TRUE) ## [1] 15 Nota: Um outro inconveniente de construir funções varargs além dos equívocos desarpesebidos quando erramos algum de seus arugmentos é que essas funções normalmente são um pouco mais complicadas de serem documentadas, visto que devemos ter um grande cuidado ao deixar claro como os argumentos serão substituídos e utilizados. Esses problemas não são suficientes justificar um desaconselho do uso de funções varargs. Na verdade é muito importante a construção de funções varargs e você deve utilizar, sempre que puder e na medida da necessidade, uma vez que isto tornará suas funções bastante flexíveis. 5.2.6 Funções infixas Para começarmos a falar de funções infixas (infix), os slogans abaixo, traduzidos para o português, poderão ser úteis para um melhor entendimento: \"Para entender a computação em R, dois slogans são úteis: Tudo o que existe é um objeto. Tudo o que acontece é uma chamada de função.\" — John M. Chambers, no artigo intitulado Object-Oriented Programming, Functional Programming and R, Statistical Science, Vol. 29, 2014, p. 170. Nas situações de funções que possuem dois argumentos, construir um operador infixo pode ser de grande utilidade. O exemplo abaixo mostra duas formas de somarmos dois termos utilizando a função `+` e o operador infixo +, respectivamente. Perceba que a segunda forma é mais conveniente que a primeira: x &lt;- y &lt;- 1 # Forma 1 (prefix): `+`(x, y) ## [1] 2 # Forma 2 (infix): x + y ## [1] 2 Além dos operadores matemáticos +, -, * e / serem funções infixas, podendo também chamar de operadores infixos ou infix, diversas outras funções são infixas, como por exemplo, ^, ::, &amp;, |, &amp;&amp;, ||, &lt;=, &gt;=, &lt;, &gt;, ==, !=, $, %%, %*%, %in%, &lt;-, &lt;&lt;-, entre diversas outras funções. O exemplo abaixo apreseta o uso de algumas dessas funções na forma prefixa: `&lt;=`(1,3) ## [1] TRUE `^`(2,3) ## [1] 8 x &lt;- list(a = 1, b = 2) `$`(x, a) ## [1] 1 Assim como existem diversas funções infixas em R previamente implementadas, também poderemos construir nossas funções infixas. Para tanto, basta considerarmos a notação %nome%, em que nome deverá ser substituído por um nome válido de função. Considere o código abaixo: `%+%` &lt;- function(x, n){ rep(x, times = n) } # Forma prefixa: `%+%`(&quot;infix&quot;, 4) ## [1] &quot;infix&quot; &quot;infix&quot; &quot;infix&quot; &quot;infix&quot; # Forma infixa: &quot;infix&quot; %+% 4 ## [1] &quot;infix&quot; &quot;infix&quot; &quot;infix&quot; &quot;infix&quot; 5.2.7 Função de substituição Você muito provavelmente já deve ter feito uso de funções de substituição, como por exemplo, names(), colnames(), rownames(), entre outras funções. Essas são chamadas de funções de substituição devido ao comportamento que é expresso no código que segue: vetor &lt;- c(1,2,3) names(vetor) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) x ## $a ## [1] 1 ## ## $b ## [1] 2 A função names(), para produzir o mesmo resultado do código acima, poderia ser invocada na foma que segue: vetor &lt;- c(1,2,3) `names&lt;-`(x = vetor, value = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## a b c ## 1 2 3 Pelo código acima podemos perceber que as funções de substituição nada mais são que funções de dois argumentos, a saber x e value, respectivamente. Dessa forma, os valores passados à value modificam o objeto x que nesse caso são os nomes do objeto vetor. Exemplo: Implementação da função de substituição samenames() que atribui o mesmo nome à todos elementos do vetor x. `samenames&lt;-` &lt;- function(x, value){ if (length(value) != 1) stop(&quot;Um vetor de comprimento 1 deverá ser atribuído.&quot;) else{ names(x) &lt;- rep(value, times = length(x)) } x } x &lt;- 1L:10L samenames(x) &lt;- &quot;a&quot; x ## a a a a a a a a a a ## 1 2 3 4 5 6 7 8 9 10 Em situações em que a função de substituição necessita de mais argumentos além dos argumentos obrigatórios x e value, deveremos colocá-los entre os argumentos x e value. No exemplo do código abaixo introduzimos o argumento rm.id em que, se desejarmos, poderemos omitir algumas posições do vetor x: `samenames&lt;-` &lt;- function(x, rm.id = NULL, value){ if (length(value) != 1) stop(&quot;Um vetor de comprimento 1 deverá ser atribuído.&quot;) else if (!is.null(rm.id) &amp;&amp; is.numeric(rm.id)){ x &lt;- x[-rm.id] names(x) &lt;- rep(value, times = length(x)) }else{ names(x) &lt;- rep(value, times = length(x)) } x } x &lt;- 1L:10L samenames(x) &lt;- &quot;a&quot; # Removendo a primeira e a décima posição de x. samenames(x, c(1,10)) &lt;- &quot;a&quot; x ## a a a a a a a a ## 2 3 4 5 6 7 8 9 Observação: A linguagem R possui diversos outros recursos, escritos em forma especial, que também são funções. Abaixo pontuarei alguns desses recursos, para que você tenha uma ideia, porém, existem mais: (x) com representação prefixa dada por `(`(x); x[i] com representação prefixa dada por `[`(x, i); x[[i]] com representação prefixa dada por `[[`(x, i); {x} com representação prefixa dada por `{`(x); if(condicao) com representação prefixa dada por `if`(condicao, se_verdade, se_falso); for(variável in conjunto) ação com representação prefixa dada por `for`(variável, conjunto, ação); while(condição) ação com representação prefixa dada por `while`(cond, action). 5.2.8 Closures Como já sabemos, uma utilidade comum de funções anônimas está em criar pequenas funções que não vale a pena nomear. Normalmente são funções pequenas que são passadas como argumento à outras funções, fornecendo assim menos ruídos visuais no código e nos livrando da necessidade de pensarmos em um bom nome para a função. Um outro importante uso de funções anônimas está na necessidade closures. O conceito de closures surgiu na década de 1960 para avaliação de expressões no \\(\\lambda\\)-calculus (um sistema formal na lógica matemática para representar a computação com base na abstração de funções) e teve sua primeira implementação computacional em 1970 como um recurso da linguagem de programação PAL. Com o passar dos anos, diversas linguagens de programação permitiram o uso de closures, um recurso de programação muito utilizado quando necessitamos criar funções escritas por outras funções: Nota: Closure possui esse nome por se tratar de uma função que encerra o seu ambiente, passando seus parâmetros para o ambiente da função mais interna, função esta que será retornada e que executará o trabalho desejado. O trecho de código abaixo exemplifica o uso de closure, em que a função potencia() (função pai) poderá gerar novas funções de interesse, cujo trabalho será executado pela função anônima interna à função potencia(). Por exemplo, poderemos criar os objetos quadrado e cubo que serão as funções quadrado() e cubo(), respectivamente, sem a necessidade de implementar cada uma dessas funções. potencia &lt;- function(expoente) { # Função anônima. function(x) { x ^ expoente } } # Criando as funções quandrado() e cubo(). quadrado &lt;- potencia(2) cubo &lt;- potencia(3) # Utilizando as funções criadas pela função potencia(): quadrado(2) ## [1] 4 cubo(3) ## [1] 27 Importante: Perceba que as funções quadrado() e cubo() não foram implementadas diretamente. Além disso, nesse caso, note essas funções retornadas aos objetos quadrado e cubo são funções que possuem x como argumento que era argumento da função anônima. Exercícios Quais são os três componentes de uma função? Contrua o objeto y que retorne a saída abaixo: ## [1] 1 2 3 4 5 6 7 8 9 10 ## attr(,&quot;att_1&quot;) ## [1] &quot;Isso é um atributo&quot; Remova o atributo att_1 do objeto y acima. O que o código abaixo retorna? Explique. Dica: para certificar-se que esteja entendendo, tente prever sem executar a função. f &lt;- function(x){ f &lt;- function(x){ f &lt;- function(x){ x * 3 } f(x) * 2 } f(x) + 1 } f(7) O que o código abaixo retorna? Explique. Dica: para certificar-se que esteja entendendo, tente prever sem executar a função. x &lt;- 1 f &lt;- function() { x &lt;- 0 x &lt;&lt;- x + 1 x } f(); x O que o código abaixo retorna? Dica: para certificar-se que esteja entendendo, tente prever sem executar a função. f &lt;- function(){ y &lt;- 0 g &lt;- function(){ y &lt;&lt;- y + 1 } list(rep(x = g(), times = y), rep(x = g(), times = y), rep(x = g(), times = y)) } Implemente a função %+% que concatena duas strings. Permita que, por meio do uso prefixo da função, o usuário possa informar o caractere que separa as duas strings. Abaixo encontra-se um exemplo do uso infixo da função. &quot;Estatística&quot; %+% &quot;Computacional&quot; ## [1] &quot;Estatística Computacional&quot; Implemente a função segundo que trabalhe da seguinte forma: x &lt;- 1:10 segundo(x) &lt;- 5 x ## [1] 1 5 3 4 5 6 7 8 9 10 Implemente a função troca() que trabalhe da forma abaixo: x &lt;- 1:10 troca(x, 2) &lt;- 7 x ## [1] 1 7 3 4 5 6 7 8 9 10 Qual o retorno da função abaixo? Explique. f &lt;- function(y) { function(x) { x + y } } g &lt;- f(1) g(x = 2) Utilizando o conceito de closure e o operador ... (dot-dot-dot), construa a função cdf_expg(G) que recebe como argumento uma função de distribuição (qualquer), seja ela denotada por \\(G\\). A função cdf_expg(G) deverá retornar a função de distribuição \\(\\mathrm{Exp}-G\\) definida por \\[F(x) = G^a(x),\\] com \\(a &gt; 0\\). Perceba que \\(F\\) é uma nova distribuição de probabilidade com um parâmetro a mais (\\(a &gt; 0\\)) e que possui a distribuição \\(G\\) como caso particular quando \\(a = 1\\). Por exemplo, se cdf_weibull é a implementação da distribuição Weibull, então cdf_expg(G = cdf_weibull) deverá retornar uma função que implementa a distribuição \\(\\mathrm{Exp-Weibull}\\). 5.3 Funcionais Funcionais não são nada a mais que funções que recebe como argumento uma outra função como argumento e retorna um vetor como saída. O trecho de código que segue implementa o funcional f(), retornando um vetor como saída: # A função f() é um funcional. f &lt;- function(x, func) func(x) # Passando uma função à f() por meio do argumento func. # Foi passado à func uma função anônima. f(x = c(1, 2, 7, 10), func = function(x) x + 1) ## [1] 2 3 8 11 Perceba que a função f() é um funcional, visto que f() recebe uma função por meio do argumento func e retorna um vetor como saída, que nesse caso é o vetor passado ao argumento x de f() acrescido de um. Considere agora o trecho que segue: f &lt;- function() mean(runif(n = 10, min = 0, max = 1)) # A função loop() é um funcional. loop &lt;- function(x, func) { resultado &lt;- NULL for (i in seq_along(x)) resultado &lt;- c(resultado, func()) resultado } loop(x = 1:3, func = f) ## [1] 0.3702804 0.7174270 0.3805153 loop(x = 1:7, func = f) ## [1] 0.5092227 0.4038002 0.5425011 0.5148392 0.2298425 0.3374357 0.3344574 A função loop() é um funcional que reproduz a função passada ao argumento func um quantidade qualquer de vezes. No exemplo acima, loop(x = 1:3, func = f) e loop(x = 1:7, func = f) reproduz f() 3 (três) e 7 (sete) vezes, respectivamente. Em situações em que você deseja reproduzir uma função ou aplicá-la à cada posição de um vetor ou lista e isso se repete por diversas partes do seu código, o uso de um funcional poderá deixar seu código mais limpo, sem a necessidade de escrever muitas estruturas de repetições. No exemplo acima, se em outra parte do código houvesse a necessidade de reproduzir f() 10 (dez) vezes, bastaria fazer loop(x = 1:10, func = f) ao invés de escrever novamente um laço com alguma estrutura de repetição. Escrever estruturas de repetições, na forma acima, não é muito útil do ponto de vista de desempenho computacional, uma vez que não há melhoria no desempenho do código que seria obtido ao se implementar os loops sem o uso do funcional loop(). Nesse exemplo, toda vez que chamamos loop(), o que internamente está sendo feito é um loop utilizando a estrutura de repetição for. A melhor forma, em R, de se fazer uso de funcionais é considerar os que já estão implementados de forma consistente, utilizando linguagens mais eficientes, como, por exemplo, os funcionais de R escritos em C/C++ ou Fortran (códigos mais antigos) e que estão disponíveis no R base ou em pacotes suplementares. Fazer uso desses funcionais nos trará o benefício de escrever estruturas de repetições sem a necessidade de implementar essa estrutura toda vez que necessitarmos, além do benefício de substituir uma estrutura de repetição de R, que naturalmente são lentas, por funcionais que são muito mais eficientes. “Para se tornar significativamente mais confiável, o código deve se tornar mais transparente. Em particular, condições aninhadas e loops devem ser vistos com grande suspeita. Fluxos de controle complicados confundem os programadores. O código bagunçado geralmente esconde bugs.” — Bjarne Stroustrup, criador da linguagem de programação C++. 5.3.1 Funcionais do R Base O pacote base da linguagem R (algumas vezes chamo de R Base) possui alguns funcionais que podem ser bastante úteis em diversas situações. Tentar evitar escrever estruturas de repetições por meio do uso de funcionais é uma prática útil e algo bastante comum em linguagens de programação com paradigma funcional e em linguagens multiparadigmas, como é o caso da linguagem R. Observação: Poderá existir diversas situações que não poderemos escapar do uso de estruturas de repetições, no caso do R, das estruturas for, while e repeat. Porém, existem diversas outras situações que aquilo que encontra-se dentro do loop é uma estrutura bem definida que poderá ser envolvida em uma função e repetida por um funcional. Dessa forma, sempre procure checar se você poderá envolver em uma função o conteúdo que seria colocado no interior de uma estrutura de repetição. Passar esse conteúdo como uma função à um funcional poderá trazer benefícios ao seu código. 5.3.1.1 apply() Trata-se de um funcional bastante conhecido em R, implementado no R Base. O funcional apply() é normalmente utilizado quando desejamos aplicar uma função em uma das dimensões de uma matriz, data frame ou tibble, sendo este último um estrutura de dados do pacote tibble. A estrutura tibble trata-se de uma releitura moderna de um data frame com um método print() aprimorado. Porém, não se preocupe, quase tudo que você sabe sobre data frame será válido para um objeto da classe tbl. A forma geral do funcional apply() é dada por: apply(X, MARGIN, FUN, ...) em que: X: é a matriz/data frame ou tibble em que será aplicada uma função sobre seus elementos; MARGIN: indica a dimensão em que a função irá ser aplicada. Se MARGIN = 1 (padrão), temos que uma dada função será aplicada sobre as linhas de do objeto X. Fazendo MARGIN = 1, temos que uma dada função será aplicada sobre todas as colunas do objeto X; FUN: função que iremos aplicar em uma das dimensões do objeto X. Dessa forma, o funcional apply() tomará cada linha ou coluna (a depender de MARGIN) como sendo o primeiro arugmento da função passada à FUN; ...: operador dot-dot-dot discutido em tópicos anteriores. Isso permitirá que possamos acessar os argumentos da função passada à FUN passando estes argmento ao funcional apply(). Exemplo: Aplicando a função mean() sobre linhas e colunas do objeto M (uma matriz). O uso do funcional apply() seria equivalente se M fosse um data frame ou uma tibble. # Construindo a matriz m de orden 5x5. M &lt;- matrix(data = 1:25, nrow = 5, ncol = 5) # Aplicando a função mean() sobre cada linha de m. apply(X = M, MARGIN = 1, mean) ## [1] 11 12 13 14 15 # Aplicando a função mean() sobre cada coluna de m. apply(X = M, MARGIN = 2, mean) ## [1] 3 8 13 18 23 5.3.1.2 lapply(), sapply() e vapply() Os funcionais lapply(), sapply() e vapply() foi introduzido o mesmo tópico, visto que eles tem muito em comum. Tais funcionais permitem que venhamos aplicar uma função à elementos de um vetor ou elementos de uma lista. Uso: lapply(X, FUN, ...) sapply(X, FUN, ..., simplify = TRUE) vapply(X, FUN, FUN.VALUE, ...) O funcional lapply() retorna uma lista do mesmo tamanho que X, em que cada elemento é o resultado da aplicação de FUN no elemento correspondente de X. Já o funcional sapply() é bastante semelhante ao funcional lapply(), sendo o retorno a diferença mais notável, visto que lapply() sempre retornará uma lista e sapply() retorna uma estrutura que melhor poderá comportar as informações, havendo uma espécie de simplificação da estrutura a ser retornada. Considere o trecho de código que segue # Criando um vetor double. x &lt;- list(c(1,7,4,3), c(1,2,3,6)) # A função f() retorna uma matrix de caracter. f &lt;- function(x){ as.character(round(sin(x), digits = 2)) } lapply(X = x, FUN = f) ## [[1]] ## [1] &quot;0.84&quot; &quot;0.66&quot; &quot;-0.76&quot; &quot;0.14&quot; ## ## [[2]] ## [1] &quot;0.84&quot; &quot;0.91&quot; &quot;0.14&quot; &quot;-0.28&quot; sapply(X = x, FUN = f) ## [,1] [,2] ## [1,] &quot;0.84&quot; &quot;0.84&quot; ## [2,] &quot;0.66&quot; &quot;0.91&quot; ## [3,] &quot;-0.76&quot; &quot;0.14&quot; ## [4,] &quot;0.14&quot; &quot;-0.28&quot; Nota: Perceba que para o exemplo acima, lapply(X = x, FUN = f) equivale a fazer sapply(X = x, FUN = f, simplify = FALSE). Por sua vez, o funcional vapply() é bastante similar ao funcional sapply(), porém, podemos especificar os tipos de valor de retorno. Considere o trecho de código abaixo que mostra o uso da função vapply(). Perceba, no código de segue, que FUN.VALUE recebe como argumento o tipo esperado de retorno da função f() e o tamanho do vetor retornado ao aplicar a função f() à cada elemento da lista passada à X. # Criando um vetor double. x &lt;- list(c(1,7,4,3), c(1,2,3,6)) # A função f() retorna uma matrix de caracter. f &lt;- function(x){ as.character(trunc(sum(x))) } # O retorno será uma matriz. resultado &lt;- vapply(X = x, FUN = f, FUN.VALUE = character(1)) resultado ## [1] &quot;15&quot; &quot;12&quot; Nota: O funcional vapply() poderá dar um pouco mais de segurança quando comparado ao funcional sapply(), visto que poderemos especiticar o tipo de retorno esperado. Dessa forma, é de se esperar que a função vapply() poderá “reclamar” um pouco mais que a função sapply(). 5.3.1.3 Map(), mapply() Considere a função mp() que recebe como argumento dois vetores de mesmo comprimento e que calcula a média ponderada do vetor passado ao argumento x considerando um vetor de pesos passado à y. mp &lt;- function(x, y){ # x é o vetor que desejamos calcular a média ponderada. # y é o vetor de pesos. if (length(x) != length(y)) stop(&quot;O vetor x deve ter o mesmo comprimento do vetor de pesos y.&quot;) sum(x*y)/sum(y) } mp(x = c(4, 6.5), y = c(6, 4)) ## [1] 5 Considerando algum dos funcionais apresentados anteriormente, poderemos facilmente aplicar mp() à todos elementos de uma lista de vetores com vetor de pesos fixos, como mostra o código abaixo: mp &lt;- function(x, y){ # x é o vetor que desejamos calcular a média ponderada. # y é o vetor de pesos. if (length(x) != length(y)) stop(&quot;O vetor x deve ter o mesmo comprimento do vetor de pesos y.&quot;) # Média ponderada. sum(x*y)/sum(y) } valores &lt;- list(c(7.3, 3.2, 1.5), c(8.4, 4.7, 5.1), c(10, 9.7, 9.6), c(8.5, 7.2, 7.7)) pesos &lt;- c(5, 3, 2) # Pesos fixos. # Usando lapply(): lapply(X = valores, FUN = mp, y = pesos) ## [[1]] ## [1] 4.91 ## ## [[2]] ## [1] 6.63 ## ## [[3]] ## [1] 9.83 ## ## [[4]] ## [1] 7.95 # Usando sapply(): sapply(X = valores, FUN = mp, y = pesos, simplify = TRUE) ## [1] 4.91 6.63 9.83 7.95 # Usando vapply(): vapply(X = valores, FUN = mp, y = pesos, FUN.VALUE = double(1)) ## [1] 4.91 6.63 9.83 7.95 Ao contrário dos funcionais anteriores, em que apenas um dos argumentos da função varia, os funcionais Map() e mapply() permitirão que outros argumentos da função possa também variar. Por exemplo, considere uma pequena modificação do caso anterior, com a diferença de que o objeto pesos será uma lista de pesos. Esse problema poderá ser resolvido utilizando o funcional Map() e mapply(), como mostra o exemplo abaixo: mp &lt;- function(x, y){ # x é o vetor que desejamos calcular a média ponderada. # y é o vetor de pesos. if (length(x) != length(y)) stop(&quot;O vetor x deve ter o mesmo comprimento do vetor de pesos y.&quot;) # Média ponderada. sum(x*y)/sum(y) } valores &lt;- list(c(7.3, 3.2, 1.5), c(8.4, 4.7, 5.1), c(10, 9.7, 9.6), c(8.5, 7.2, 7.7)) pesos &lt;- list(c(5, 3, 2), c(3, 6, 1), c(4, 4, 2), c(7, 1, 2)) # Pesos não fixados. # Utilizando o funcional Map(). Map(f = mp, x = valores, y = pesos) ## [[1]] ## [1] 4.91 ## ## [[2]] ## [1] 5.85 ## ## [[3]] ## [1] 9.8 ## ## [[4]] ## [1] 8.21 # Utilizando o funcional mapply(). mapply(FUN = mp, x = valores, y = pesos) ## [1] 4.91 5.85 9.80 8.21 Importante: O funcional mapply() funciona de forma bastante semelhante à Map(), retornando um vetor ao invés de uma lista. A linguagem R possui um função para o cálculo de média ponderanda. Veja a documentação da função weighted.mean(). Implementamos a função mp() apenas para deixar claro que os funcionais se aplicam à qualquer função de R, incluindo as funções que implementamos. 5.3.2 Funcionais do pacote purrr O pacote purrr aprimora o conjunto de ferramentas de programação funcional da linguagem R. Este pacote fornece um conjunto completo, consistente e eficiente de ferramentas para trabalhar com funções e vetores. O pacote purrr encontra-se no CRAN (Comprehensive R Archive Network) do R e você poderá instalar facilmente fazendo install.packages(\"purrr\"). Se desejar, você poderá instalar a versão do pacote mantida no GitHub fazendo devtools::install_github(\"tidyverse/purrr\"), nesse caso, será preciso ter instalado o pacote devtools. Figura 5.3: Logo do pacote purrr de autoria de Hadley Wickham (autor) e e Lionel Henry (autor e mantenedor). Nota: As funções do pacote purrr são implementadas na linguagem C. Dessa forma, são funções tão eficientes quanto àquelas que são fornecidas pelos funcionais do R Base, com a vantagem de ser menos verbosas. 5.3.2.1 map() e variantes O funcional map() é a função principal do pacote purrr, em que recebe como primeiro argumento um vetor/lista, uma função como segundo argumento e necessário, um conjunto de argumentos passado da função atribuida. Forma geral de uso: map(.x, .f, ...) map_int(.x, .f, ...) map_dbl(.x, .f, ...) map_lgl(.x, .f, ...) map_chr(.x, .f, ...) em que, .x: é uma lista ou vetor atômico; .f: uma função, fórmula (por exemplo ~ .x + 2) ou um vetor/lista. ...: um conjunto adicional de argumentos que são mapeados para o objeto passada para o argumento .f; Exemplo: Utilizando o funcional map() que aplica a função sinal() à cada elemento de um vetor atômico. A função irá retornar \"-\", \"0\" ou \"+\", a depender do valor passado à x em f(). sinal &lt;- function(x){ # Varificando a classe de x e parando a execução da função # se x não for um objeto da classe numeric. if (!is.numeric(x)) stop (&quot;x deve ter a classe numérica.&quot;) if (x == 0) &quot;0&quot; else if (x &gt; 0) &quot;+&quot; else &quot;-&quot; } x &lt;- c(1.7, -2.01, 0, 12) purrr::map(.x = x, .f = sinal) ## [[1]] ## [1] &quot;+&quot; ## ## [[2]] ## [1] &quot;-&quot; ## ## [[3]] ## [1] &quot;0&quot; ## ## [[4]] ## [1] &quot;+&quot; Perceba que o retorno de map() é uma lista assim como obteriamos ao utilizarmos o funcional lapply(). O exemplo acima poderia ser resolvido, com lapply(), fazendo lapply(X = x, FUN = sinal). A grande vantagem do uso do funcional map() do pacote purrr é que podemos fazer uso de sufixos que nos ajudam na tarefa de converter o resultado para um vetor atômico do tipo desejado, utilizando alguma de suas variantes: map_lgl() (retorno de um vetor com elementos do tipo logical), map_int() (retorno de um vetor com elementos do tipo integer), map_dbl() (retorno de um vetor com elementos do tipo double) e map_chr() (retorno de um vetor com elementos do tipo character). Exemplo: Utilizando map_chr() para obtenção de um vetor de caracteres como saída. Isso evito termos que efetuar unlist() para transformarmos uma lista em um vetor atômico. purrr::map_chr(.x = x, .f = sinal) ## [1] &quot;+&quot; &quot;-&quot; &quot;0&quot; &quot;+&quot; Para o argumento .f do funcional map() bem como de seus variantes (map_lgl(), map_int(), map_dbl() e map_chr()), poderemos passar uma função anônima ou uma fórmula. Os três exemplos que seguem apresentam o uso do funcinal map() ou alguma de suas variantes, considerando funções com 1 (um), 2 (dois) ou 3 (três) argumentos. Independentemente de qual(is) varantiante(s) de map() for/forem utilizada(s) nos exemplos, o uso de todas as variântes são equivalentes. Exemplo (um argumento): Uso do funcional map_int() para uma função com um único argumento. Nesse exemplo, desejamos somar 1 à cada elemento do vetor atômico (vetor homogêneo) x &lt;- 1L:10L. Note que, nesse exemplo, resolvemos o problema de somar o valor 1 (do tipo inteiro) aos valores de x, de 4 (quatro) formas distintas. Na primeira forma, definimos a função soma1() e passamos a função como argumento à .f do funcional map_int(). Na segunda forma, optou-se em passar uma função anônima para o argumento .f, uma vez que a função é curta e não necessitaríamos nos preocupar em atribuir um nome à ela. Nessa segunda forma, não haveria a necessidade da definição da função soma1(), uma vez que definimos a função diretamente no funcional, sem a necessidade de atribuição de um nome. Já na terceira e quarta forma, note que optamos em passar um objeto da classe formula (note o til, ~). Como trata-se de uma função com um único argumento, podemos definir esse argumento por .x ou .. x &lt;- 1L:10L soma1 &lt;- function(x) x + 1L # Foma 1: Passando à .f uma função soma1(). purrr::map_int(.x = x, .f = soma1) # Forma 2: Passando à .f uma função anônima. purrr::map_int(.x = x, .f = function(x) x + 1L) # Forma 3: Passando à .f uma formula. purrr::map_int(.x = x, .f = ~ .x + 1L) # Forma 4: Para funções com um único argumento, você poderá substituir # .x na fórmula passada ao argumento .f por um &quot;.&quot; (ponto). purrr::map_int(.x = x, .f = ~ . + 1L) Nota: É claro que poderiamos resolver o exemplo acima sem uso de funcional algum, uma vez que a linguagem R é vetorizada e poderiamos simplesmente fazer x + 1L para assim obtermos um vetor de interio. Porém, isso é um exemplo didático, em que o objetifo aqui é entender os funcionais do pacote purrr e não perdermos mais tempo com o entendimento da função passada ao funcional. Sempre tenha em mente que a função passada à .f, na maioria das vezes, não será tão simples a ponto de justificar resolver o problema sem o uso de um funcional. Exemplo (dois argumentos): Uso do funcional map(), em que é aplicado a função f() sobre todos os elementos da lista x. O exemplo mostra que a função map() varia sobre os elementos do primeiro argumento .x e fixa o segundo argumento. Além disso, note que é possível passar uma função anônima ou uma fórmula ao argumento .f do funcional map(), assim como no exemplo anterior. Para o caso de passagem de uma fórmula, podemos utilizar . ou .x para se referir ao primeiro argumento de f() e .y para fazer referência ao segundo argumento. x &lt;- list(c(1.1,4.07,3.76), c(7.1,2.2), 1:10) y &lt;- c(1,2,7,4,2) f &lt;- function(x, y) 2 * x + sum(sqrt(y)) # Forma 1: Passando a função f() para o argumento .f # de map_dbl(). purrr::map(.x = x, .f = f, y = y) # Forma 2: Passando uma função anônima de dois argumentos. purrr::map(.x = x, .f = function(x, y) 2 * x + sum(sqrt(y)) , y = y) # Forma 3: Utilizamos .x e .y em situações de funções com 2 argumentos. purrr::map(.x = x, .f = ~ 2 * .x + sum(sqrt(.y)), .y = y) # Forma 4: Aqui o x .x será substituido na ocorrência de &quot;.&quot; (ponto). purrr::map(.x = x, .f = ~ 2 * . + sum(sqrt(.y)), .y = y) Nota: Note que nesse exemplo não poderemos fazer uso das variantes do funcional map(). Isso se deve ao fato de x ser uma lista, o que implica que a função f() será aplicada à cada elemento da lista x. Sendo assim, esperamos que o retorno de map() será uma lista com a mesma quantidade de elementos de x. Exemplo (três ou mais argumentos): Esse exemplo é muito parecido com o exemplo antrior (função f() com 2 (dois) argumentos). Aqui, temos que a função f() possui 3 (três) argumentos. Perceba porém, que ao se passar uma fórmula ao argumento .f do funcional map(), poderemos nos referir ao terceiro argumento com a notação ..3. x &lt;- list(1:3, 2:7, 8:10) y &lt;- 1:3 z &lt;- c(2,3,5) f &lt;- function(x, y, z) x * y + 2 * z # Forma 1: Passando a função f() para o argumento .f # de map_dbl(). purrr::map(.x = x, .f = f, y = y, z = z) # Forma 2: Passando uma função anônima de dois argumentos. purrr::map(.x = x, .f = function(x, y, z) x * y + 2 * z , y = y, z = z) # Forma 3: Utilizamos .x e .y em situações de funções com 2 argumentos. purrr::map(.x = x, .f = ~ .x * .y + 2 * ..3, y = y, ..3 = z) # Forma 4: Aqui o x .x será substituido na ocorrência de &quot;.&quot; (ponto). purrr::map(.x = x, .f = ~ . * .y + 2 * ..3, y = y, ..3 = z) Nota: Nas formas 3 e 4 do exercício acima, você poderá substituir ..3 por z, ou seja, considerar, por exemplo, purrr::map(.x = x, .f = ~ .x * .y + 2 * ..3, y = y, z = z) irá funcionar. Isso se deve ao fato do funcional map() ser uma função vararg, em que os argumentos adicionais (não pertencentes à map()) serão acrescentados na função passada ao argumento .f de map(). Se f() é uma função com n argumentos, você poderá referenciar os seus argumentos por ..1 (primeiro argumetno), ..2 (segundo argumento), ..3 (terceiro argumento), …, ..n, com n um número inteiro qualquer. Observação: O uso de . para especificar o primeiro elemento de uma função passada como argumento à .f em um dos funcionais do pacote purrr poderá gerar conflitos em situações em que você esteja utilizando o pacote magrittr em que . tem um outro significado. 5.3.2.2 map2() e variantes O funcional map2() tem grande utilidade em situações em que desejamos percorrer simultaneamente dois argumentos, isto é, quando temos que a função passada como argumento à .f possui dois argumentos e desejamos aplicar a função, par a par, sobre os elementos passados aos argumentos .x e .y, respectivamente. Em outras palavras, o uso do funcional map2() é útil em situações em que temos interesse de não deixar fixo o segundo argumento da função passada à .f. Assim como nas variantes do funcional map(), temos que as variantes do funcional map2() (map2_int(), map2_dbl() map2_lgl() e map2_chr()) ireão retornar um vetor com elementos do tipo referente ao sufixo utilizado. Forma geral de uso: map2(.x, .y, .f, ...) map2_int(.x, .y, .f, ...) map2_dbl(.x, .y, .f, ...) map2_lgl(.x, .y, .f, ...) map2_chr(.x, .y, .f, ...) Nota: O uso do funcional map2() é análago ao uso de map() e suas variantes, com a diferença que o segundo argumento não estará fixo. Exemplo: Uso da função map2() em que estão sendo somados, par a par, os elementos dos objetos x e y. x &lt;- list(1:3, 1:2, 3:10) y &lt;- list(1:3, c(4,3), 5:12) purrr::map2(.x = x, .y = y, .f = ~ .x + .y) ## [[1]] ## [1] 2 4 6 ## ## [[2]] ## [1] 5 5 ## ## [[3]] ## [1] 8 10 12 14 16 18 20 22 5.3.2.3 pmap() e variantes Algo muito parecido com o funcional Map() e mapply()do R Base é o que podemos fazer com o funcional pmap() do pacote purrr. Analogamente ao que temos com Map() e mapply(), ao utilizar o funcional pmap() poderemos variar mais de um argumeto. Forma geral de uso: pmap(.l, .f, ...) pmap_int(.l, .f, ...) pmap_dbl(.l, .f, ...) pmap_lgl(.l, .f, ...) pmap_chr(.l, .f, ...) Exemplo: Uso do funcional pmap() variando, par a par, sobre elementos de duas listas (x e y) e um vetor (z). x &lt;- list(1:3, 1:2, 3:10) y &lt;- list(1:3, c(4,3), 5:12) z &lt;- c(1, 2, 3) purrr::pmap(.l = list(x, y, z), .f = ~ .x + .y + ..3) ## [[1]] ## [1] 3 5 7 ## ## [[2]] ## [1] 7 7 ## ## [[3]] ## [1] 11 13 15 17 19 21 23 25 Importante: O funcional pmap() poderá ser utilizado, de forma análoga ao exemplo acima, em situações em que a função passada ao argumento .f possa ter mais de três variáveis não fixadas. Porém, perceba que ao utilizar o funcional pmap(), nada impedirá que você tenha algumas dessas variáveis fixadas, se isso for de interesse. Esse fato também é válido para os funcionais Map() e mapply() do R Base e para o funcional map2() do pacote purrr. Exemplo: Uso do funcional pmap() variando em duas listas (x, y) e um vetor z. Perceba que a quantidade de elementos nos objetos x, y e z é a mesma, ou seja, os objetos x e y são duas listas com dois vetores, respectivamente e z é um vetor com dois elementos. f &lt;- function(x, y, z) x + y - z x &lt;- list(c(2,1,4), c(4,3,6,7,1)) y &lt;- list(1:3, 1:5) z &lt;- c(1,1) # Vetor fixo. purrr::pmap(.l = list(x, y, z), .f = f) ## [[1]] ## [1] 2 2 6 ## ## [[2]] ## [1] 4 4 8 10 5 5.3.2.4 invoke() e invoke_map() A funcional invoke() é bastante semelhante ao funcional do.call() do R Base. Ambos os funcionais são úteis quando temos os argumentos de uma função em uma lista e posteriormente desejamos invocar uma função passando a lista de argumentos. Exemplo: Passando a lista runif_args para a função runif() usando os funcionais do.call() (do R Base) e invoke (pacote purrr). set.seed(0) # Fixando uma semente. # Lista de argumentos para passar à função runif(). runif_args &lt;- list(n = 3, min = 0, max = 10) # Usando do.call() do R Base. do.call(what = runif, args = runif_args) ## [1] 8.966972 2.655087 3.721239 # Usando invoke() do pacote purrr. purrr::invoke(.f = runif, .x = runif_args) ## [1] 5.728534 9.082078 2.016819 Nas situações em que desejamos aplicar uma função à uma lista de listas de argumentos ou aplicar uma lista de argumentos à uma lista de funções, o funcional invoke_map() poderá ser de grande utilidade. O exemplo que segue mostra essas duas situações mencionadas. Exemplo: f1 &lt;- function(valor, por) valor + por f2 &lt;- function(valor, por) valor - por f3 &lt;- function(valor, por) valor * por f4 &lt;- function(valor, por) valor / por # Passando uma lista de listas de argumentos para a função f1. purrr::invoke_map(.f = f1, .x = list(list(valor = 1, por = 1), list(valor = 2, por = 2), list(valor = 7.1, por = 10))) ## [[1]] ## [1] 2 ## ## [[2]] ## [1] 4 ## ## [[3]] ## [1] 17.1 # Passando uma lista de funções para a lista de argumentos passada # à .x do funcional invoke_map(). purrr::invoke_map(.f = list(f1, f2, f3, f4), .x = list(list(valor = 2, por = 2))) ## [[1]] ## [1] 4 ## ## [[2]] ## [1] 0 ## ## [[3]] ## [1] 4 ## ## [[4]] ## [1] 1 Exercícios Considerando o data frame iris (150 observações e 5 variáveis), obtenha a média das variáveis quantitativas por meio do uso de um funcional. O que o código abaixo faz? Reescreva o código abaixo, substitundo o loop for() pelo uso de um funcional. Dica: Utilize a função sapply(). vetor &lt;- 1L:10L f &lt;- function(x){ v &lt;- c() for(i in seq_along(x)){ v[i] &lt;- x[i] + x[i + 1] } # A função na.omit() remove ocorrências de NA # no vetor passado como argumento. v &lt;- na.omit(v) attributes(v) &lt;- NULL; v } Refaça o exercício anterior utilizando a função vapply(). Leia a descrição do funcional accumulate() do pacote purrr e entenda o código abaixo: x &lt;- list(c(3, 2, 4), c(5, 3), c(4, 2, 3)) purrr::accumulate(.x = x, .f = ~ sum(.x) + .y) Reescreva o código abaixo utilizando o funcional accumulate() do pacote purrr. acumular &lt;- function(x){ vetor &lt;- x[1] for(i in 2:length(x)){ vetor[i] &lt;- sum(vetor[i - 1]) + x[i] } vetor } Implemente a função isnumeric(x) que deverá recebe um data frame e retornar um vetor lógico informando TRUE, se a coluna é numerica ou FALSE, caso contrário. Implemente de três formas, tal que: Forma 1: Implementar utilizando a estrutura de repetição for(); Forma 2: Implementar utilizando o funcional sapply(); Forma 3: Implementar utilizando o functional vapply(). A função unique() quando aplicada à um vetor, retornará um outro vetor com os elementos não repetidos do vetor passado como argumento à unique(). Implemente a função countdiff(x) que recebe como argumento um vetor, matriz ou tabela (data frame), de forma que retorne a quantidade de elementos distintos no vetor ou nas colunas da matriz/tabala. Considere o objeto lista &lt;- list(1:2, list(c(8, 7), c(1, 4))). Utilizando o funcional map(), obtenha a saída abaixo. Dica: 1 - Use map() dentro de map(). 2 - Ao final, utilize o comando flatten() do pacote purrr. A saída a baixo é nada mais que somar 1 em cada elemento da lista. [[1]] [1] 2 [[2]] [1] 3 [[3]] [1] 9 8 [[4]] [1] 2 5 Por meio da documentação do funcional map_if() do pacote purrr, entenda o que o código abaixo faz: x &lt;- 1:10 purrr::map_if(.x = x, .p = ~ .x %% 2 == 0, .f = ~ 2 * .x, .else = ~ .x + 1) %&gt;% flatten_dbl() Considere o objeto lista definido por lista &lt;- list(a = c(1, 3, 2), b = c(2, 3)). Utilizando o funcional map_if(), multiplique os elementos pares por 2 de forma a obter a saída abaixo: $a $a[[1]] [1] 1 $a[[2]] [1] 3 $a[[3]] [1] 4 $b $b[[1]] [1] 4 $b[[2]] [1] 3 Dica: Tente construir algo como map(.x = lista, .f = ~ map_if()). A função split() divide um data frame em grupos de um fator. Por exemplo, faça iris %$% split(., Species). Dado isso, considere o conjunto de dados starwars do pacote dplyr (install.packages(\"dplyr\")) que possui várias descrições dos personagens de Star Wars. Obtenha a quantidade de personagens por espécies utilizando o funcional map(). 5.4 Sistema S3 S3 é o primeiro e mais simples sistema de Orientação à Objeto (OO) da linguagem R. Por ser o primeiro sistema de OO da linguagem R, S3 é o sistema mais utilizado nos pacotes disponíveis no Comprehensive R Archive Network - CRAN, além de ser o sistema de OO utilizado na implementação dos pacotes base (R Base) e no pacote stats, ambos pacotes disponíveis por padrão em qualquer instalação de R. Aliás, o base é o principal pacote de R, sendo este o pacote de define a linguagem R com suas funções básicas. A linguagem R permite o uso de outros sistemas de OO como o S4, RC e R6, sendo o sistema R6 disponível pelo pacote R6 o mais formal e disponível em forma de um pacote desenvolvido por Winston Chang. O S3 implementa um estilo de OO chamado OO de função genérica. Esse sistema é diferente da maioria das linguagens de programação com paradigma de OO, como, por exemplo, Java, C++, Ruby, Python e C#, que implementam o sistema de OO por transmissão de mensagens. Com a passagem de mensagens para um objeto, este determina qual método (função) irá chamar. Nessas linguagens, invocamos um método para um objeto fazendo algo como objeto.metodo(), em que objeto é um objeto qualquer pertencente à uma classe e metodo() é uma função qualquer disponível à objetos dessa classe. Por exemplo, você poderia ter algo como M.inverse() que calcularia a inversa do objeto M da classe matrix. Dessa forma, se o objeto M é assinado com uma classe, os métodos (funções) disponíveis para esse objeto estão encapsulados no interior do objeto. OO, em R, de forma mais próxima aos sistemas de linguagens OO tracionais é possível com o sistema R6 do pacote R6. Esse sistema é utilizado no pacote ggplot2. Ao contrário dos sistemas tradicionais de OO, no sistema de OO S3, os métodos não estão dentro (encapsulados) dos objetos. Esses são invocados por uma função genérica que é responsável por invocar o método correto. Considere o exemplo abaixo: Exemplo: vetor &lt;- c(7, 1, 2, 3, 1.2, 4.4) modelo &lt;- lm(data = mtcars, formula = mpg ~ cyl + disp + wt) # Calculando o sumário de um vetor. summary(vetor) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 1.40 2.50 3.10 4.05 7.00 # Obtendo o sumário de um modelo de regressão. summary(modelo) ## ## Call: ## lm(formula = mpg ~ cyl + disp + wt, data = mtcars) ## ## Residuals: ## Min 1Q Median 3Q Max ## -4.4020 -1.4067 -0.4948 1.3471 6.0717 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 41.072990 2.839375 14.466 1.61e-14 *** ## cyl -1.778054 0.606451 -2.932 0.00664 ** ## disp 0.007275 0.011797 0.617 0.54243 ## wt -3.623447 1.037898 -3.491 0.00161 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.595 on 28 degrees of freedom ## Multiple R-squared: 0.8325, Adjusted R-squared: 0.8146 ## F-statistic: 46.39 on 3 and 28 DF, p-value: 5.446e-11 Perceba que a função summary() atuou de formas distintas sobre os objetos vetor e modelo que pertencem às classes numeric e lm, respectivamente. A função summary() invocou o método para realizar o trabalho correto sobre o objeto em questão. Trata-se de uma função genérica (uma interface) responsável por invocar o método correto. Essa função estará associada à diversas outras funções. É a função genérica que irá despachar o método (função) correta para trabalhar com objeto em questão. Note que a função summary() (função genérica) é uma implementação muito simples. Veja o seu conteúdo abaixo: body(fun = summary) ## UseMethod(&quot;summary&quot;) Para o exemplo acima, a função genérica summary() invocou os métodos default() e lm para trabalharem sobre os objetos vetor e modelo, respectivamente. Por exemplo, você poderia ter feito o papel da função genérica summary(), fazendo: vetor &lt;- c(7, 1, 2, 3, 1.2, 4.4) modelo &lt;- lm(data = mtcars, formula = mpg ~ cyl + disp + wt) # Calculando o sumário de um vetor. summary.default(vetor) # Obtendo o sumário de um modelo de regressão. summary.lm(modelo) Além dos métodos default() e lm() associados à função genérica summary(), diversos outros métodos podem ser despachado por summary(). Faça em um prompt de comando da linguagem R, por exemplo, summary + Tab para obter uma lista dos métodos disponíveis para a função genérica summary(). Uma outra forma mais eficiente de fazer isso é utilizando a função methods(), como mostra o código abaixo: # Listando todos os métodos associados # à função genérica summary(). methods(generic.function = summary) # or methods(generic.function = &quot;summary&quot;) ## [1] summary.aov summary.aovlist* ## [3] summary.aspell* summary.check_packages_in_dir* ## [5] summary.cohesiveBlocks* summary.connection ## [7] summary.data.frame summary.Date ## [9] summary.default summary.ecdf* ## [11] summary.factor summary.gexf* ## [13] summary.ggplot* summary.glm ## [15] summary.hcl_palettes* summary.igraph* ## [17] summary.infl* summary.lm ## [19] summary.loess* summary.manova ## [21] summary.matrix summary.mlm* ## [23] summary.nls* summary.packageStatus* ## [25] summary.POSIXct summary.POSIXlt ## [27] summary.ppr* summary.prcomp* ## [29] summary.princomp* summary.proc_time ## [31] summary.rlang_error* summary.rlang_trace* ## [33] summary.srcfile summary.srcref ## [35] summary.stepfun summary.stl* ## [37] summary.table summary.tukeysmooth* ## [39] summary.vctrs_sclr* summary.vctrs_vctr* ## [41] summary.warnings summary.XMLInternalDocument* ## see &#39;?methods&#39; for accessing help and source code Para saber se uma determinada função é genérica e em caso afirmavo saber qual método foi despachado, o uso do pacote sloop poderá ser útil. O pacote encontra-se no CRAN e poderá ser instalado fazendo install.packages(\"devtools\"). Considere o exemplo que segue: Exemplo: x &lt;- matrix(1L:4L, nrow = 2) # Indica que print() é um objeto do sistema S3 # de OO e além disso, informa que trata-se de # uma função genérica. sloop::ftype(f = print) ## [1] &quot;S3&quot; &quot;generic&quot; # A seta indica qual método está sendo utilizado para # imprimir o objeto x. Nesse caso, print(x) despacha # o método default() associado à função genérica print(). sloop::s3_dispatch(print(x)) ## print.matrix ## print.integer ## print.numeric ## =&gt; print.default 5.4.1 Classes No sistema S3 não há uma definição formal de classe. Para definir um objeto como pertencente à uma determinada classe, bastará definir um atributo de classe ao objeto utilizando as funções structure() ou class&lt;-(). O exempo que deixará claro como isso poderá ser feito: Exemplo: # Fazendo list() tpertencer à uma classe qualquer # de nome &quot;any_class&quot;. x &lt;- structure(list(), class = &quot;any_class&quot;) class(x) ## [1] &quot;any_class&quot; # ou x &lt;- list() class(x) &lt;- &quot;any_class&quot; class(x) ## [1] &quot;any_class&quot; Importante: Perceba que a classe de um objeto não é nada mais que um atributo do objeto, em que esse atributo tem o nome class. Faça, por exemplo attributes(x) para obter uma lista de atributos associados à um objeto. Você poderá incluir qualquer outro atributo ao objeto x, se for de seu interesse, porém, deverá existir apenas um atributo de nome class que controla a classe do objeto. Exemplo: Você poderá determinar qual a classe de um objeto fazendo e perguntar se um objeto pertence à uma instância de classe, como mostra o código que segue: x &lt;- list() class(x) &lt;- &quot;any_class&quot; # Perguntando a classe do objeto x. class(x) ## [1] &quot;any_class&quot; # Perguntando e o objeto x pertência à instância de # classe de nome any_class. inherits(x, what = &quot;any_class&quot;) ## [1] TRUE 5.4.2 Criando funções genéricas O trabalho de um S3 genérico é executar o envio do método, ou seja, encontrar a implementação específica para uma classe. O envio do método é realizado por UseMethod(). Exemplo: Veja que print() e summary() são funções genéricas, cuja a implementação faz uso da função UseMethod(). sloop::ftype(summary) ## [1] &quot;S3&quot; &quot;generic&quot; sloop::ftype(print) ## [1] &quot;S3&quot; &quot;generic&quot; # Corpo da função genérica summary(). body(summary) ## UseMethod(&quot;summary&quot;) # Corpo da função genérica print(). body(print) ## UseMethod(&quot;print&quot;) A função UseMethod() usa dois argumentos: o nome da função genérica (obrigatório) e o argumento a ser usado para o método de envio (opcional). Se você omitir o segundo argumento, ele será despachado com base no primeiro argumento, que é quase sempre o que é desejado. Exemplo: Criando a função genérica f(). O método default() é um método auxiliar que será utilizado caso a classe o argumento passado à função f() pertença à uma classe que não há um método associado á função genérica f(). Perceba que f(x) fará uso do método myclass() e f(y) fará uso do método default(), uma vez que y não foi assinado com um objeto pertencente à classe myclass. f &lt;- function(x) UseMethod(&quot;f&quot;) # Função que trabalha com objeto da classe myclass. f.myclass &lt;- function(x) { warning(&quot;Foi executado o método myclass: mesmo que f.myclass(x)&quot;) print(x + 1) } f.default &lt;- function(x){ warning(&quot;Foi executado o método default: mesmo que f.default(x)&quot;) print(x) } x &lt;- y &lt;- 1L:10L class(x) &lt;- &quot;myclass&quot; f(x) ## Warning in f.myclass(x): Foi executado o método myclass: mesmo que ## f.myclass(x) ## [1] 2 3 4 5 6 7 8 9 10 11 ## attr(,&quot;class&quot;) ## [1] &quot;myclass&quot; # Será executado o método default, uma vez que o objeto # y não foi assinado com a classe myclass. f(y) ## Warning in f.default(y): Foi executado o método default: mesmo que ## f.default(x) ## [1] 1 2 3 4 5 6 7 8 9 10 # Checando se f é um objeto da classe S3 e se trata-se # de uma função genérica. sloop::ftype(f) ## [1] &quot;S3&quot; &quot;generic&quot; Observação: Perceba que utiliza . no nome de uma função não ocasionará problemas de conflito, mas poderá nos deixar com dúvidas, uma vez que não sabemos se o que está antes do ponto é uma função genérica e logo após o seu método ou se apenas trata-se de uma função que usa . no seu nome. Por exemplo, se olharmos apenas para f.a() não ficará claro se f() é uma função genérica e a() um método de f() ou se temos uma função comum de nome f.a. Exercício 1 - A função função dim() é uma função genérica? Explique. Em caso afirmativo, quantos métodos possui essa função? 2 - Explique o por quê da saída do código que segue: x &lt;- 1L:10L class(x) &lt;- &quot;test&quot; t(x) ## ## One Sample t-test ## ## data: x ## t = 5.7446, df = 9, p-value = 0.0002782 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## 3.334149 7.665851 ## sample estimates: ## mean of x ## 5.5 3 - Crie o método print.conc(x, y, sep = \"\", ...) para a função genérica print(). O método deverá concatenar dois objetos da classe conc. O método deverá funcionar da forma abaixo: str1 &lt;- &quot;Estudando&quot; class(str1) &lt;- &quot;conc&quot; str2 &lt;- &quot;R&quot; print(x = str1, y = str2, sep = &quot; &quot;) ## [1] &quot;Estudando&quot; ## attr(,&quot;class&quot;) ## [1] &quot;conc&quot; # [1] &quot;Estudando R&quot; 4 - Informe a saída do código abaixo. Explique! y &lt;- 1 f &lt;- function(x) { y &lt;- 2 UseMethod(&quot;f&quot;) } f.numeric &lt;- function(x) y f(10); f.numeric(7) 5 - Informe a saída do código abaixo. Explique! g &lt;- function(x) UseMethod(&quot;g&quot;) g.character &lt;- function(x) paste(&quot;char&quot;, x) g.numeric &lt;- function(x) paste(&quot;num&quot;, x) g.default &lt;- function(x) &quot;?&quot; g(&quot;1&quot;) g(1) g(TRUE) 6 - A função abaixo implementa o método summary.character(). O que esse método faz? Por que não foi preciso assinar o objeto x? Entenda o código: summary.character &lt;- function(x){ if (!inherits(x, what = &quot;character&quot;)) stop(&quot;x must be of character type&quot;) n_char &lt;- nchar(x) vetor_chr &lt;- strsplit(x = x, split = &quot;&quot;) if (is.list(vetor_chr) == TRUE){ list_factor &lt;- purrr::map(.x = vetor_chr, .f = ~ as.factor(.x)) n_diff &lt;- purrr::map(.x = list_factor, .f = ~ length(levels(.x))) } else n_diff &lt;- length(levels(as.factor(vetor_chr))) list(nchr = n_char, ndiff = n_diff) } summary(x = c(&quot;aabb&quot;, &quot;aaa&quot;)) ## $nchr ## [1] 4 3 ## ## $ndiff ## $ndiff[[1]] ## [1] 2 ## ## $ndiff[[2]] ## [1] 1 7 - Construa a função genérica mydiag(x) que recebe como argumento uma matriz ou tabela (data frame) que podem conter valores numéricos ou caracters, com o número de linhas é igual ao número de colunas. Depois, defina dois métodos, mydiag.numeric() e mydiag.character() que retorna a soma da diagonal principal do objeto passado à x. Para a matriz/tabela de caracteres, considere A/a como 1, B/b como 2, …, Z/z como 26, respectivamente. Dicas: 1 - As função tolower() poderá ajudar a converter um caracter em letra maiúscila para minúscula. 2 - Para o caso de matriz/tabela com strings, considere apenas o primeiro caracter da string. Por exemplo: m1 &lt;- matrix(1:4, 2, 2) mydiag(m1) # [1] 5 m2 &lt;- matrix(c(&quot;casa&quot;, &quot;a&quot;, &quot;barco&quot;, &quot;terra&quot;), 2, 2) mydiag(m2) # [1] 23 8 - Leia o artigo Object-Oriented Programming, Functional Programming and R de John M. Chambers. Nesse artigo, o autor disserta sobre os paradigmas de programação disponíveis em R e trás um pouco da evolução da linguagem. "],
["topicos-em-estatistica-computacional.html", "6 Tópicos em Estatística Computacional 6.1 Geração de Números Pseudo-Aleatórios Exercício 6.2 Otimização Não-Linear Exercício 6.3 Monte Carlo Exercício", " 6 Tópicos em Estatística Computacional 6.1 Geração de Números Pseudo-Aleatórios O conteúdo para esse tópico entra-se em PDF e poderá ser acessado aqui. Em um futuro próximo, essa seção será reescrita e fará parte do corpo deste HTML. 6.1.1 Método da Transformação Inversa (Caso Discreto) O método da transformação inversa também poderá ser aplicado também para gerar observações de v.a.’s discretas. Seja \\(X\\) uma v.a. discreta, tal que \\[... &lt; x_{i-1} &lt; x_i &lt; x_{i+1} &lt;\\, ...\\,.\\] As observações acima são pontos de descontinuidade de \\(F_X(x)\\). Então, a transformação inversa é \\(F_X^{-1} = x_i\\), quando \\(F_X(x_{i-1}) &lt; u \\leq F_X(x_i)\\). O algoritmo que segue poderá ser utilizado para gerar observações de \\(X\\). Algoritmo: Gere um número pseudo-leatório \\(u\\) de uma v.a. \\(U \\sim \\mathcal{U}(0,1)\\); Retorne \\(x_i\\) como observação de \\(X\\), tal que \\(F(x_{i-1}) &lt; u \\leq F(x_i)\\). Em outras palavras, gere \\(u\\) de uma v.a. \\(U \\sim \\mathcal{U}(0,1)\\) e compare na sequência: Se \\(u &lt; p_0\\), faça \\(X = x_0\\) e pare; Se \\(p_0 \\leq u &lt; p_0 + p_1\\), faça \\(X = x_1\\) e pare; Se \\(p_0 + p_1\\leq u &lt; p_0 + p_1 + p_2\\), faça \\(X = x_2\\) e pare; … Se \\(\\sum_{i = 0}^{j-1} p_i \\leq u &lt; \\sum_{i=0}^j p_i\\), faça \\(X = x_j\\) e pare; … em que \\(p_j = P(X = j)\\). Exemplo: Implemente, em R, uma função que retorna a quantidade de observações de uma v.a. \\(X\\) com função de probabilidade: \\[P(X = 1) = 0.3, P(X = 2) = 0.2, P(X = 3) = 0.35, P(X = 4) = 0.15.\\] random &lt;- function(n = 1L){ x &lt;- 1L:4L probs &lt;- c(0.3, 0.2, 0.35, 0.15) u &lt;- runif(n = n, min = 0, max = 1) # Criando uma função para ser passada à um funcional. comp &lt;- function(u){ # Retorna a primeira ocorrência de TRUE match(TRUE, u &lt; cumsum(probs)) } purrr::map_dbl(.x = u, .f = ~ comp(.x)) } set.seed(0) random(n = 10L) ## [1] 4 1 2 3 4 1 4 4 3 3 Em um estudo de simulação, poderemos ter interesse em gerar observações equiprováveis, em que a v.a. \\(X\\) assume um número finito de observações, tal forma que: \\[P(X = j) = \\frac{1}{n}, \\,\\, j = 1, 2, \\ldots, n.\\] Porém, note que para esse caso, não precisaremos fazer muitas comparações, uma vez que sabemos que \\(x = j\\) quando \\(u \\leq \\frac{j-1}{n}\\). Sendo assim, tomamos \\(x = j\\) quando \\(nu \\leq j - 1\\). Note que fazer \\(x = j\\) quando \\(nu \\leq j - 1\\) equivale a fazer \\(x = \\mathrm{Int}(nu) + 1\\), em que \\(\\mathrm{Int}(\\cdot)\\) aqui irá retornar o menor inteiro de um número. Exemplo: Seja \\(X \\sim Bernoulli(p)\\), em que \\(P(X = 0) = 1 - p\\) e \\(P(X = 1) = p\\), com \\(0\\leq p \\leq 1\\). A função rbernoulli(n = 1L, p) retorna possíveis observações de \\(X\\). rbernoulli &lt;- function(n = 1L, p){ u &lt;- runif(n = n, min = 0, max = 1) cond &lt;- (u &lt; 1 - p) comp &lt;- function(x){ ifelse(x &lt; 1 - p, 0L, 1L) } purrr::map_int(.x = u, .f = ~ comp(.x)) } set.seed(0) # Fixando uma semente. n &lt;- 1e4 # Número de observações. result &lt;- rbernoulli(n = n, p = 0.6) # prob. de sucesso = 0.6. # Probabilidade de sucesso aproximada. sum(result == 1)/n ## [1] 0.5973 6.1.2 Método da aceitação e rejeição Em situações em que não podemos fazer uso do método da inversão (impossível obter a função quantílica) e nem conhecemos uma transformação que envolve uma variável aleatória ao qual sebemos gerar observações, poderemos fazer uso do método a aceitação e rejeição. Suponha que \\(X\\) e \\(Y\\) são variáveis aleatórias com função densidade de probabilidade (fdp) ou função de probabilidade (fp) \\(f\\) e \\(g\\), respectivamente. Além disso, suponha que existe uma constante \\(c\\) de tal forma que \\[\\frac{f(t)}{g(t)} \\leq c,\\] para todo valor de \\(t\\), com \\(f(t) &gt; 0\\). Para utilizar o método a aceitação e rejeição para gerar observações da v.a. \\(X\\), utilizando o algoritmo mais abaixo, antes, encontre uma v.a. \\(Y\\) com pdf ou fp \\(g\\), tal que satisfaça a condição acima. Importante: É importante que a v.a. \\(Y\\) escolhida seja de tal forma que você consiga gerar facilmente suas observações. Isso se deve ao fato do método da aceitação e rejeição ser computacionalmente mais intensivo que métodos mais diretos como o método da transformação ou o método da inversão que exige apenas a regração de números pseudo-aleatórios com distribuição uniforme. Algoritmo do Método da Aceitação e Rejeição: 1 - Gere uma observação \\(y\\) proveniente de uma v.a. \\(Y\\) com fdp/fp \\(g\\); 2 - Gere uma observação \\(u\\) de uma v.a. \\(U\\sim \\mathcal{U} (0, 1)\\); 3 - Se \\(u &lt; \\frac{f(y)}{cg(y)}\\) aceite \\(x = y\\); caso contrário rejeite \\(y\\) como observação da v.a. \\(X\\) e volte ao passo 1. Prova: Consideremos o caso discreto, ou seja, que \\(X\\) e \\(Y\\) são v.a.s com fp’s \\(f\\) e \\(g\\), respectivamente. Pelo passo 3 do algoritmo acima, temos que \\(\\{aceitar\\} = \\{x = y\\} = u &lt; \\frac{f(y)}{cg(y)}\\). Isto é, \\[P(aceitar | Y = y) = \\frac{P(aceitar \\cap \\{Y = y\\})}{g(y)} = \\frac{P(U \\leq f(y)/cg(y)) \\times g(y)}{g(y)} = \\frac{f(y)}{cg(y)}.\\] Daí, pelo Teorema da Probabilidade Total, temos que: \\[P(aceitar) = \\sum_y P(aceitar|Y=y)\\times P(Y=y) = \\sum_y \\frac{f(y)}{cg(y)}\\times g(y) = \\frac{1}{c}.\\] Portanto, pelo método da aceitação e rejeição aceitamos ocorrência de \\(Y\\) como sendo uma ocorrência de \\(X\\) com probabilidade \\(1/c\\). Além disso, pelo Teorema de Bayes, temos que \\[P(Y = y | aceitar) = \\frac{P(aceitar|Y = y)\\times g(y)}{P(aceitar)} = \\frac{[f(y)/cg(y)] \\times g(y)}{1/c} = f(y).\\] O resultado logo acima, mostra que aceitar \\(x = y\\) pelo procedimento do algoritmo equivale a aceitar um valor proveniente de \\(X\\) que tem fp \\(f\\). Para o caso contínuo, a demonstração é similar. Importante: Perceba que para reduzir o custo computacional do método, deveremos escolher \\(c\\) de tal forma que possamos maximizar \\(P(aceitar)\\). Sendo assim, escolher um valor exageradamente grande da constante \\(c\\) irá reduzir a probabilidade de aceitar uma observação de \\(Y\\) como sendo observação da v.a. \\(X\\). Nota: Computacionalmente, é conveniente considerar \\(Y\\) como sendo uma v.a. com distribuição uniforme no suporte de \\(f\\), uma vez que gerar observações de uma distribuição uniforme é algo simples em qualquer computador. Para o caso discreto, considerar \\(Y\\) com distribuição uniforme discreta poderá ser uma boa alternativa. Exercício Quais as propriedades de um bom gerador de números pseudo-aleatórios? Disserte sobre cada uma delas. Implemente o gerador Midsquare idealizado pelo matemático John von Neumann. Por que o gerador Midsquare não é um bom gerador? Explique. Defina matematicamente o gerador congruencial linear. Implemente uma função em R que implementa esse gerador. O gerador Randu é definido por \\(x_{i + 1} = 65539 \\times x_i\\,\\mathrm{mod}\\,31\\). O Randu é um gerador congruencial misto ou multiplicativo? Por que o gerador Randu é um dos peiores geradores de números pseudo-aleatório já criado? Explique. Defina um gerador congruencial de período completo para geração de números pseudo-aleatórios com distribuição uniforme no intervalo \\((0,1)\\) Explique o método da transformação para geração de números pseudo aleatório. Apresente um exemplo. Defina o método da inversão para geração de números pseudo-aleatórios. Sempre será possível utilizar esse método? Explique. Implemente uma função para geração de números pseudo-aleatórios com distribuição normal padrão. A função deverá implementar o método de Box-Müller e o método polar. Ao final obtenha um histograma com os números gerados (mil valores) e realize um teste de normalidade. Realize um teste de normalidade. Seja \\(X\\) uma variável aleatória em um espaço de probabilidade \\((\\Omega, \\mathcal{A},\\mathcal{P})\\) e suponha que \\(X \\sim \\mathcal{U}(0,1)\\). Obtenha a distribuição de \\(Y = -\\log(X)\\). Com base na distribuição da variável aleatória (v.a.) \\(Y\\) do exercício acima, implemente uma função em R que gere observações de \\(Y\\). Conhecendo a distribuição da v.a. \\(X\\), implemente para cada um dos itens que seguem, uma função para geração de observações da v.a. \\(Y\\): \\(X \\sim \\mathrm{Exp}(\\lambda),\\) com \\(x \\geq 0\\) e \\(\\lambda &gt; 0\\) e \\(Y = \\sum_{i = 1}^n X_i \\sim \\Gamma(n, \\lambda)\\); \\(X \\sim \\mathrm{Exp}(\\lambda)\\), com \\(x \\geq 0\\) e \\(\\lambda&gt;0\\) e \\(Y = \\mu - \\beta\\log(\\lambda X) \\sim \\mathrm{Gumbel}(\\mu,\\beta)\\), com \\(\\mu \\in \\Bbb{R}\\) e \\(\\beta&gt;0\\); \\(X \\sim \\mathcal{U}(0,1)\\) (contínua) e \\(Y = m + s[-\\log(X)]^{-1/\\alpha} \\sim\\) Fréchet\\((\\alpha,s,m)\\), com \\(x, \\alpha,s &gt; 0\\) e \\(m \\in \\Bbb{R}\\). Cite algumas das propriedades do gerador Mersenne Twister. Qual o seu período de ocorrência? Explique o algoritmo do método da aceitação e rejeição. Utilizando o método da aceitação e rejeição, implemente uma função que gere valores aleatório provenientes da distribuição da v.a. \\(X\\) tal que \\[P(X = 1) = 0.3, P(X = 2) = 0.2, P(X = 3) = 0.35, P(X = 4) = 0.15.\\] Implemente duas funções que geram observações da v.a. \\(X\\) utilizando o método da transformação para v.a. discretas e pelo método da aceitação e rejeição. Qual método é mais eficiente computacionalmente? Por que? \\[\\begin{eqnarray} P(X = 0) &amp;=&amp; 0.14, P(X = 1) = 0.27, P(X = 2) = 0.27,\\nonumber\\\\ P(X = 3) &amp;=&amp; 0.18, P(X = 4) = 0.09, P(X = 5) = 0.04, \\nonumber\\\\ P(X = 6) &amp;=&amp; 0.01. \\nonumber\\\\ \\end{eqnarray}\\] Implemente a função rdisc(n = 1L, x, probs) que retorna números pseudo-aleatórios de uma v.a. discreta \\(X\\) que assume uma quantidade finita de observações. Os argumentos de rdisc estão especificados abaixo: n: número de observações a serem geradas; x: vetor com as possíveis observações da v.a. \\(X\\); probs: vetor com as probabilidades das observações passadas à x. Implemente uma função para o método da aceitação e rejeição (ar_fp(n, x, prob)), para o caso em que deseja-se gerar observações de uma v.a. \\(X\\) discreta. O argumento n refere-se à quantidade de observações a serem geradas, x é um vetor de valores assumidos por \\(X\\) e prob é um vetor de probabilidades de cada observação de \\(X\\). A função ar_fp(n, x, prob) deverá escolher um valor adequado para \\(c\\). Seja \\(X\\) uma v.a. contínua com fdp \\(f(x) = 6x(x-1)\\), com \\(0 &lt; x &lt; 1\\). Implemente a função rf(n, c = 1.5) que gera números pseudo-aleatórios como observações de \\(X\\), pelo método da aceitação e rejeição, em que n é a quantidade de números a serem gerados e c é o valor da constante (0.5 por padrão) no algoritmo do método da aceitação e rejeição. Dica: considere \\(Y \\sim \\mathcal{U}(0,1)\\). Considerando a função rf(n, c) implementada no exercício anterior, quantos passos serão necessários para que possamos gerar 10 mil observações proveniente da distribuição de \\(X\\), considerando c = 6? Respectivamente, quantos passos serão necessários para serem gerados a mesma quantidade de observações de \\(X\\) considerando c = 0.5? Dica: antes de chamar a função implementada, fixe a semente fazendo set.seed(0). 6.2 Otimização Não-Linear Na estatísticas, em muitas simtuações práticas, temos o interesse de maximizar ou minimizar uma função objetivo. Por exemplo, na inferência esatística, é comum o nosso interesse na obtenção dos estimadores de máxima verossimilhança de parâmetros que indexam modelos ou distribuições de probabilidade. Um outro problema comum na estatística, mais precisamente na área de regressão é o de minimizar a soma dos quadrados de um conjunto de erros, em um modelo de regressão não-linear, por meio de mínimos quadrados não-lineares. Nota: Aqui, o termo otimizar estará se referindo à minimiar ou maximizar uma função objetivo. Dessa forma, por meio do contexto em que o termo esteja sendo utilizado, a ideia estará implícita. Além disso, por uma simples modificação na função objetivo, um algoritmo utilizado para maximizar uma função poderá ser convertido em um algoritmo para minimização de uma função. Suponha que temos interesse em maximizar uma função objetivo, seja ela \\(\\psi(\\pmb{\\Theta}): \\pmb{\\Theta} \\rightarrow \\mathbb{R}\\), em que \\(\\pmb{\\Theta}\\) é um subspaço do \\(\\mathbb{R}^p\\). Dessa forma, queremos encontrar o vetor \\(\\pmb{\\theta}\\) (\\(p \\times 1\\)) que maximiza a função objetivo \\(\\psi(\\cdot)\\). Ou seja, queremos encontar \\[ \\underset{\\pmb{\\theta}\\, \\in\\, \\pmb{\\Theta}}{\\mathrm{arg\\,max}}\\,\\psi(\\pmb{\\theta}).\\] A maioria das situações práticas nos levam à problemas com a condição de primeira ordem, \\[\\frac{\\partial\\,\\psi(\\pmb{\\theta})}{\\partial\\,\\pmb{\\theta}} = \\pmb{0},\\] resulta em um sistema de equações não-lineares que não apresenta solução em forma fechada. Nesses casos, a solução do problema de minimizar \\(\\psi(\\pmb{\\theta})\\) é obtida utilizando-se de métodos/algoritmos iterativos. 6.2.1 Metódos Gradiente A classe de métodos mais utilizadas em situações em que a condição de primeira ordem resulta em um sistema não-lineare que não possue forma fechada é denominada de classe de métodos gradiente. Nessa classe de métodos, a atualização de \\(\\pmb{\\theta}\\) para um vetor que mais se aproxima do ponto que minimiza \\(\\psi(\\cdot)\\) (função objetivo) é dada de forma iterativa. Dessa forma, seja \\(\\pmb{\\theta}_0\\) o ponto inicial (chute inicial) na \\(t\\)-ésima iteração. Se o valor de \\(\\pmb{\\theta}\\) que maximiza globalmente a função \\(\\psi(\\cdot)\\) não tiver sido alcançado, calcula-se o vetor direcional (vetor gradiente) de \\(\\psi(\\cdot)\\), denotado aqui por \\(\\pmb\\Delta_t\\) (\\(p \\times 1\\)) e o “tamanho do passo” \\(\\lambda_t\\). Assim, o próximo valor de \\(\\pmb\\theta\\) será atualizado para: \\[\\pmb\\theta_{t+1} = \\pmb\\theta_t + \\lambda_t \\pmb \\Delta_t.\\] Importante: O vetor gradiente fornece a direção e o sentido de deslocamento, apartir de um ponto especificado, de subida que fornece um incremento em uma grandeza. No nosso caso, \\(\\pmb\\Delta_t\\) (\\(p \\times 1\\)) irá indicar o sentido de subida, em que poderemos atualizar o valor de \\(\\pmb \\theta\\) para um ponto que maximiza \\(\\psi(\\cdot)\\). Dessa forma, \\(-\\pmb\\Delta_t\\) fornecerá a direção e o sentido de atualização de \\(\\pmb\\theta\\) que nos levam à pontos que minimizam \\(\\psi(\\cdot)\\). Note também que, em cada iteração do algoritmo, temos \\(\\pmb \\theta_t\\) e \\(\\pmb \\Delta_t\\) são conhecidos, uma vez que \\(\\pmb \\theta_t\\) é o ponto \\(\\pmb \\theta\\) atualizado na iteração \\(t-1\\) e \\(\\pmb \\Delta_t\\) é o vetor gradiente da função objetivo avaliado em \\(\\pmb \\theta_t\\). Dado o conhecimento dessas quantidade, perceba que precisamos obter o “tamanho do passo” \\(\\lambda_t\\). Assim, iremos recair em um problema de otimização secundário, denominado de procura em linha. Sendo assim, busca-se \\(\\lambda_t\\) de tal forma que \\[\\frac{\\partial \\pmb\\,\\psi(\\pmb \\theta_t + \\lambda_t\\pmb\\Delta_t)}{\\partial \\lambda_t} = \\delta(\\pmb \\theta_t + \\lambda_t\\pmb\\Delta_t)^{&#39;}\\pmb \\Delta_t = 0,\\] em que \\(\\delta(\\pmb \\theta_t + \\lambda_t\\pmb\\Delta_t)^{&#39;}\\) é o vetor gradiente tansposto (\\(1 \\times p\\)) da função objetivo avaliado no ponto \\(\\pmb \\theta_t + \\lambda_t\\pmb\\Delta_t.\\) Figura 6.1: Poblema de procura em linha, em que a função objetivo é função penas do tamanho do passo. Observação: É importante observar que o processo de busca em linha em um algoritmo de otimização não-linear tornará esse algoritmo computacionalmente intensivo. Dessa forma, muitos algoritmos adotam um conjunto de regras ad hoc que são computacionalmente menos custosas. Essa classe de algoritmos é o que denominamos de classe de métodos gradiente. Na classe de métodos gradiente, fazemos \\[\\pmb \\Delta_t = M_t\\delta_t,\\] em que \\(M_t\\) (\\(p \\times p\\)) é uma matriz positiva-definida e \\(\\delta_t\\) (\\(p \\times 1\\)) é o gradiente de \\(\\pmb\\psi\\), ambos na \\(t\\)-ésima iteração. Para deixar claro, temos que \\(\\delta_t\\) = \\(\\delta_t(\\pmb \\theta_t) = \\partial \\, \\psi(\\pmb \\theta_t)/\\partial\\, \\pmb \\theta_t\\). A motivação por trás dos métodos gradientes, ao em tomar \\(\\pmb \\Delta_t = M_t\\delta_t\\), poderá ser entendida ao considerar uma aproximação para \\(\\psi(\\pmb \\theta_t + \\lambda_t\\pmb\\Delta_t)\\) por uma série de Taylor de primeira ordem, em torno do ponto \\(\\lambda_t = 0\\). Assim, temos que, \\[\\psi(\\pmb \\theta_t + \\lambda_t\\pmb\\Delta_t) \\approx \\psi(\\pmb \\theta_t) + \\lambda_t \\delta_t^{&#39;}\\pmb \\Delta_t,\\] em que \\(\\delta_t^{&#39;}\\) é o vetor gradiente transposto (\\(1 \\times p\\)). Para reduzir a notação, tome \\(\\psi(\\pmb \\theta_t + \\lambda_t\\pmb\\Delta_t) = \\psi_{t+1}\\). Assim, temos que \\[\\psi_{t+1} - \\psi_{t} \\approx \\lambda_t \\delta_t^{&#39;}\\pmb \\Delta_t.\\] Assim, considerando \\(\\pmb \\Delta_t = M_t\\delta_t\\), temos que \\[\\psi_{t+1} - \\psi_{t} \\approx \\lambda_t \\delta_t^{&#39;}M_t\\delta_t.\\] Para \\(\\delta_t\\) diferente de zero e \\(\\lambda_t\\) suficientemente pequeno, se \\(\\psi(\\pmb\\theta)\\) não assume o valor máximo da função, podemos sempre encontrar um tamanho de passo tal que uma iteração adicional no algoritmo irá incrementar o valor da função, ou seja, se aproximará um pouco mais do máximo global da função objetivo. Perceba que sempre temos que \\(\\psi_{t+1} - \\psi_{t} \\geq 0\\). Isso sempre será verdade, uma vez que \\(M_t\\) é uma matriz positiva-definida, o que implica que \\(\\delta_t^{&#39;}M_t\\delta_t &gt; 0\\). Além disso, na situação de \\(\\psi(\\pmb\\theta)\\) não encontar-se no ponto máximo, como mencionado no parágrafo anterior, sempre haverá um tamanho de passo \\(\\lambda_t\\), por menor que ele seja. 6.2.1.1 Steepest Ascent O algoritmo steepest ascent (“subida mais inclinada”) é o mais simples dos métodos gradientes. A ideia do algoritmo steepest ascent é considerar \\[M_t = I,\\] em que \\(I\\) é a matriz identidade (\\(p \\times p\\)). Dessa forma, temos que \\(\\pmb \\Delta_t = \\delta_t\\), em todos os passos iterativos. Daí, a atualização de \\(\\pmb \\theta\\) é dada por: \\[\\pmb \\theta_{t+1} = \\theta + \\lambda_t\\delta_t.\\] Nota: Esse algoritmo tende a ser pouco utilizado na prática, uma vez que apresenta convergência lenta. Esse método é muito semelhante ao algoritmo gradiente descendente steepest descent, utilizado para minimização. Não confunda steepest descent citado aqui com um método de aproximação de integrais que leva o mesmo nome. 6.2.1.2 Newton-Raphson O método de Newton-Raphson, muitas vezes apenas chamado de método de Newton, considera a atualização de \\(\\pmb \\theta\\) na forma \\[\\pmb \\theta_{t+1} = \\pmb \\theta_t -H_t^{-1}\\delta_t,\\] em que \\[H = H(\\theta) = \\frac{\\partial^2 \\psi(\\pmb \\theta)}{\\partial \\pmb \\theta \\partial \\pmb \\theta^{&#39;}},\\] ou seja, temos que \\(H\\) é a matriz hessiana. No método de Newton-Rapshon, temos que \\(\\lambda_t = 1\\) e \\(M_t = -H_t^{-1}\\), em todas iterações. Observação: A matriz hessiana nos permite identificar a concavidade de uma função multiparamétrica, desde que estas sejam duplamente diferenciável. Em um problema de maximização de uma função objetivo, temos que a matriz hessiana é negativa definida em uma região muito próxima ao ponto que maximiza a função. Dessa forma, \\(-H^{-1}\\) é uma matriz positiva definida na mesma região, isto é, se \\(\\pmb a\\) é um vetor qualquer (\\(p \\times 1\\)) e \\(H^{-1}\\) é uma matriz (\\(p \\times p\\)), então \\(-\\pmb a^{&#39;} H^{-1} \\pmb a &lt; 0\\). Seja \\(H\\) uma matriz hessiana como apresentada acima. Abaixo estão listadas algumas propriedades da de \\(H\\). Dessa forma, Então \\(\\pmb a^{&#39;} H \\pmb a &gt; 0\\) (positiva-definida): A função é estritamente convexa; \\(\\pmb a^{&#39;} H \\pmb a &lt; 0\\) (negativa-definida): A função é estritiamente concava. Essa é a propriedade que estamos considerando, visto que estamos em um problema de maximização de uma função objetivo; \\(\\pmb a^{&#39;} H \\pmb a \\geq 0\\) (positiva-definida): A função é parcialmente convexa; \\(\\pmb a^{&#39;} H \\pmb a \\leq 0\\) (positiva-definida): A função é parcialmente concava; \\(H\\) é uma matriz simétrica; A inversa de uma matriz positiva-definida é também uma matriz positiva-definida; Você poderá entender a matriz hessiana como a primeira derivada do vetor gradiente da função objetivo. O método de Newton-Raphson normalmente é utilizado para encontar os zeros de uma função. Quando aplicado sobre a condição de primeira ordem, o método de Newton-Raphson nos conduzirá aos pontos críticos da função. Como fazemos uso do vetor gradiente, estaremos sempre a caminhar para os pontos de máximo de \\(\\psi(\\cdot)\\). Dessa forma, os pontos críticos são os pontos de máximo da função objetivo. Para que possamos entender melhor a ideia do método, considere uma expansão de Taylor da condição de primeira ordem em torno de um ponto qualquer \\(\\pmb \\theta_0\\). Assim, temos que \\[\\frac{\\partial\\,\\psi(\\pmb \\theta)}{\\partial\\, \\pmb \\theta} \\approx f(\\pmb \\theta_0) + H(\\pmb \\theta_0) (\\pmb \\theta - \\pmb\\theta_0).\\] Resolvendo o sistema para \\(\\pmb\\theta\\) e fazendo \\(\\pmb \\theta = \\pmb \\theta_{t+1}\\) e \\(\\pmb \\theta_0 = \\pmb \\theta_t\\), obteremos o esquema iterativo do algoritmo apresentado ascima. A forma mais usual do algoritmo de Newton-Rapshon introduz o mecanismo de “procura em linha”. Dessa forma, o esquema iterativo é dada por \\[\\pmb \\theta_{t+1} = \\pmb \\theta_t -\\lambda_tH_t^{-1}\\delta_t.\\] Nota: O método de Newton-Raphson apesar de funcionar bem em diversas situações, poderá fornecer estimativas ruins em alguns casos. Por exemplo, um problema comum é quando \\(\\pmb \\theta_t\\) é um ponto distante do ponto que maximiza \\(\\psi(\\cdot)\\), uma vez que nesses pontos, a matriz \\(M_t = -H^{-1}\\) pode não ser positiva-definida. 6.2.1.3 BHHH O método BHHH (Berndt-Hall-Hall-Hausman), foi proposto no artigo Berndt, E. R., Hall, B. H., Hall, R. E., &amp; Hausman, J. A. (1974). Estimation and inference in nonlinear structural models. In Annals of Economic and Social Measurement, Volume 3, p. 653-665. O método é muito semelhante ao método de Newton-Raphson, com a diferença que trocamos a matriz \\(H_t\\) pelo auto produto dos vetores gradientes \\(\\delta_t\\delta_t^{&#39;}\\) Nota: A vantagem do método BHHH está no fato de não necessitarmos calcular segundas derivadas. Trata-se de um método muito utilizado em aplicações ecnonométricas. O método BHHH poderá enfrentar o mesmo problema de convergência que o método de Newton-Raphson. 6.2.1.4 Métodos quasi-Newton A classe de algoritmos quasi-Newton é composta por algoritmos que são bastante eficientes do ponto de vista de convergência e também do ponto de vista computacional, visto que esses algoritmos não requerem o cálculo de segundas derivadas. Nessa classe de algoritmos, é utilizado uma sequência de matrizes tal que \\[M_{t+1} = M_{t} + N_t,\\] sendo \\(N_t\\) uma matriz positiva-definida. Assim, se \\(M_0\\) é positiva-definida, \\(M_t\\) na \\(t\\)-ésima iteração sempre será positiva-definida. A ideia básica desses métodos é construir uma aproximação para \\(-H(\\pmb \\theta)^{-1}\\), de tal forma que \\[\\lim_{t \\to \\infty} M_t = -H^{-1}.\\] Há diversos algoritmos que pertencem à classe de métodos quasi-Newton. Por exemplo, o método DFP (Davidon, Fletcher e Powell) atualiza \\(M_{t+1}\\) fazendo \\[M_{t+1} = M_{t} + \\frac{\\pmb \\gamma_t \\pmb \\gamma_t^{&#39;}}{\\pmb \\gamma_t^{&#39;}\\kappa_t} + \\frac{M_t\\kappa_t\\kappa_t^{&#39;}M_t}{\\kappa_t^{&#39;}M_t\\pmb \\gamma_t},\\] em que \\(\\pmb \\gamma_t = \\pmb \\theta_{t+1} - \\pmb \\theta_t\\) (diferença de pontos) e \\(\\kappa_t = \\delta(\\pmb \\theta_{t+1}) - \\delta(\\pmb \\theta_t)\\) (diferenças de gradientes avaliados em pontos). O algoritmo quasi-Newton mais utilizado é o BFGS (Broyden-Fletcher-Goldfarb-Shanno). O algoritmo BFGS tem a atualização semelhante ao DFP, com a diferença que é subtraído o termo \\(a_tb_tb_t^{&#39;}\\), em que \\(a_t = \\kappa_t^{&#39;}M_t\\kappa_t\\) e \\[b_t = \\frac{\\pmb\\gamma_t}{\\pmb\\gamma_t^{&#39;}\\kappa_t} - \\frac{M_t\\kappa_t}{\\kappa_t^{&#39;}M_t \\kappa_t}.\\] Sendo assim, temos que no método BFGS, a atualização de \\(M_t\\) de dará por: \\[M_{t+1} = M_{t} + \\frac{\\pmb \\gamma_t \\pmb \\gamma_t^{&#39;}}{\\pmb \\gamma_t^{&#39;}\\kappa_t} + \\frac{M_t\\kappa_t\\kappa_t^{&#39;}M_t}{\\kappa_t^{&#39;}M_t\\pmb \\gamma_t} - a_tb_tb_t^{&#39;}.\\] Nota: O termo quasi-Newton é empregado para se referir ao fato de que esses métodos não fazem uso da matriz hessiana. Porém, esses métodos utilizam uma aproximação iterativa de uma matriz \\(M_t\\) que converge para a matriz de segundas derivadas. Dessa forma, não entenda o termo quasi-Newton como se esses métodos fossem inferiores aos métodos de Newton-Raphson. Na verdade, os métodos quasi-Newton normalmente apresentam desempenho superior. 6.2.1.5 Otimização não-linear no R Em R, é comum minimizar uma função objetivo utilizando a função optim() do pacote stats que está disponível em qualquer instalação básica da linguagem. A forma geral de uso da função optim() é: optim(par, fn, gr = NULL, ..., method = c(&quot;Nelder-Mead&quot;, &quot;BFGS&quot;, &quot;CG&quot;, &quot;L-BFGS-B&quot;, &quot;SANN&quot;, &quot;Brent&quot;), lower = -Inf, upper = Inf, hessian = FALSE) em que: par é um vetor de chutes inicias; fn é a função objetivo a ser minimizada; gr é a função gradiente da função fn; method é o método escolhido par minimizar fn. É possível escolher os métodos de Nelder-Mead, BFGS, CG, L-BFGS-B, SANN (Simulated Annealing) e Brent; ... é o operador dot-dot-dot que poderá receber argumentos que por ventura possam existir nas funções fn e gr; lower é um vetor que limita inferiormente os parâmetros a serem otimizados (por padrão é -Inf); upper é um vetor que limita superiormente os parâmetros a serem otimizados (por padrão é Inf); hessian recebe um valor lógico, em que por padrão hessian = FALSE. Se hessian = TRUE, será calculado uma estimativa da matriz hessiana avaliada na estimativa de ponto de mínimo global. Exemplo: Utilizando a função optim() para minimizar a função Rosenbrock pelo método BFGS. Figura 6.2: Gráfico da superfície da função Rosenbrock introduzida por Howard H. Rosenbrock em 1960. # Função Rosenbrock f_objetivo &lt;- function(x, a = 2, b = 40) { x1 &lt;- x[1] x2 &lt;- x[2] (a - x1) ^ 2 + b * (x2 - x1 ^ 2) ^ 2 } optim(par = c(2, 2), fn = f_objetivo, method = &quot;BFGS&quot;) ## $par ## [1] 1.999998 3.999992 ## ## $value ## [1] 2.761362e-11 ## ## $counts ## function gradient ## 128 45 ## ## $convergence ## [1] 0 ## ## $message ## NULL Entendendo a saída (retorno da função): par é um vetor contendo as estimativas para \\(x_1\\) e \\(x_2\\); value é o valor da função avaliada nas estimativas obtidas; counts é a quantidade de chamadas da função a ser otimizada e do seu gradiente. Note que não passamos o gradiente da função de objetivo mas este teve que ser calculado numericamente; convergence é um vetor de uma única posição, em que 0 indica convergência. Qualquer número diferente de zero indica que houve problema de convergência no algoritmo escolhido para mininizar a função objetivo; message retorna alguma mensagem com informações adicionais, se necessário. Caso contrário, NULL será o retorno. A função de Rosenbrock tem mínimo analítico no ponto \\((a, a^2)\\) (ponto ótimo), em que \\(f(a, a^2) = 0\\). Dessa forma, um bom método de otimização nos trará uma estimativa próxima ao ponto \\((2, 4)\\), uma vez que foi considerado, no código acima, \\(a = 2\\) e \\(b = 40\\). Como pode-se observar, o método BFGS forneceu uma boa estimativa para ponto ótimo analítico. Nota: Para o exemplo acima, \\(x_1\\) e \\(x_2\\) são chamadas de variáveis, visto que a função de Rosenbrock é determinística. Porém, em problemas estatísticos, por exemplo, quando desejamos maximizar uma função de log-verossimilhança, a otimização é realizada em termos dos parâmetros que indexam o modelo estatístico. Nesse caso, cada ponto da função O argumento ... é muito importante para nós que necessitamos frequentemente maximizar uma função de log-vessimilhança \\(\\mathcal{l}(\\pmb \\theta)\\). É por meio desse argumento que passamos a amostra para \\(\\mathcal{l}(\\pmb \\theta)\\). Sem ele, teríamos que implementa uma função de verossimilhança para cada tamanho de amostra, o que seria impraticável. Com a amostra especificada, poderemos proceder a minimização de \\(-\\mathcal{l}(\\pmb \\theta)\\) e obter o vetor \\(\\pmb \\theta\\) com as estimativas de máxima verossimilhança dos parâmetros que indexam um modelo probablístico. Exemplo: Considere o conjunto de dados obtido abaixo: set.seed(0L) dados &lt;- rnorm(n = 750L, mean = 2, sd = 1) Seja \\(X_1, \\ldots, X_n\\) uma amostra aleatória (v.a.’s i.i.d), em que \\(X_i \\sim \\mathcal{N}(\\mu = 2, \\sigma^2 = 1)\\, \\forall i\\). Obtenha pelo método BFGS os estimadores de máxima verossimilhança para \\(\\mu\\) e \\(\\sigma^2\\). Seja \\(\\mathcal{l(\\pmb\\theta)}\\) a função de verossimilhança para amostra e \\(\\pmb \\theta^{&#39;} = (\\mu, \\sigma^2)\\). Precisaremos implementar a função de verossmilhança e multiplica-la por -1, uma vez que minimizando \\(-\\mathcal{l}(\\pmb \\theta)\\) equivale à maximizar \\(\\mathcal{l}(\\pmb \\theta)\\). set.seed(0L) dados &lt;- rnorm(n = 750L, mean = 2, sd = 1) # Função de log-verssimilhança da amostra aleatória. loglikelihood_normal &lt;- function(par, x){ mu &lt;- par[1] sigma2 &lt;- par[2] -sum(log(dnorm(x, mean = mu, sd = sqrt(sigma2)))) } # maximizando -log-likelihood da amostra aleatória. resultado &lt;- optim(par = c(1, 1), fn = loglikelihood_normal, method = &quot;BFGS&quot;, x = dados) # Graficando a densidade estimada sobre os dados ---------------------------------- # Sequência no domínio da distribuição: x &lt;- seq(-5, 6, length.out = 1000L) y &lt;- dnorm(x = x, mean = resultado$par[1], resultado$par[2]) # Histograma das observações: hist(x = dados, main = &quot;Função Densidade de Probabilidade Estimada&quot;, ylab = &quot;Probabilidade&quot;, xlab = &quot;x&quot;, probability = TRUE, col = rgb(1, 0.9, 0.8), border = NA) # Tracejando a densidade sobre o histograma: lines(x, y, lwd = 2) Importante: Nunca esqueça que minimizar \\(-f\\) é equivalente a maximizar \\(f\\), sendo tabém verdadeira a recíproca. Além disso, lembre-se também que a função optim() é implementada de forma a minimizar uma função objetivo. Exercício Defina matematicamente o método gradiente para maximização de uma função \\(\\psi(\\pmb{\\theta}): \\pmb{\\Theta} \\rightarrow \\mathbb{R}\\), em que \\(\\pmb{\\Theta}\\) é um subespaço do \\(\\mathbb{R}^p\\). Qual a desvantagem do uso do processo de busca em linha em algoritmos de otimização não-linear? Defina os métodos quasi-Newton e o que os diferenciam dos de Newton? Qual as vantagens que a maioria desses métodos apresentam com relação aos métodos de Newton? Enuncie os métodos Steepest Ascent, Newton-Raphson e BHHH. Esses são métodos de Newton ou quasi-Newton? Explique. Considere a função abaixo: \\[f(\\theta) = 6 + \\theta ^ 2 \\times \\sin(14\\theta),\\] em que \\(-2.5 \\leq \\theta \\leq 2.5\\). Obtenha uma estimativa para o ponto de máximo global dessa função. Houve convergência? Explique. Além disso, construa um gráfico da função \\(f(\\theta)\\) destacando o ponto de máximo no gráfico da função. Considere a Matyas function, função definida logo abaixo: \\[f(x, y) = 0.26 \\times (x^2 + y^2) - 0.48 \\times xy,\\] em que \\(0 \\leq x, y ,\\leq 10\\). Qual o ponto de mínimo global da função? Obtenha uma estimativa, utilizando o método BFGS, para o ponto de mínimo global da função. Além disso, construa o gráfico da superfície obtida pela função e o gráfico com as curvas de níveis da função com a estimativa obtida indicada como um ponto nesse último gráfico. Interprete o resultado obtido. Houve convergência? Considere a Himmelblau’s function, função definida por: \\[f(x, y) = (x^2 + y -11)^2 + (x + y^2 - 7)^2,\\] com \\(-5 \\leq x,y \\leq 5\\). Essa função possui quatro pontos de mínimo global, são eles: \\[ \\mathrm{Min} = \\left \\{ \\begin{array}{rcc} f(3.0, 2.0) &amp; = &amp; 0.0 \\\\ f(-2.805118, 3.131312) &amp; = &amp; 0.0 \\\\ f(-3.779310, -3.283186) &amp; = &amp; 0.0 \\\\ f(3.584428, -1.848126) &amp; = &amp; 0.0 \\end{array} \\right. \\] Obtenha uma estimativa, utilizando o método BFGS, para o ponto de mínimo global da função. Além disso, construa o gráfico da superfície obtida pela função e o gráfico com as curvas de níveis da função com a estimativa obtida indicada como um ponto nesse último gráfico. Interprete o resultado obtido. Houve convergência? Considere a Earson function, função definida abaixo: \\[f(x,y) = -\\cos(x)\\cos(y)\\exp\\{-[(x-\\pi)^2 + (y-\\pi)^2]\\},\\] em que \\(-100 \\leq x,y \\leq 100\\). Essa função possui mínimo global no ponto \\((\\pi,\\pi)\\), com \\(f(\\pi,\\pi) = -1\\). Obtenha uma estimativa, utilizando o método BFGS, para o ponto de mínimo global da função. Além disso, construa o gráfico da superfície obtida pela função e o gráfico com as curvas de níveis da função com a estimativa obtida indicada como um ponto nesse último gráfico. Interprete o resultado obtido. Houve convergência? O que você observa variando os chutes iniciais? Por que os métodos de Newton ou quasi-Newton apresentam dificuldades de otmizar uma função objetivo como a função do exercício logo acima? Explique. Considere Hölder table function, função definida como: \\[f(x,y) = - \\left| \\sin(x) \\cos(y) \\exp \\left( \\left| 1 - \\frac{\\sqrt{x^2 + y^2}}{\\pi} \\right| \\right) \\right|,\\] em que \\(-10 \\leq x,y \\leq 10\\). Essa função possui mínimos globais em: \\[ \\mathrm{Min} = \\left\\{ \\begin{array}{ccc} f(8.05502,\\, 9.66459) &amp; = &amp; -19.2085 \\\\ f(-8.05502,\\, 9.66459) &amp; = &amp; -19.2085 \\\\ f(8.05502,\\, -9.66459) &amp; = &amp; -19.2085 \\\\ f(-8.05502,\\,-9.66459) &amp; = &amp; -19.2085 \\\\ \\end{array} \\right. \\] Obtenha uma estimativa, utilizando o método BFGS, para o ponto de mínimo global da função. Além disso, construa o gráfico da superfície obtida pela função e o gráfico com as curvas de níveis da função com a estimativa obtida indicada como um ponto nesse último gráfico. Interprete o resultado obtido. Houve convergência? Considere a Eggholder function, função definida como: \\[f(x,y) = -(y + 47)\\sin \\left(\\sqrt{\\left|\\frac{x}{2} + (y + 47)\\right|}\\right) - x\\sin(\\left|x - (y + 47)\\right|),\\] em que \\(-512\\leq x,y \\leq 512\\). Essa função possui mínimo global no ponto \\((512, 404.2319)\\), assumiando o valor mínio, nesse ponto, em \\(-959.6407\\). Obtenha uma estimativa, utilizando o método BFGS, para o ponto de mínimo global. Além disso, construa o gráfico da superfície e o gráfico com as curvas de níveis, em que este último deverá apresentar o ponto da estimativa obtida. Houve convergência? Nadarajah e Haghighi (2011) propuseram a distribuição de probabilidade Nadarajah-Haghighi (NH), em que se \\(X\\) é uma v.a. tal que \\(X \\sim \\mathrm{NH}(\\alpha, \\lambda)\\), então a f.d.p. da v.a. \\(X\\) é dada por: \\[f_X(x) = \\alpha \\lambda (1 + \\lambda x)^{\\alpha - 1}\\exp\\{1 - (1 + \\lambda x)^\\alpha\\},\\] com \\(x &gt; 0\\) e \\(\\alpha, \\lambda &gt; 0\\). Perceba para \\(\\alpha = 1\\), obtemos a f.d.p. de uma v.a. com distribuição exponencial com parâmetro \\(\\lambda\\). Considere o conjunto de dados: 1.7, 2.2, 14.4, 1.1, 0.4, 20.6, 5.3, 0.7, 1.9, 13.0, 12.0, 9.3, 1.4, 18.7, 8.5, 25.5, 11.6, 14.1, 22.1, 1.1, 2.5, 14.4, 1.7, 37.6, 0.6, 2.2, 39.0, 0.3, 15.0, 11.0, 7.3, 22.9, 1.7, 0.1, 1.1, 0.6, 9.0, 1.7, 7.0, 20.1, 0.4, 2.8, 14.1, 9.9, 10.4, 10.7, 30.0, 3.6, 5.6, 30.8, 13.3, 4.2, 25.5, 3.4, 11.9, 21.5, 27.6, 36.4, 2.7, 64.0, 1.5, 2.5, 27.4, 1.0, 27.1, 20.2, 16.8, 5.3, 9.7, 27.5, 2.5, 27.0. 1 - Obtenha as estimativas de máxima verossimilhança, pelo método BFGS, para os parâmetros \\(\\alpha\\) e \\(\\lambda\\) que indexam \\(f_X(x)\\). 2 - Construa o histograma dos dados e sobreponha a f.d.p. estimada sobre o histograma. 3 - A densidade estimada parece ajusta-se bem ao conjunto de dados? 4 - Houve convergência do método BFGS? 5 - Em caso de haver convergência, ela é suficiente para garantir de a \\(f_X(x)\\) irá modelar o conjunto de dados? Explique. Refaça o exercício acima considerando o conjunto de dados: 0.08, 2.09, 3.48, 4.87, 6.94, 8.66, 13.11, 23.63, 0.20, 2.23, 3.52, 4.98, 6.97, 9.02, 13.29, 0.40, 2.26, 3.57, 5.06, 7.09, 9.22, 13.80, 25.74, 0.50, 2.46, 3.64, 5.09, 7.26, 9.47, 14.24, 25.82, 0.51, 2.54, 3.70, 5.17, 7.28, 9.74, 14.76, 26.31, 0.81, 2.62, 3.82, 5.32, 7.32, 10.06, 14.77, 32.15, 2.64, 3.88, 5.32, 7.39, 10.34, 14.83, 34.26, 0.90, 2.69, 4.18, 5.34, 7.59, 10.66, 15.96, 36.66, 1.05, 2.69, 4.23, 5.41, 7.62, 10.75, 16.62, 43.01, 1.19, 2.75, 4.26, 5.41, 7.63, 17.12, 46.12, 1.26, 2.83, 4.33, 5.49, 7.66, 11.25, 17.14, 79.05, 1.35, 2.87, 5.62, 7.87, 11.64, 17.36, 1.40, 3.02, 4.34, 5.71, 7.93, 11.79, 18.10, 1.46, 4.40, 5.85, 8.26, 11.98, 19.13, 1.76, 3.25, 4.50, 6.25, 8.37, 12.02, 2.02, 3.31, 4.51, 6.54, 8.53, 12.03, 20.28, 2.02, 3.36, 6.76, 12.07, 21.73, 2.07, 3.36, 6.93, 8.65, 12.63, 22.69. 6.3 Monte Carlo 6.3.1 Um breve histórico Os métodos de Monte Carlo (MC) é uma classe de metodologias bastante utilizada na estatística moderna. De um modo geral, tais metodologias calculam quantidades sob amostras aleatórias que são gerada/obtidas de forma iterativa, em que ao final obtem-se estatísticas de interesse com base nos resultados armazenados. Os métodos de MC, por exemplo, poderão ser utilizado para estimar parâmetros da distribuição amostral de uma estatística e para o cálculo do erro quadrático médio (EQM). Estudos de MC podem ser projetados para avaliar a probabilidade de cobertura para a confinaça de um intervalo aleatório ou para avaliação do Erro Tipo I em um procedimento de teste de hipóteses. Esses são apenas alguns exemplo do uso dos métodos de MC. Os métodos de MC auxiliam muito os estatísticos no processo de compararem modelos/estatísticas, em que cada um(a) desses modelos/estatísticas serão submetidos à amostras com “características” prefixadas. Normalmente essas comparações serão realizadas em situações em que evidências analíticas não são possíveis de serem obtidas devido à complexidade dos modelos/estatísticas envolvidas. Além da estatística, os métodos de MC são bastante utilizados por profissionais em campos díspares como finanças, engenheria, física, biologia, entre outros. Nota: Para implementar um método de MC é necessário ter uma fonte de geração de números pseudo-aleatórios além da capacidade de controlarmos a sequência de números gerados. No R, como vimos anteriormente, teremos a nossa disposição diversas funções para a geração de números pseudo-aleatórios uniforme e não-uniformes e poderemos controlar a sequência gerada utilizando a função set.seed(). De acordo com Hammersley, no livro Monte Carlo Methods, 1964, o nome “Monte Carlo” surgiu durante o projeto Manhattan na época da Segunda Guerra Mundial. O Projeto Manhattan foi liderado pelos Estados Unidos com o apoio do Reino Unido e Canadá. O projeto tinha como objetivo desenvolver pesquisas para a produção das primeiras bombas atômicas durante o período de guerra. O projeto foi uma das maiores colaborações científicas já realizadas que deram origem a inúmeras novas tecnologias, indo muito além do aproveitamente da fissão nuclear. Figura 6.3: Primeiro teste nuclear (nome de código Trinity), uma das três bombas atômicas produzidas pelo Projeto Manhattan. Teste realizado em 16 de julho de 1945. Com apenas 0.025 segundos após a detonação, o impacto já tomava conta de uma região com 100 metros de diâmetro. O Projeto Manhattan foi conduzido no Laboratório Nacional de Los Alamos, construído para desenvolver as primeiras bombas atômicas utilizadas na Segunda Guerra Mundial. À época, tratava-se de um centro secreto das forças aliadas para o desenvolvimento de armas nucleares conhecido por Site Y. Atualmente o laboratório trata-se de uma das maiores instituições científicas multidisciplinares. Figura 6.4: Laboratório de Los Alamos, laboratório federal pertencente ao Departamento de Energia dos Estados Unidos (DOE), gerido pela Universidade da Califórnia, localizado em Los Alamos, Novo México. O Laboratório Nacional de Los Alamos, em toda sua história, reuniu diversos cientistas catedráticos e ganhadores de prêmios importantes como, por exemplo, o Prêmio Nobel. Na época da Segunda Guerra, diversos cientisticas de grande importância para o desenvolvimento científico e tecnológico atual faziam parte do projeto como Stanislaw Ulam, Richard Feynman e John von Neumann. Figura 6.5: John von Neumann, Richard Feynman e Stanislaus Ulam em Los Alamos durante o Projeto Manhattan (da direita para a esquerda). No ano de 1946, enquanto se recuperava de uma encefalite, o matemático Stanislaw Ulam jovava paciência. Ele tentou calcular as probabilidades de alguns eventos no jogo utilizando análise combinatória. Porém, percebeu que uma alternativa mais prática seria realizar inúmeras jogadas e contar quantas vezes cada resultado ocorria, ou seja, utilizar a teoria frequentista de probabilidade. Detalhes sobre essa história poderá ser encontrada em Stam Ulam, John Von Neumann, and the Monte Carlo method, Los Alamos Science n. 15, pg 131 (1987), artigo livre e disponibilizado pela Los Alamos National Laboratory Research Library. Nesse artigo é apresentado trechos de cartas trocadas entre John von Neuman e Stanislau Ulam. O documento também apresenta uma descrição de 1983 que ajudou a entender a origem dos métodos de Monte Carlo realizada por Stanislaw Ulam, um ano antes do seu falecimento. Abaixo segue uma tradução aproximada do que foi dito: “Os primeiros pensamentos e tentativas que fiz para praticar [o método de Monte Carlo] foram sugeridos por uma questão que me ocorreu em 1946, quando eu estava convalescendo de uma doença e jogando paciência. A questão é quais são as chances de um jogador sair com sucesso em um jogo de paciência com 52 cartas? Depois de passar muito tempo tentando estimar, por puro cálculo de combinação, eu me perguntei se um método mais prático que o pensamento abstrato não seria expor cem vezes e simplesmente contar o número de jogadas bem-sucedidas. Isso já foi possível prever com o início da nova era de computadores rápidos, e eu imediatamente pensei em problemas de difusão de nêutrons e outras questões de física/matemática, e mais genericamente como mudar processos descritos por certas equações diferenciais em uma forma equivalente interpretável como uma sucessão de operações aleatórias. Mais tarde, … [em 1946, eu] descrevi a ideia à John von Neumann e começamos a planejar cálculos reais.” — Stanislaw Ulam. Ulam entendia que as técnicas de amostragem não eram muito utilizadas por envolverem cálculos extremamente demorados, tediósos e sujeito à erros, em uma época em que utilizavam-se dispositivos meânicos para realização de cálculos. Porém, nessa época surgiu o primeiro computador eletrônico, o ENIAC. Embora muito mais lento que os computadores atuais, o ENIAC impressionou Ulam que sugeriu o uso de técnicas de amostragem estatística e da teoria frequentista de probabilidade para simular a difusão de nêutrons em materiais sujeitos à fissão nuclear. O físico Nicholas Metropolis, que também participou do Projeto Manhattan sugeriu o nome Monte Carlo para o método estatístico. O nome foi inspirado em um tio de Ulam que sempre tomava dinheiro emprestado com parentes para ir jogar no cassino de Monte Carlo, no distrito de Monte Carlo, em Mônaco. Figura 6.6: Le Casino de Monte-Carlo, complexo de jogos e entretenimento localizado no distrito de Monte Carlo, Mônaco. Esse fato pode ser lido no artigo The Beginning of the Monte Carlo Method, escrito por Nicholas Metropolis, Los Alamos, 1987, um outro artigo livre e também disponibilizado pela Los Alamos National Laboratory Research Library. Nicholas Metropolis é também responsável pelo desenvolvimento de trabalhos que deram origem ao algoritmo de Mepropolis-Hastings, método de MC muito utilizado na geração de números pseudo-aleatórios de distribuições multidimensionais, especialmente quando o número de dimensões é alto. 6.3.2 Métodos de Monte Carlo Nos dias atuais, é muito mais fácil codificar uma simulação de MC para obetenção de aproximações que poderiam ser complicadas de serem obtidas analiticamente. Porém, os procedimentos de MC podem ser utilizados para resolver um problema deterministo. Por exemplo, é possível construir um procedimento de MC para aproximar o valor médio de uma função, bem como para calcular uma integral definida de uma função contínua em um intervalo \\([a, b]\\), sendo estes exemplos notoriamente determinísticos. Porém, os procedimentos de MC são procedimentos que fazem uso de amostragem aleatória massiva para a obtenção de resultados numéricos aproximados. Por exemplo, o método da aceitação e rejeição, apresentado em seções anteriores, é um típico procedimento de MC, uma vez que o método é iterativo e em suas iterações faz uso de geração de observações de uma sequência de variáveis aleatórias. O exemplo que segue mostra a construção de um procedimento simples de MC para o cálculo aproximado do valor médio de uma função. Exemplo: Calculando o ponto médio de uma função determinística utilizando simulações de MC. Seja \\(h(x) = \\mathrm{sen}(x)\\), tal que \\(x \\in [0, 2\\pi]\\). Então, analiticamente, o ponto médio da função \\(h(x)\\) é dado por: \\[\\overline{h} = \\frac{1}{2\\pi} \\int_0^{2\\pi} \\mathrm{sen}(x) dx = \\frac{1}{2\\pi}[-\\cos(x)] \\Big|_0^{2\\pi} = -\\frac{1}{2\\pi}[\\cos(2\\pi) - \\cos(0)] = -\\frac{1}{2\\pi}\\times 0 = 0.\\] Lembre-se: O ponto médio de uma função diferenciável no intervalo \\([a,b]\\) é dado por \\[\\overline{h} = \\frac{1}{b-a} \\int_a^b h(x) dx.\\] Para a função em questão, sob um olhar gráfico, temos que: Figura 6.7: Função seno(x), em que a reta azul destaca o ponto médio analítico da função. Caso não desejássemos calcular a integral acima, o que não justifica-se, uma vez que a integral é bastante simples, poderemos aproximar o valor médio da função \\(h(x)\\) utilizando uma simples simulação de MC. Para tanto, deveremos selecionar aleatoriamente diversos pontos da função e tirar uma média aritmética. Quanto mais pontos gearmos, melhor será a nossa aproximiação. # Número de réplicas de Monte Carlo (MC): N &lt;- 50L # Fixando uma semente. set.seed(1L) # Média dos valores da função: mean_est &lt;- mean(sin(runif(n = N, min = 0, max = 2 * pi))) Figura 6.8: Função seno(x), em que a reta azul destaca o ponto médio analítico e a reta em vermelho destaca o ponto médio estimado para 50 réplicas de MC, com os pontos selecionados estão destacados. 6.3.3 Integração por Monte Carlo O exercício anterior nos fornece tudo que precisaremos para desenvolver um método de MC para o cálculo aproximado de uma integral definida de uma função \\(h(x)\\) com \\(x \\in [a, b]\\). Se \\[\\overline{h} = \\frac{1}{b-a}\\int_a^b h(x) dx\\] e sabemos estimar \\(\\overline{h}\\) pelo método de MC, então saberemos caclular \\(\\int_a^b h(x) dx\\), uma vez que basta fazer: \\[\\int_a^b h(x) dx = (b - a)\\overline{h},\\] em que \\(\\overline{h}\\) é aproximado por MC. Observação: Para obtermos uma aproximação para a integral de uma função \\(h(x)\\) com \\(x \\in [a, b]\\), precisamos apenas calcular o ponto médio da função e multiplicar por \\((b-a)\\). Dessa forma, estimando o ponto médio de uma função por MC nos conduz diretamente ao método de MC para obter \\(\\int_a^b h(x) dx\\). Exemplo: Seja \\(X\\) uma v.a. tal que \\(X \\sim Weibull(\\alpha, \\beta)\\), com \\(\\alpha, \\beta &gt; 0\\) e \\(x \\geq 0\\). Implemente a função intmc(N = 1e3L, fun, lower = NULL, upper = NULL, ...), que aproxima por MC a integral de uma função, em que N é o número de réplicas de MC, fun é a função que desejamos integrar, lower é o limite inferior de integração, upper é o limite superior de integração e ... é o operador dot-dot-dot. Por meio da função intmc() e da função integrate(), obtenha uma aproximação para \\(P(X \\leq 2)\\). fdp_weibull &lt;- function(x, alpha, beta) dweibull(x, shape = alpha, scale = beta) intmc &lt;- function(N = 1e3L, fun, lower = NULL, upper = NULL, ...){ if (missing(fun)) stop (&quot;The function has been omitted.&quot;) if (is.null(lower) || is.null(upper)) stop (&quot;Integration limits must be specified.&quot;) # Gerando valores uniformes no suporte da função: u &lt;- runif(n = N, min = lower, max = upper) # Valor aproximado da integral: (upper - lower) * mean(fun(x = u, ...)) } # P(X &lt; 2): round(pweibull(q = 2, shape = 1.5, scale = 1.2), digits = 4L) ## [1] 0.8837 set.seed(1L) # P(X &lt; 2) por MC: round(intmc(N = 5e6, fun = fdp_weibull, lower = 0, upper = 2, alpha = 1.5, beta = 1.2), digits = 4L) ## [1] 0.8837 O método de integraçao de MC poderá ser entendido também por meio de uma interpretação estatística. Seja \\(h(x)\\) uma função, com \\(x \\in [a, b]\\) e suponha que desejamos obter uma estimativa para \\[I = \\int_a^b h(x) dx.\\] Note que a integral acima poderá ser reescrita, sem alterar o seu resultado, como: \\[I = (b - a) \\int_a^b h(x) \\frac{1}{b-a}dx.\\] Perceba também que se \\(X\\) é uma v.a., tal que \\(X \\sim \\mathcal{U}(a, b)\\), então, \\(f_X(x) = \\frac{1}{b-a}\\), com \\(a \\leq x \\leq b\\) é a f.d.p. de \\(X\\). Dessa forma, \\[\\begin{eqnarray} I &amp; = &amp; (b - a) \\int_a^b h(x) \\frac{1}{b-a}dx = (b - a) \\int_a^b h(x) f_X(x)dx = (b - a) \\times \\mathrm{E}[h(X)]\\\\ &amp; = &amp; (b - a) \\times \\mu. \\end{eqnarray}\\] Assim, perceba que o problema de calcular \\(I\\) recai sobre o problema de calcular um valor esperado, isto é, calcular \\(\\mu\\). Dessa forma, precisaremos de um \\(\\hat{\\mu}\\) que nos forneça uma boa estimativa para \\(\\mu\\). Consideremos \\[\\hat{\\mu} = n^{-1}\\sum_{i=1}^n h(X_i),\\] um estimador para \\(\\mu\\). Dessa forma, temos especificado um estimador para \\(I\\) que é dado por: \\[\\hat{I} = (b - a)\\hat{\\mu}.\\] Perceba que \\(\\hat{\\mu}\\) é um estimador não-viesado para \\(\\mu\\). Isso implica que \\(\\hat{I}\\) também será um estimador não-viesado para \\(I\\). Mais importante, temos que \\(\\hat{\\mu}\\) é um estimador consistente para \\(\\mu\\). Isso é verdade, uma vez que se \\(X_i, \\ldots, X_n\\) é uma sequência de v.a.’s i.i.d. em um mesmo espaço de probabilidade, então \\[P\\Big(|S_n - n\\mu| \\geq n\\varepsilon\\Big) \\leq \\frac{\\mathrm{Var}(S_n)}{\\varepsilon^2 n^2},\\] pela desigualdade de Chebychev, em que \\(S_n = \\sum_{i=1}^n h(X_i)\\). Como \\(X_i, \\ldots, X_n\\) é uma sequência de v.a.’s i.i.d., tal que \\(X_i \\sim \\mathcal{U}(a,b), \\, \\forall\\, i\\), então \\[\\mathrm{Var}(S_n) = n \\mathrm{Var}[h(X_i)].\\] Logo, \\[\\lim_{n \\to +\\infty}P\\Big(\\Big|S_n - n\\mu\\Big| \\geq n\\varepsilon\\Big) \\leq \\lim_{n \\to +\\infty}\\frac{\\mathrm{Var}[h(X_i)]}{n\\varepsilon^2} = 0,\\] uma vez que \\(h(x)\\) é uma função contínua no intervalo \\([a, b]\\), logo existe um \\(M\\) tal que \\(|h(X_i)| \\leq M, \\forall\\, i\\). Assim, temos que \\(\\hat{\\mu}\\) converge em probabilidade para \\(\\mu\\) (\\(\\hat{\\mu}\\) é consistente para se estimar \\(\\mu\\)) e denotamos por \\(\\hat{\\mu} \\overset{p}{\\to} \\mu\\). Sendo assim, temos que \\(\\hat{I}\\) é um estimador consistente para \\(I\\). Isso garante que a medida que tomamos mais pontos, mais nos aproximamos do valor verdadeiro da integral, ou seja, mais nos aproximamos de \\(I\\). Note que a variância de \\(\\hat{I}\\) é dada por: \\[\\mathrm{Var}(\\hat{I}) = (b - a)^2 \\mathrm{Var}(\\hat{\\mu}) = \\frac{(b - a)^2}{n}\\mathrm{Var}[h(X)].\\] Pela definição de variância, temos que \\[\\sigma^2 = \\mathrm{Var}(\\hat{I}) = \\mathrm{E}\\Big(\\hat{I}^2\\Big) - E^2(\\hat{I}) = \\gamma - \\eta^2.\\] Assim, um estimador para \\(\\mathrm{Var}(\\hat{I})\\) também poderá ser obtido utilizando um procedimento de MC, de tal forma que: \\[\\widehat{\\sigma}^2 = \\widehat{\\mathrm{Var}(\\hat{I})} = \\overline{\\widehat{\\gamma}} - \\overline{\\widehat{\\eta}}^2,\\] em que \\(\\overline{\\widehat{\\gamma}} = n^{-1} \\sum_{i=1}^n \\hat{I}_i^2\\) e \\(\\overline{\\widehat{\\eta}}^2 = \\Big(n^{-1}\\sum_{i=1}^n\\hat{I}_i\\Big)^2\\). Perceba que \\(\\hat{I}_i\\) é obtido por um procedimento de MC para cada \\(i\\), com \\(i = 1, \\ldots, n\\). Sendo assim, necessitamos de várias estimativas da integral para se obter uma estimativa de \\(\\mathrm{Var}(\\hat{I})\\) que também é um procedimento de MC. Exemplo: Abaixo é implementado a função intvarmc(N = 1e3L, fun, lower = NULL, upper = NULL, ...) que retona uma estimativa para a integral de uma função, a variância estimada por MC do estimador \\(\\hat{I}\\) e um vetor de estimativas \\(\\hat{I}\\) utilizados para o cálculo de \\(\\widehat{\\mathrm{Var}(\\hat{I})}\\) por MC. Em que N é a quantidade de réplicas de MC. Por padrão N = 1e3L; fun é a função contínua que desejamos integrar; lower é o limite inferior de integração; upper é o limite superior de integração; ... é o argumento dot-dot-dot (varargs) que será útil para passarmos outros argumentos à função que desejamos integrar. fdp_weibull &lt;- function(x, alpha, beta) dweibull(x, shape = alpha, scale = beta) intmc &lt;- function(N = 1e3L, fun, lower = NULL, upper = NULL, ...){ if (missing(fun)) stop (&quot;The function has been omitted.&quot;) if (is.null(lower) || is.null(upper)) stop (&quot;Integration limits must be specified.&quot;) # Gerando valores uniformes no suporte da função: u &lt;- runif(n = N, min = lower, max = upper) # Valor aproximado da integral: (upper - lower) * mean(fun(x = u, ...)) } # Essa função retorna uma estimativa da integral de uma função h(x) por MC # uma estimativa da da variância do estimador de MC para integral de h(x): intvarmc &lt;- function(N = 1e3L, fun, lower = NULL, upper = NULL, ...){ intmc_map &lt;- function(x, ...) intmc(N, fun, lower, upper, ...) i_hat &lt;- purrr::map_dbl(.x = 1:N, .f = intmc_map, ...) var_hat &lt;- mean(i_hat ^ 2) - mean(i_hat) ^ 2 list(i_hat = mean(i_hat), var_hat = var_hat, vec_ihat = i_hat) } set.seed(0L) result &lt;- intvarmc(N = 5e3L, fun = fdp_weibull, lower = 0, upper = 10, alpha = 1.5, beta = 1.5) str(result) ## List of 3 ## $ i_hat : num 1 ## $ var_hat : num 0.000503 ## $ vec_ihat: num [1:5000] 1.029 0.975 0.999 1.005 1.031 ... # Realizando um teste de normalidade pelo # teste de Shapiro-Wilk: shapiro.test(result$vec_ihat) ## ## Shapiro-Wilk normality test ## ## data: result$vec_ihat ## W = 0.99969, p-value = 0.6642 Uma vez que são médias, perceba que as estimativas obtidas por \\(\\hat{I}_1, \\ldots, \\hat{I}_n\\) aparentemente segue uma distribuição normal, em que \\(\\hat{I}_i \\sim \\mathcal{N}(I, \\sigma^2/n)\\), o que é garantido pelo Teorema Central do Limite. Construindo um histograma e realizando um teste de normalidade, temos: hist(result$vec_ihat, main = expression(paste(&quot;Estimativas &quot;, hat(I)[i])), xlab = expression(hat(I)[i]), ylab = &quot;Frequência&quot;, border = NA, col = rgb(1, 0.9, 0.8)) Observação: Note que a distribuição de \\(\\hat{I}_i, \\forall \\, i\\) é centrada no valor da integral que desejamos calcular. No caso do exercício acima, como a função é uma f.d.p, então a distribuição será centrada em 1. 6.3.4 Aproximando o valor de \\(\\pi\\) Uma outra aplicação bastante conhecida dos métodos de MC é a obtenção de um valor aproximado para a constante \\(\\pi\\). O método para aproximação do valor de \\(\\pi\\) é construído considerando inicialmente uma circunferência de raio (\\(r = 1\\)) na seguinte forma: Figura 4.4: Cicunferência centrada no ponton (0,0) de raio igual à 1 (um) e de área igual à constante de desejamos estimar. A estatégia por meio de um procedimento de MC é gerar massivamente (mil, 10 mil, 100 mil, …) pontos no interior do quadrado de área 1. Dessa forma, deveremos contabilizar a quantidade de pontos que cairam no interior da circunferência e dividir pelo total de pontos, isto é, desejamos obter a proporção de pontos que cairam dentro da circunferência, onde teremos, assim, uma aproximação da área. Porém, perceba que poderemos nos restringir ao primeiro quadrante, com área igual à \\(\\frac{\\pi}{4}\\). Dessa forma, considerando apenas o primerio quadrante, temos que a porporção de pontos que caem no interior da circunferência multiplicada por 4 irá fornecer uma aproximação para o valor de \\(\\pi\\). Exemplo: Implemente a função insideplot(x, y) que recebe como argumentos dois vetores de mesmo comprimento. A função deverá construir um gráfico do primeiro quadrante da circunferência, em um quadrado unitário, com os pontos formados pelos valores dos vetores, par a par, destancando de vermelho os pontos no interior da circunferência e de azul àqueles que caem fora dela. insideplot &lt;- function(x, y) { plot.new() plot.window(xlim = c(0, 1), ylim = c(0, 1)) axis(1); axis(2) title(xlab = &quot;x&quot;, ylab = &quot;y&quot;) x_circ &lt;- seq(0, 1, length.out = 1000L) y_circ &lt;- sqrt(1 - x_circ ^ 2) test &lt;- function(x, y){ if ((x ^ 2 + y ^ 2) &lt;= 1) points(x, y, col = &quot;red&quot;, pch = 19) else points(x, y, col = &quot;blue&quot;, pch = 19) } segments(0, 0, 1, 0, lwd = 2); segments(0, 0, 0, 1, lwd = 2) segments(0, 1, 1, 1, lwd = 2); segments(1, 0, 1, 1, lwd = 2) lines(x_circ, y_circ, lwd = 2L) invisible(mapply(FUN = test, x, y)) } x &lt;- c(0.42, 0.24, 0.81, 0.93) y &lt;- c(0.21, 0.47, 0.72, 0.85) insideplot(x, y) Figura 6.9: Resultado do uso da função insideplot() nos pontos (0.42, 0.21), (0.24, 0.47), (0.81, 0.72) e (0.93, 0.85), em que pontos vemelhos estão no interior da circunferência e pontos azuis fora dela. Exemplo: Implementando a função mcpi(N = 1e3L) que aproxima o valor da constante \\(\\pi\\) por meio de um procedimento de MC. A função mcpi() retornará o valor aproximado da constante \\(\\pi\\) e construirá o gráfico com os pontos gerados utilizando a função insideplot(). # Aproximando o valor da constante pi por MC: mcpi &lt;- function(N = 1e3L){ x &lt;- runif(n = N, min = 0, max = 1) y &lt;- runif(n = N, min = 0, max = 1) inside &lt;- function(x, y) ifelse((x ^ 2 + y ^ 2) &lt;= 1, TRUE, FALSE) insideplot(x, y) 4 * sum(mapply(FUN = inside, x, y)) / N # ou sum(purrr::map2_lgl(.x = x, .y = y, .f = inside)) / N } # Fixando uma semente: set.seed(1L) # Aproximando o valor de pi (mil réplicas): mcpi() ## [1] 3.148 6.3.5 Paralelizando um procedimento de Monte Carlo A classe de procedimentos de MC contemplam metodologias típias que podem ser paralelizadas, isto é, por se tratarem de procedimentos iterativos, cada iteração poderá ser realizada em paralelo. Porém, é importante deixar claro que nem todo o procedimento iterativo poderá ser paralelizado. Essa é uma restrição do ponto de vista matemático e não do ponto de vista de computação. Isso deve-se ao fato de que nem todos procedimentos iterativos são matematicamente independentes, isto é, nesses procedimentos, para realizarmos a iteração \\(t + 1\\) necessariamente devemos esperar pelos cálculos realizados na \\(t\\)-ésima iteração. Tipicamente, os procedimentos de MC são matematicamente independentes. Embora a construção de tais procedimentos que produzem amostras com as propriedades desejadas geralmente não seja difícil, a tarefa de garantir a convergência a uma taxa compatível com os recursos computacionais atuais continua sendo um grande desafio. Nos dias atuais, é comum observarmos códigos passíveis de paralização sem fazer o devido aproveitamento de todos os recursos computacionais disponíveis em um dado computador. Em dias atuais, é comum processadores e GPUS (Graphics Processing Unit) com vários núcleos de processamento. A linguagem R disponibiliza diversas bibliotecas para se trabalhar com computação paralela. Ente alguns pacotes importantes que viablizam o uso de computação paralela em R destaco o parallel e o snow (“Simple Network of Workstations”). Tempos atrás, havia também o pacote multicore que foi removido do CRAN, sendo substituído pelo pacote parallel. Diversas funções do pacote parallel são derivadas do pacote snow e do antigo pacote multicore. O pacote parallel reúne as melhores características desses pacotes, com algumas modificações e características próprias. Além desses pacote, há diversas outas bibliotecas em R disponíveis para implementação de códigos paralelizados. Porém, a maioria dessas bibliotecas utilizam-se do parallel e snow como backend para suas implementações. Por exemplo, foreach + doParallel normalmente são utilizados em conjunto para a criação de loops com execução em paralelo, em que utiliza-se das funções foreach() + %dopar% do pacote foreach. Nesse exemplo, o pacote doParallel atuará como uma interface para o pacote parallel que é o verdadeiro responsável para efetuar a paralelização do loop. Uma das vantagem do pacote parallel está no fato dele ser distribuído em conjunto com a linguagem R. Mais precisamente, o pacote parallel foi incluído, pela primeira vez, em 31 de Outubro de 2011, na versão 2.14.0 da linguagem R. Uma outra vantagem do pacote parallel é que ele necessita de menos configurações iniciais para a utilização dos seus funcionais em um procedimento de paralização multicore em um mesmo processador. A única desvantagem do pacote parallel diz respeito aos usuários do sistema operacional (SO) Windows, em que alguns de seus funcionais não irão funcionar de forma paralela. Porém, o pacote parallel dispõe de funcionais alternativos para a realização de computação paralela em Windows. A vantagem de utilizar-se um sistema *nix é que os funcionais que funcionam em Windows também funcionarão em sistemas *nix. Aqui trataremos apenas da paralelização multicore de memória compartilhada em um único processador, isto é, em um mesmo chip, utilizando a linguagem R. Para os exemplos, utilizaremos os típicos procedimentos de MC que são passíveis de execução em paralelo. Processadores com múltiplos núcleos são muito comuns nos dias atuais. Também é comum estamos implementando nossas simulações em computadores pessoais que normalmente possue apenas um único processador com vários núcleos de processamento. A ideia é discutir como aproveitarmos todo o recurso computacional desses processadores e assim usufruirmos de um código com maior performance, uma vez que temos esses recursos a nossa disposição. Abaixo encontra-se uma representação típica de um processador com vários núcleos de processamento, mais precisamente, 4 (cores) destacados em azul e 8 (oito) threads destacados em vermelho. Figura 6.10: Representação de um processador multicore (múltiplos núcleos), em que os retângulos vermelhos representam os pseudo-cores (hardware threads) e a parte cinza onde encontra-se o processador chamamos de soquete. Abaixo encontram-se listados alguns conceitos comumente utilizados em computação paralela. Entender essas nomenclaturas ajudará bastante a compreensão de textos em computação paralela. Nó: um único computador que consiste basicamente de uma placa-mãe com uma memória e um processador; Processador/soquete: a unidade física que contém um ou mais núcleos que fazem cálculos; Core/núcleo: a menor unidade de computação do processador. Cada core é capaz de executar um único programa/tarefa; Thread (hardware): também conhecido como core lógico, as threads, do ponto de vista de hardware, são unidades de computação dentro dos cores que poderá permitir que um core faça duas ou mais tarefas ao mesmo tempo. Trabalhador/worker: um processo independente que conduz o cálculo e fornece os resultados para o processo mestre/master. Alguns texto referem-se aos trabalhadores como threads (software), em que thread mestre/thread master é o processo mestre e as bifurcações geridas por esse processo principal em outros processos são chamados de threads escravas/slave threads. Importante: Com o pacote parallel é possível também fazer uso de computação paralela utilizando Message Passing Interface - MPI (um padrão de dados em computação paralela), quando temos a nossa disposição um cluster configurado com várias máquina (vários nós), cada um com vários processadores com múltiplos núcleos de processamento. Também é importante deixar destacar que nem sempre os custos que o computador tem em gerir diversos processos justifica a paralelização de um código. Por exemplo, é possível que um código funcione de forma mais eficiente quando executado de forma serial quando comparado ao seu análogo paralelo. 6.3.6 Speedup Uma forma de mensurar o ganho ou perda computacional ao executar um código em paralelo é utilizando a medida speedup que é definido como a relação de tempo gasto para executar uma terefa de forma serial com o tempo gasta para executar a mesma tarefa em \\(n\\) threads. Ou seja, se \\(S\\) é o speedup, então \\[S(n) = \\frac{T(1)}{T(n)},\\] em que \\(T(1)\\) é o tempo serial e \\(T(n)\\) é o tempo em paralelo ao considerar \\(N\\) cores, em um processador que suporta essa quantidade de núcleos. Assim, quanto maior o speedup, maior será o ganho computacional ao se paralelizar um código. Lei de Amdahl Se o tempo de processamento de uma tarefa pode ser escalonado linearmente com o número de núcleos utilizados em paralelo, dizemos que o código em paralelo produz uma aceleração linear, sendo este o melhor dos cenários. Porém, na maioria dos problemas em que desejamos paralelizar, o tempo de computação atinge uma “parede assintótica”, em que os benefícios de utilizar núcleos adicionais são compensados pelos custos adicionais de gerenciar o fluxo de informações entre tantos trabalhadores. Essa função assintótica poderá seguir a Lei de Amdahl, definida por Gene Myron Amdahl, em uma conferência, em 1967. A lei diz que: \\[T(n) = T(1)\\Big[s + \\frac{1}{n}(1 - s)\\Big],\\] em que \\(T(n)\\) é o tempo que um algoritmo leva para ser executado de forma paralela utilizando \\(n\\) núcleos e \\(s\\) é a proporção do código que deve ser executado de forma serial, sendo \\(1 - s\\) a proporção de código executado de forma paralela. Sendo assim, dado \\(s\\), o speedup teórico é dado por: \\[S(n) = \\frac{T(1)}{T(n)} = \\frac{T(1)}{T(1)\\Big[s + \\frac{1}{n}(1 - s)\\Big]} = \\frac{1}{s + \\frac{1}{n}(1-s)}.\\] Perceba que, \\[\\lim_{n \\to \\infty} \\frac{1}{s + \\frac{1}{n}(1-s)} = \\frac{1}{s},\\] é o speedup máximo alcançado, segundo essa lei. Figura 6.11: Speedup estimado utilizando a Lei de Amdhal levando em consideração a quantidade de núcleos disponiveis e a proporção de código passível de paralelização de um algoritmo. Nota: Existem diversas métricas para entender o comportamento de um aplicação paralela em face ao número de núcleos utilizados, em que todas elas tem suas limitações. A principal limitação da Lei de Amdahl é o fato dela ingnorar ao gerenciar-se diversos processos. O que é mais importante para os nossos objetivos é a conciência da existência de uma barreira assintótica para o speedup. Na prática, essa barreira torna-se-á bastante frequênte devido aos custos computacionais relacionados ao transporte de dados entre os processos que será muito provavelmente diminuído com o passar dos anos. 6.3.7 Pacote parallel O pacote parallel possui diversas funções úteis. Você poderá encontrar um tutorial do parallel clicando aqui. O pacote parallel possui diversas funções úteis, em que um vetor completo com o nome das funções pode ser obtido fazendo: library(parallel) ls(&quot;package:parallel&quot;) ## [1] &quot;clusterApply&quot; &quot;clusterApplyLB&quot; &quot;clusterCall&quot; ## [4] &quot;clusterEvalQ&quot; &quot;clusterExport&quot; &quot;clusterMap&quot; ## [7] &quot;clusterSetRNGStream&quot; &quot;clusterSplit&quot; &quot;detectCores&quot; ## [10] &quot;getDefaultCluster&quot; &quot;makeCluster&quot; &quot;makeForkCluster&quot; ## [13] &quot;makePSOCKcluster&quot; &quot;mc.reset.stream&quot; &quot;mcaffinity&quot; ## [16] &quot;mccollect&quot; &quot;mclapply&quot; &quot;mcMap&quot; ## [19] &quot;mcmapply&quot; &quot;mcparallel&quot; &quot;nextRNGStream&quot; ## [22] &quot;nextRNGSubStream&quot; &quot;parApply&quot; &quot;parCapply&quot; ## [25] &quot;parLapply&quot; &quot;parLapplyLB&quot; &quot;parRapply&quot; ## [28] &quot;parSapply&quot; &quot;parSapplyLB&quot; &quot;pvec&quot; ## [31] &quot;setDefaultCluster&quot; &quot;splitIndices&quot; &quot;stopCluster&quot; As funções que serão destacadas aqui e que nos ajudaram a paralelizar um procedimento de MC são as funções mclapply(), mcmapply(), mcMap() e detectCores(). Perceba que algumas funções iniciam-se com mc, o que faz alusão à expressão multicore (múltiplos núcleos). Dessa forma, mclapply() equivale ao funcional lapply(), porém trabalhando de forma paralela, mcmapply() é análogo paralelo do funcional mapply() e mcMap() é o analogo paralelo do funcional Map(). As funções mclapply() e mcmapply() trabalham de forma multicore, ou seja, sobre um único processador com vários núcleos físicos e lógicos. Isso é feito utilizando o conceito de FORK, sendo este um conceito de sistemas operacionais POSIX que está disponível em todas as plataformas R, exceto em Windows. O sistema FORK cria um novo processo de R tomando uma cópia completa do processo mestre, incluindo o espaço de trabalho e o estado de fluxo de números aleatórios. Porém, em um SO razoável, as cópias compartilham páginas de memória com o processo mestre até o momento em que o que é comum entre entre os processos seja modificado, permitindo assim que este procedimento de FORK seja eficiente. Exemplo: Comparando a execução serial e paralela da função intvarmc(). Como é possível observar, optou-se em paralelizar a função intmc() que é utilizado pela função intvarmc() para o cálculo das integrais aproximadas por um procedimento de MC. É possível observar que paralelizar a execução da função intvarmc() contribuiu significativamente na melhoria da peformance da função intvarmc(). Observe as saídas dos tempos de execução das funções intvarmc() (função com execução serial) e intvarmc_parallel() (cópia paralelizada da função intvarmc()): Código Serial: # Código Serial ----------------------------------------------------------- intvarmc &lt;- function(N = 1e3L, fun, lower = NULL, upper = NULL, ...){ intmc_map &lt;- function(x, ...) intmc(N, fun, lower, upper, ...) i_hat &lt;- purrr::map_dbl(.x = 1:N, .f = intmc_map, ...) var_hat &lt;- mean(i_hat ^ 2) - mean(i_hat) ^ 2 list(i_hat = mean(i_hat), var_hat = var_hat, vec_ihat = i_hat) } set.seed(0L) time_serial &lt;- system.time(result_serial &lt;- intvarmc(N = 5e3L, fun = fdp_weibull, lower = 0, upper = 10, alpha = 1.5, beta = 1.5)) result_serial$i_hat ## [1] 1.000779 Código Paralelizado: # Código Paralelizado ----------------------------------------------------- intvarmc_parallel &lt;- function(N = 1e3L, fun, lower = NULL, upper = NULL, ...){ intmc_map &lt;- function(x, ...) intmc(N, fun, lower, upper, ...) # Reescrita da função intmc() para que seja possível utilizar # em um funcional baseado no funcional lapply(). i_hat &lt;- unlist(parallel::mclapply(X = 1L:N, FUN = intmc_map, ..., mc.cores = parallel::detectCores())) var_hat &lt;- mean(i_hat ^ 2) - mean(i_hat) ^ 2 list(i_hat = mean(i_hat), var_hat = var_hat, vec_ihat = i_hat) } set.seed(0L) system.time(result_parallel &lt;- intvarmc_parallel(N = 5e3L, fun = fdp_weibull, lower = 0, upper = 10, alpha = 1.5, beta = 1.5)) ## usuário sistema decorrido ## 2.769 0.379 0.541 result_parallel$i_hat ## [1] 0.9996403 Importante: O código paralelizado no exemplo anterior irá verdadeiramente funcionar de forma paralela em sistemas *nix e não trabalhará corretamente em Windows. Isso se deve ao fato de muitas funções do pacote parallel serem derivadas do pacote multicore e utilizarem FORK, uma chamada de sistema POSIX não compatível com o SO Windows. Essas funções, em que FORK é apenas uma delas, constroem uma interface entre um processo e o SO. Em Windows, uma abordagem paralelizada também poderá ser implementada utilizando o pacote parallel, a custo de um pouco mais de passos, já que não há suporte à FORK. Como função mclapply() e funções derivadas fazem uso de FORK, deveremos considerar funções que não fazem uso de FORK. Exemplo: Implementação da função intvarmc_parallel() para que funcione de forma paralelizada em Windows. Perceba que foi necessário incluir mais passos e substituir a função mclapply() pela função parLapply() que também está disponível no pacote parallel. Assim como o FORK, o PSOCK é também uma chamada de sistema POSIX que define uma nova forma de transporte de dados e comunicação entre as threads e o processo mestre. O PSOCK faz algumas execuções do comando Rscript, conforme a quantidade de núcleos utilizados para realizar um trabalho. Nesse sistema, a comunicação das threads com o processo mestre se dá utilizando conecções de soquete. Sendo assim, quando deseja-se fazer uso de paralelismo multicore, em Windows, há a necessidade da criação de um cluster do tipo PSOCK. Nota: É sempre uma boa prática desligar as theads chamando a função stopCluster() ao final da execução da função em paralelo, muito embora em alguns tipos de clusters o encerramento é automático. Caso contrário, poderemos correr o risco de transbordar threads, por exemplo, se o tipo de cluster for alterado, o que poderá gerar diversos conflitos e inconsistências. # No Windows -------------------------------------------------------------- # Atribuindo a quantidade de núcleos disponíveis. cores &lt;- getOption(&quot;mc.cores&quot;, parallel::detectCores()) # Criando um cluster do tipo PSOCK. cl &lt;- makeCluster(cores, type = &quot;PSOCK&quot;) # Exportando as funções intmc() e fdp_weibull() para que sejam reconhecidas # em cada núcleo. clusterExport(cl = cl, varlist = c(&quot;intmc&quot;, &quot;fdp_weibull&quot;), envir = environment()) intvarmc_parallel &lt;- function(N = 1e3L, fun, lower = NULL, upper = NULL, ...){ # Reescrita da função intmc() para que seja possível utilizar # em um funcional baseado no funcional lapply(). intmc_map &lt;- function(x, ...) intmc(N, fun, lower, upper, ...) i_hat &lt;- unlist(parallel::parLapply(cl = cl, X = 1L:N, fun = intmc_map, ...)) var_hat &lt;- mean(i_hat ^ 2) - mean(i_hat) ^ 2 list(i_hat = mean(i_hat), var_hat = var_hat, vec_ihat = i_hat) } set.seed(0L) system.time(result_parallel &lt;- intvarmc_parallel(N = 5e3L, fun = fdp_weibull, lower = 0, upper = 10, alpha = 1.5, beta = 1.5)) stopCluster(cl) result_parallel$i_hat Tanto no exemplo de paralização em SO *nix utilizando FORK quanto em Windows utilizando um cluster PSOCK, a função intvarmc_parallel() mostrou-se mais eficiente do sua implementação serial. Porém, nos deparamos com o problema de reprodutibilidade. Perceba que fazer set.seed(0L) antes da execução da função intvarmc_parallel() não é suficiente para garantir os mesmos resultados. Como é de responsabilidade do SO distribuir os processos entre as threads (hardware) disponíveis e o gerador de números pseudo-aleatórios toma estados distintos a depender da thread (hardware) ao qual um trabalhador foi alocado, sequências distintas muito provavelmente serão observadas entre execuções de uma função paralelizada. O pacote parallel contém uma implementação das ideias de L’Ecuyer et al. (2002), cujo o artigo é livre e poderá ser acessado com o link abaixo: L’Ecuyer P, Simard R, Chen EJ, Kelton WD (2002). An object-oriented random-number package with many long streams and substreams. Operations Research, 50, 1073–5. URL link. Assim, em R, é possível fazer uso desse gerador que recebe o nome L’Ecuyer-CMRG. Isso poderá ser feito passando a string \"L'Ecuyer-CMRG\", alem da semente, para o agumento kind da função set.seed() ou alterando o gerador utilizando a função \"RNGkind()\" e posteriormente utilizando a função set.seed() para fixar uma semente. As duas formas estão apresentadas abaixo: # Forma 1: set.seed(seed = 0L, kind = &quot;L&#39;Ecuyer-CMRG&quot;) # Forma 2: RNGkind(kind = &quot;L&#39;Ecuyer-CMRG&quot;) set.seed(0L) Exemplo: Reproduções da função intvarmc_parallel() usando os sistemas FORK e PSOCK, repectivamente. Trata-se de um exemplo que poderá ser reproduzível, uma vez que foi utilizado o gerador L’Ecuyer-CMRG com semente fixa. Paralelização usando FORK: # Código Paralelizado ----------------------------------------------------- intvarmc_parallel &lt;- function(N = 1e3L, fun, lower = NULL, upper = NULL, ...){ intmc_map &lt;- function(x, ...) intmc(N, fun, lower, upper, ...) # Reescrita da função intmc() para que seja possível utilizar # em um funcional baseado no funcional lapply(). i_hat &lt;- unlist(parallel::mclapply(X = 1L:N, FUN = intmc_map, ..., mc.cores = parallel::detectCores())) var_hat &lt;- mean(i_hat ^ 2) - mean(i_hat) ^ 2 list(i_hat = mean(i_hat), var_hat = var_hat, vec_ihat = i_hat) } # Fixando uma semente para um gerador que poderá # trabalhar sobre processos paralelizados. set.seed(0L, kin = &quot;L&#39;Ecuyer-CMRG&quot;) time_parallel &lt;- system.time(result_parallel &lt;- intvarmc_parallel(N = 5e3L, fun = fdp_weibull, lower = 0, upper = 10, alpha = 1.5, beta = 1.5)) # Uma aproximação para integral de uma função # utilizando um procedimento de MC: result_parallel$i_hat ## [1] 0.9993872 # Speedup: time_serial[3]/time_parallel[3] ## elapsed ## 2.824966 Paralelização usando PSOCK: # No Windows -------------------------------------------------------------- # Atribuindo a quantidade de núcleos disponíveis. cores &lt;- getOption(&quot;mc.cores&quot;, parallel::detectCores()) # Criando um cluster do tipo PSOCK. cl &lt;- makeCluster(cores, type = &quot;PSOCK&quot;) # Exportando as funções intmc() e fdp_weibull() para que sejam reconhecidas # em cada núcleo. clusterExport(cl = cl, varlist = c(&quot;intmc&quot;, &quot;fdp_weibull&quot;), envir = environment()) intvarmc_parallel &lt;- function(N = 1e3L, fun, lower = NULL, upper = NULL, ...){ # Reescrita da função intmc() para que seja possível utilizar # em um funcional baseado no funcional lapply(). intmc_map &lt;- function(x, ...) intmc(N, fun, lower, upper, ...) i_hat &lt;- unlist(parallel::parLapply(cl = cl, X = 1L:N, fun = intmc_map, ...)) var_hat &lt;- mean(i_hat ^ 2) - mean(i_hat) ^ 2 list(i_hat = mean(i_hat), var_hat = var_hat, vec_ihat = i_hat) } # Fixando uma semente para um gerador que poderá # trabalhar sobre processos paralelizados. set.seed(0L, kin = &quot;L&#39;Ecuyer-CMRG&quot;) system.time(result_parallel &lt;- intvarmc_parallel(N = 5e3L, fun = fdp_weibull, lower = 0, upper = 10, alpha = 1.5, beta = 1.5)) stopCluster(cl) # Uma aproximação para integral de uma função # utilizando um procedimento de MC: result_parallel$i_hat # Speedup: time_serial[3]/time_parallel[3] Exercício 1 - Explique o que é um procedimento de Monte Carlo (MC)? 2 - Enuncie um procedimento de MC para o cálculo de uma integral de uma função contínua em um intervalo \\([a, b]\\). Depois, escreva um algoritmo para o procedimento enunciado. 3 - Seja \\(\\hat{I}\\) o estimador de \\(I = \\int_a^b f(x) dx\\), em que \\(f\\) é uma função contínua no intervalo \\([a, b]\\), em que \\[\\hat{I} = (b-a) \\frac{\\sum_{i=1}^n f(x_i)}{n},\\] cuja amostra é obtida pelo procedimento de MC enunciado no exercício anterior. Mostre que \\(\\hat{I}\\) é um estimador não-viesado e consistente para \\(I\\). 4 - Implemente a função intmc() que calcula a integral de uma função contínua qualquer definida em um intervalo \\([a, b]\\). Dica: Utilize o operador dot-dot-dot (operador varargs) para que a função intmc() possa receber argumentos da função que será integrada por um procedimento de MC. 5 - Seja \\(X_1, \\ldots, X_n\\) uma amostra aleatória de v.a.’s tal que \\(X_i \\sim \\mathcal{N}(\\mu = 0, \\sigma^2 = 1)\\). Construa um procedimento de MC para avaliar os estimadores \\(\\hat{\\sigma}^2\\) e \\(S^2\\) de \\(\\sigma^2\\), em que \\[\\begin{eqnarray} \\hat{\\sigma}^2 &amp;=&amp; \\frac{1}{n}\\sum_{i=1}^n (X_i - \\overline{X})^2\\\\ &amp;\\mathrm{e}&amp;\\\\ S^2 &amp;=&amp; \\frac{1}{n - 1}\\sum_{i=1}^n (X_i - \\overline{X})^2. \\end{eqnarray}\\] Dica: Para comparar, utilize uma aproximação do Erro Quadrático Medio (EQM) obtida por um procedimento de MC. Lembre-se, se \\(\\hat{\\theta}\\) é um estimador para \\(\\theta\\), então o \\(\\mathrm{EQM}(\\hat{\\theta}) = \\mathrm{E}[(\\hat{\\theta} - \\theta)^2]\\). 6 - Um dado experimento aleatório consiste em lançar dois dados não viesados (6 lados em cada dado) e observar a soma obtida. Por meio de um procedimento de MC, obtenha a probabilidade aproximada da soma ser par. Simule para \\(N = 10, 100, 1000, 10000\\) e \\(100000\\), em que \\(N\\) é o número de réplicas de MC. O que você observa? Explique. 7 - Walter está jogando um jogo com dois dados de 6 lados equiprováveis. O jogo consiste em lançar ambos os dados e caso a soma dos dados seja divisível por 3, ele ganhará, percendo em caso contrário. Realize um procedimento de MC para avaliar o jogo e responda a pergunta: Em média o jogo é favorável ao jogador? 8 - Suponha que tenhamos uma urna com bolas de mesmo tamanho enumeradas de 1 à 100. Considere o experimento aleatório de retirar uma bola da urna e observar o seu número até obtermos a bola com número desejado. Nesse experimento, será considerado reposição, isto é, caso não tenha sido observado a numeração desejada, a bola será devolvida à urna. Implemente um procedimento de MC considerando 10 mil repetições desse experimento e obtenha a média das retiradas necessárias para obter-se o número desejado. Além disso, retorne uma aproximação da probabilidade de se obter o número desejado. Dica: considere o número 77 como o número desejado. 9 - Um dono de cassino estuda disponibilizar um novo jogo e solicita uma consultoria estatística para saber se o jogo será viável para o cassino, isto é, se o valor esperado em dólares do lucro obtido será positivo, em média. Realize uma simulação de MC considerando 100 mil jogos e obtenha o valor médio de lançamentos de um jogador bem como a probabilidade (aproximada) de um jogador jogar apenas uma única partida. Além disso, responda: Se um jogador paga \\(\\$\\) 10 dólares para jogar e lucra \\(\\$\\) 1,50 dólares por cada jogada, o jogo é rentável para o dono do cassino? Regras do Jogo: Dois dados são lançados e caso a soma for 5, 6, 7, 8 ou 9 o jogo termina imediatamente; Se nenhum dos resultamos acima for obtido, o jogador continua lançando ambos os dados até obter uma soma igual à 11 ou 12. 10 - Explique, com suas palavras, o que é paralelização multicore. Descreva brevemente os conceitos de nó, thread (hardware), processo master e trabalhadores. 11 - Descreva brevemente o sistema FORK e PSOCK. Apresente um exemplo de um código paralelizado usando o sistema FORK e PSOCK, respectivamente. 12 - Defina speedup e explique o significado. 13 - Ao paralelizar um algoritmo, teremos garantia da melhoria do desempenho computacional? Explique. 14 - Enuncie a Lei de Amdahl e cite um ponto negativo dessa lei. Qual o valor máximo de speedup definido por essa lei? 15 - Implemente um procedimento de MC, utilizando paralelismo para avaliar o cálculo do estimador de \\(\\hat{I}\\) definido no exercício 3. Obtenha o speedup e discuta o resultado. 16 - Implemente uma versão paralela dos exercícios 5, 6, 7, 8 e 9. Avalie a implementação paralela com a versão serial. Houveram melhoria no desempenho computacional utilizando as versões paralelizadas? Explique. 17 - Implemente de forma paralela, uma função que realiza uma simulação de MC para avaliar o procedimento de MC para aproximação da constante \\(\\pi\\). Obtenha o speedup e discuta o resultado. Considere 100 mil iterações em ambos os procedimentos. 18 - Implemente uma versão paralelizada do método da aceitação e rejeição para geração de números pseudo-aleatórios. Obtenha o speedup e discuta se houve ou não melhorias no desempenho computacional ao considerar-se a versão paralelizada. Explique. "]
]
